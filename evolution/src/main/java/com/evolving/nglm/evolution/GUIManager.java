/*****************************************************************************
*
*  GUIManager.java
*
*****************************************************************************/

package com.evolving.nglm.evolution;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.InetSocketAddress;
import java.net.URL;
import java.net.URLClassLoader;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Properties;
import java.util.Set;
import java.util.TimeZone;
import java.util.UUID;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.evolving.nglm.evolution.commoditydelivery.CommodityDeliveryException;
import com.evolving.nglm.evolution.commoditydelivery.CommodityDeliveryManagerRemovalUtils;

import org.apache.http.HttpEntity;
import org.apache.http.HttpHeaders;
import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpRequestBase;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.errors.SerializationException;
import org.apache.kafka.common.errors.WakeupException;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.common.serialization.Serializer;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.search.SearchScrollRequest;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestClientBuilder;
import org.elasticsearch.client.indices.GetIndexRequest;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.Scroll;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.reflections.Reflections;
import org.reflections.scanners.ResourcesScanner;
import org.reflections.util.ClasspathHelper;
import org.reflections.util.ConfigurationBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.evolving.nglm.core.Alarm;
import com.evolving.nglm.core.AlternateID;
import com.evolving.nglm.core.ConnectSerde;
import com.evolving.nglm.core.Deployment;
import com.evolving.nglm.core.JSONUtilities;
import com.evolving.nglm.core.JSONUtilities.JSONUtilitiesException;
import com.evolving.nglm.core.LicenseChecker;
import com.evolving.nglm.core.LicenseChecker.LicenseState;
import com.evolving.nglm.core.NGLMRuntime;
import com.evolving.nglm.core.Pair;
import com.evolving.nglm.core.RLMDateUtils;
import com.evolving.nglm.core.ReferenceDataReader;
import com.evolving.nglm.core.ReferenceDataValue;
import com.evolving.nglm.core.ServerException;
import com.evolving.nglm.core.ServerRuntimeException;
import com.evolving.nglm.core.StringKey;
import com.evolving.nglm.core.SubscriberIDService;
import com.evolving.nglm.core.SubscriberIDService.SubscriberIDServiceException;
import com.evolving.nglm.core.SystemTime;
import com.evolving.nglm.core.UniqueKeyServer;
import com.evolving.nglm.evolution.CommodityDeliveryManager.CommodityDeliveryOperation;
import com.evolving.nglm.evolution.CommodityDeliveryManager.CommodityDeliveryRequest;
import com.evolving.nglm.evolution.CommodityDeliveryManager.CommodityDeliveryStatus;
import com.evolving.nglm.evolution.CustomerMetaData.MetaData;
import com.evolving.nglm.evolution.DeliveryManager.DeliveryStatus;
import com.evolving.nglm.evolution.DeliveryManagerAccount.Account;
import com.evolving.nglm.evolution.DeliveryManagerForNotifications.MessageStatus;
import com.evolving.nglm.evolution.DeliveryRequest.ActivityType;
import com.evolving.nglm.evolution.DeliveryRequest.Module;
import com.evolving.nglm.evolution.EmptyFulfillmentManager.EmptyFulfillmentRequest;
import com.evolving.nglm.evolution.EvaluationCriterion.CriterionDataType;
import com.evolving.nglm.evolution.EvaluationCriterion.CriterionOperator;
import com.evolving.nglm.evolution.GUIManagedObject.GUIManagedObjectType;
import com.evolving.nglm.evolution.GUIManagedObject.IncompleteObject;
import com.evolving.nglm.evolution.GUIService.GUIManagedObjectListener;
import com.evolving.nglm.evolution.INFulfillmentManager.INFulfillmentRequest;
import com.evolving.nglm.evolution.Journey.GUINode;
import com.evolving.nglm.evolution.Journey.JourneyStatus;
import com.evolving.nglm.evolution.Journey.SubscriberJourneyStatus;
import com.evolving.nglm.evolution.Journey.TargetingType;
import com.evolving.nglm.evolution.JourneyHistory.NodeHistory;
import com.evolving.nglm.evolution.JourneyService.JourneyListener;
import com.evolving.nglm.evolution.LoyaltyProgram.LoyaltyProgramType;
import com.evolving.nglm.evolution.LoyaltyProgramChallenge.ChallengeLevel;
import com.evolving.nglm.evolution.LoyaltyProgramChallengeHistory.LevelHistory;
import com.evolving.nglm.evolution.LoyaltyProgramHistory.TierHistory;
import com.evolving.nglm.evolution.LoyaltyProgramMission.MissionStep;
import com.evolving.nglm.evolution.LoyaltyProgramMissionHistory.StepHistory;
import com.evolving.nglm.evolution.MailNotificationManager.MailNotificationManagerRequest;
import com.evolving.nglm.evolution.NotificationManager.NotificationManagerRequest;
import com.evolving.nglm.evolution.PurchaseFulfillmentManager.PurchaseFulfillmentRequest;
import com.evolving.nglm.evolution.PurchaseFulfillmentManager.PurchaseFulfillmentStatus;
import com.evolving.nglm.evolution.PushNotificationManager.PushNotificationManagerRequest;
import com.evolving.nglm.evolution.SMSNotificationManager.SMSNotificationManagerRequest;
import com.evolving.nglm.evolution.SegmentationDimension.SegmentationDimensionTargetingType;
import com.evolving.nglm.evolution.SubscriberProfileService.EngineSubscriberProfileService;
import com.evolving.nglm.evolution.SubscriberProfileService.SubscriberProfileServiceException;
import com.evolving.nglm.evolution.ThirdPartyManager.API;
import com.evolving.nglm.evolution.Token.TokenStatus;
import com.evolving.nglm.evolution.complexobjects.ComplexObjectType;
import com.evolving.nglm.evolution.complexobjects.ComplexObjectTypeService;
import com.evolving.nglm.evolution.complexobjects.ComplexObjectTypeSubfield;
import com.evolving.nglm.evolution.elasticsearch.ElasticsearchClientAPI;
import com.evolving.nglm.evolution.elasticsearch.ElasticsearchClientException;
import com.evolving.nglm.evolution.elasticsearch.ElasticsearchManager;
import com.evolving.nglm.evolution.grafana.GrafanaUtils;
import com.evolving.nglm.evolution.offeroptimizer.DNBOMatrixAlgorithmParameters;
import com.evolving.nglm.evolution.offeroptimizer.GetOfferException;
import com.evolving.nglm.evolution.offeroptimizer.ProposedOfferDetails;
import com.google.gson.JsonArray;
import com.evolving.nglm.evolution.reports.ReportCsvFactory;
import com.evolving.nglm.evolution.reports.bdr.BDRReportDriver;
import com.evolving.nglm.evolution.reports.bdr.BDRReportMonoPhase;
import com.evolving.nglm.evolution.reports.journeycustomerstatistics.JourneyCustomerStatisticsReportDriver;
import com.evolving.nglm.evolution.reports.notification.NotificationReportDriver;
import com.evolving.nglm.evolution.reports.notification.NotificationReportMonoPhase;
import com.evolving.nglm.evolution.reports.odr.ODRReportDriver;
import com.evolving.nglm.evolution.reports.odr.ODRReportMonoPhase;
import com.evolving.nglm.evolution.tenancy.Tenant;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;

import kafka.utils.Log4jControllerRegistration;

public class GUIManager
{
  /*****************************************
  *
  *  ProductID
  *
  *****************************************/

  public static String ProductID = "Evolution-GUIManager";

  protected static final DeliveryRequest.DeliveryPriority DELIVERY_REQUEST_PRIORITY = DeliveryRequest.DeliveryPriority.High;

  public enum API
  {
    //
    //  GUI APIs
    //  

    getStaticConfiguration("getStaticConfiguration"),
    getSupportedLanguages("getSupportedLanguages"),
    getSupportedCurrencies("getSupportedCurrencies"),
    getSupportedTimeUnits("getSupportedTimeUnits"),
    getSupportedRelationships("getSupportedRelationships"),
    getCallingChannelProperties("getCallingChannelProperties"),
    getCatalogCharacteristicUnits("getCatalogCharacteristicUnits"),
    getSupportedDataTypes("getSupportedDataTypes"),
    getSupportedEvents("getSupportedEvents"),
    getLoyaltyProgramPointsEvents("getLoyaltyProgramPointsEvents"),
    getSupportedTargetingTypes("getSupportedTargetingTypes"),
    getProfileCriterionFields("getProfileCriterionFields"),
    getProfileCriterionFieldIDs("getProfileCriterionFieldIDs"),
    getProfileCriterionField("getProfileCriterionField"),
    getFullProfileCriterionFields("getFullProfileCriterionFields"),
    getFullProfileCriterionFieldIDs("getFullProfileCriterionFieldIDs"),
    getFullProfileCriterionField("getFullProfileCriterionField"),
    getPresentationCriterionFields("getPresentationCriterionFields"),
    getPresentationCriterionFieldIDs("getPresentationCriterionFieldIDs"),
    getPresentationCriterionField("getPresentationCriterionField"),
    getJourneyCriterionFields("getJourneyCriterionFields"),
    getJourneyCriterionFieldIDs("getJourneyCriterionFieldIDs"),
    getJourneyCriterionField("getJourneyCriterionField"),
    getJourneyTriggerTargetingCriterionFields("getJourneyTriggerTargetingCriterionFields"),
    getOfferProperties("getOfferProperties"),
    getScoringEngines("scoringEngines"),
    getOfferOptimizationAlgorithms("getOfferOptimizationAlgorithms"),
    getNodeTypes("getNodeTypes"),
    getJourneyToolbox("getJourneyToolbox"),
    getJourneyList("getJourneyList"),
    getJourneySummaryList("getJourneySummaryList"),
    getJourney("getJourney"),
    putJourney("putJourney"),
    removeJourney("removeJourney"),
    updateJourney("updateJourney"),
    startJourney("startJourney"),
    setStatusJourney("setStatusJourney"),
    stopJourney("stopJourney"),
    getCampaignToolbox("getCampaignToolbox"),
    getCampaignList("getCampaignList"),
    getCampaignSummaryList("getCampaignSummaryList"),
    getCampaign("getCampaign"),
    putCampaign("putCampaign"),
    removeCampaign("removeCampaign"),
    updateCampaign("updateCampaign"),
    setStatusCampaign("setStatusCampaign"),
    startCampaign("startCampaign"),
    stopCampaign("stopCampaign"),
    getWorkflowToolbox("getWorkflowToolbox"),
    getFullWorkflowList("getFullWorkflowList"),
    getWorkflowList("getWorkflowList"),
    getWorkflowSummaryList("getWorkflowSummaryList"),
    getWorkflow("getWorkflow"),
    putWorkflow("putWorkflow"),
    removeWorkflow("removeWorkflow"),
    updateWorkflow("updateWorkflow"),
    setStatusWorkflow("setStatusWorkflow"),
    
    getLoyaltyWorkflowToolbox("getLoyaltyWorkflowToolbox"),
    
        
    getBulkCampaignList("getBulkCampaignList"),
    getBulkCampaignSummaryList("getBulkCampaignSummaryList"),
    getBulkCampaign("getBulkCampaign"),
    getBulkCampaignCapacity("getBulkCampaignCapacity"),
    putBulkCampaign("putBulkCampaign"),
    removeBulkCampaign("removeBulkCampaign"),
    updateBulkCampaign("updateBulkCampaign"),
    setStatusBulkCampaign("setStatusBulkCampaign"),
    startBulkCampaign("startBulkCampaign"),
    stopBulkCampaign("stopBulkCampaign"),
    getJourneyTemplateList("getJourneyTemplateList"),
    getJourneyTemplateSummaryList("getJourneyTemplateSummaryList"),
    getJourneyTemplate("getJourneyTemplate"),
    putJourneyTemplate("putJourneyTemplate"),
    removeJourneyTemplate("removeJourneyTemplate"),
    setStatusJourneyTemplate("setStatusJourneyTemplate"),
    getJourneyNodeCount("getJourneyNodeCount"),
    getSegmentationDimensionList("getSegmentationDimensionList"),
    getSegmentationDimensionSummaryList("getSegmentationDimensionSummaryList"),
    getSegmentationDimension("getSegmentationDimension"),
    putSegmentationDimension("putSegmentationDimension"),
    removeSegmentationDimension("removeSegmentationDimension"),
    setStatusSegmentationDimension("setStatusSegmentationDimension"),
    getCountBySegmentationRanges("getCountBySegmentationRanges"),
    getCountBySegmentationRangesBySegmentID("getCountBySegmentationRangesBySegmentID"),
    getCountBySegmentationEligibility("getCountBySegmentationEligibility"),
    evaluateProfileCriteria("evaluateProfileCriteria"),
    getUCGDimensionSummaryList("getUCGDimensionSummaryList"),
    getPointList("getPointList"),
    getPointSummaryList("getPointSummaryList"),
    getPoint("getPoint"),
    putPoint("putPoint"),
    removePoint("removePoint"),
    setStatusPoint("setStatusPoint"),
    getOfferList("getOfferList"),
    getOfferSummaryList("getOfferSummaryList"),
    getOffer("getOffer"),
    putOffer("putOffer"),
    removeOffer("removeOffer"),
    updateOffer("updateOffer"),
    setStatusOffer("setStatusOffer"),
    getReportGlobalConfiguration("getReportGlobalConfiguration"),
    getReportList("getReportList"),
    putReport("putReport"),
    launchReport("launchReport"),
    downloadReport("downloadReport"),
    getPresentationStrategyList("getPresentationStrategyList"),
    getPresentationStrategySummaryList("getPresentationStrategySummaryList"),
    getPresentationStrategy("getPresentationStrategy"),
    putPresentationStrategy("putPresentationStrategy"),
    removePresentationStrategy("removePresentationStrategy"),
    setStatusPresentationStrategy("setStatusPresentationStrategy"),
    getScoringStrategyList("getScoringStrategyList"),
    getScoringStrategySummaryList("getScoringStrategySummaryList"),
    getScoringStrategy("getScoringStrategy"),
    putScoringStrategy("putScoringStrategy"),
    removeScoringStrategy("removeScoringStrategy"),
    setStatusScoringStrategy("putScoringStrategy"),
    getDNBOMatrixList("getDNBOMatrixList"),
    getDNBOMatrixSummaryList("getDNBOMatrixSummaryList"),
    getDNBOMatrix("getDNBOMatrix"),
    putDNBOMatrix("putDNBOMatrix"),
    removeDNBOMatrix("removeDNBOMatrix"),
    setStatusDNBOMatrix("putDNBOMatrix"),
    getScoringTypesList("getScoringTypesList"),
    getDNBOMatrixVariablesList("getDNBOMatrixVariablesList"),
    getCallingChannelList("getCallingChannelList"),
    getCallingChannelSummaryList("getCallingChannelSummaryList"),
    getCallingChannel("getCallingChannel"),
    putCallingChannel("putCallingChannel"),
    setStatusCallingChannel("setStatusCallingChannel"),
    removeCallingChannel("removeCallingChannel"),
    getSalesChannelList("getSalesChannelList"),
    getSalesChannelSummaryList("getSalesChannelSummaryList"),
    getSalesChannel("getSalesChannel"),
    putSalesChannel("putSalesChannel"),
    removeSalesChannel("removeSalesChannel"),
    setStatusSalesChannel("setStatusSalesChannel"),
    getSupplierList("getSupplierList"),
    getSupplierSummaryList("getSupplierSummaryList"),
    getSupplier("getSupplier"),
    putSupplier("putSupplier"),
    removeSupplier("removeSupplier"),
    setStatusSupplier("setStatusSupplier"),
    getProductList("getProductList"),
    getProductSummaryList("getProductSummaryList"),
    getProduct("getProduct"),
    putProduct("putProduct"),
    updateProduct("updateProduct"),
    removeProduct("removeProduct"),
    setStatusProduct("setStatusProduct"),
    getCatalogCharacteristicList("getCatalogCharacteristicList"),
    getCatalogCharacteristicSummaryList("getCatalogCharacteristicSummaryList"),
    getCatalogCharacteristic("getCatalogCharacteristic"),
    putCatalogCharacteristic("putCatalogCharacteristic"),
    removeCatalogCharacteristic("removeCatalogCharacteristic"),
    setStatusCatalogCharacteristic("setStatusCatalogCharacteristic"),
    getContactPolicyList("getContactPolicyList"),
    getContactPolicySummaryList("getContactPolicySummaryList"),
    getContactPolicy("getContactPolicy"),
    putContactPolicy("putContactPolicy"),
    removeContactPolicy("removeContactPolicy"),
    setStatusContactPolicy("setStatusContactPolicy"),
    getJourneyObjectiveList("getJourneyObjectiveList"),
    getJourneyObjectiveSummaryList("getJourneyObjectiveSummaryList"),
    getJourneyObjective("getJourneyObjective"),
    putJourneyObjective("putJourneyObjective"),
    removeJourneyObjective("removeJourneyObjective"),
    setStatusJourneyObjective("setStatusJourneyObjective"),
    getOfferObjectiveList("getOfferObjectiveList"),
    getOfferObjectiveSummaryList("getOfferObjectiveSummaryList"),
    getOfferObjective("getOfferObjective"),
    putOfferObjective("putOfferObjective"),
    removeOfferObjective("removeOfferObjective"),
    setStatusOfferObjective("setStatusOfferObjective"),
    getProductTypeList("getProductTypeList"),
    getProductTypeSummaryList("getProductTypeSummaryList"),
    getProductType("getProductType"),
    putProductType("putProductType"),
    removeProductType("removeProductType"),
    setStatusProductType("setStatusProductType"),
    getUCGRuleList("getUCGRuleList"),
    getUCGRuleSummaryList("getUCGRuleSummaryList"),
    getUCGRule("getUCGRule"),
    putUCGRule("putUCGRule"),
    removeUCGRule("removeUCGRule"),
    setStatusUCGRule("setStatusUCGRule"),
    getDeliverableList("getDeliverableList"),
    putDeliverable("putDeliverable"),
    removeDeliverable("removeDeliverable"),
    getDeliverableSummaryList("getDeliverableSummaryList"),
    getDeliverable("getDeliverable"),
    setStatusDeliverable("setStatusDeliverable"),
    getDeliverableByName("getDeliverableByName"),
    getTokenTypeList("getTokenTypeList"),
    getTokenTypeSummaryList("getTokenTypeSummaryList"),
    putTokenType("putTokenType"),
    getTokenType("getTokenType"),
    removeTokenType("removeTokenType"),
    setStatusTokenType("setStatusTokenType"),
    getTokenCodesFormats("getTokenCodesFormats"),
    
    getVoucherTypeList("getVoucherTypeList"),
    getVoucherTypeSummaryList("getVoucherTypeSummaryList"),
    putVoucherType("putVoucherType"),
    getVoucherType("getVoucherType"),
    setStatusVoucherType("setStatusVoucherType"),
    removeVoucherType("removeVoucherType"),

    getVoucherCodeFormatList("getVoucherCodeFormatList"),
    generateVouchers("generateVouchers"),
    
    getVoucherList("getVoucherList"),
    getVoucherSummaryList("getVoucherSummaryList"),
    putVoucher("putVoucher"),
    getVoucher("getVoucher"),
    removeVoucher("removeVoucher"),
    setStatusVoucher("setStatusVoucher"),
    redeemVoucher("redeemVoucher"),
    extendVoucherValidity("extendVoucherValidity"),
    expireVoucher("expireVoucher"),

    getVoucherCodePatternList("getVoucherCodePatternList"),
    
    getMailTemplateList("getMailTemplateList"),
    getFullMailTemplateList("getFullMailTemplateList"),
    getMailTemplateSummaryList("getMailTemplateSummaryList"),
    getMailTemplate("getMailTemplate"),
    putMailTemplate("putMailTemplate"),
    removeMailTemplate("removeMailTemplate"),
    setStatusMailTemplate("setStatusMailTemplate"),
    getSMSTemplateList("getSMSTemplateList"),
    getFullSMSTemplateList("getFullSMSTemplateList"),
    getSMSTemplateSummaryList("getSMSTemplateSummaryList"),
    getSMSTemplate("getSMSTemplate"),
    putSMSTemplate("putSMSTemplate"),
    removeSMSTemplate("removeSMSTemplate"),
    setStatusSMSTemplate("setStatusSMSTemplate"),
    
    getPushTemplateList("getPushTemplateList"),
    getFullPushTemplateList("getFullPushTemplateList"),
    getPushTemplateSummaryList("getPushTemplateSummaryList"),
    getPushTemplate("getPushTemplate"),
    putPushTemplate("putPushTemplate"),
    removePushTemplate("removePushTemplate"),
    setStatusPushTemplate("setStatusPushTemplate"),
    
    getDialogTemplateList("getDialogTemplateList"),
    getFullDialogTemplateList("getFullDialogTemplateList"),
    getDialogTemplateSummaryList("getDialogTemplateSummaryList"),
    getDialogTemplate("getDialogTemplate"),
    putDialogTemplate("putDialogTemplate"),
    removeDialogTemplate("removeDialogTemplate"),
    setStatusDialogTemplate("setStatusDialogTemplate"),
    
    getFulfillmentProviders("getFulfillmentProviders"),
    getPaymentMeans("getPaymentMeans"),
    getPaymentMeanList("getPaymentMeanList"),
    getPaymentMeanSummaryList("getPaymentMeanSummaryList"),
    getPaymentMean("getPaymentMean"),
    putPaymentMean("putPaymentMean"),
    removePaymentMean("removePaymentMean"),
    setStatusPaymentMean("setStatusPaymentMean"),
    getDashboardCounts("getDashboardCounts"),
    getCustomer("getCustomer"),
    getCustomerMetaData("getCustomerMetaData"),
    getCustomerBDRs("getCustomerBDRs"),
    getCustomerEDRs("getCustomerEDRs"),
    getCustomerODRs("getCustomerODRs"),
    getCustomerMessages("getCustomerMessages"),
    getCustomerJourneys("getCustomerJourneys"),
    getCustomerCampaigns("getCustomerCamapigns"),
    getCustomerPoints("getCustomerPoints"),
    getCustomerLoyaltyPrograms("getCustomerLoyaltyPrograms"),
    refreshUCG("refreshUCG"),
    putUploadedFile("putUploadedFile"),
    putUploadedFileWithVariables("putUploadedFileWithVariables"),
    getUploadedFileList("getUploadedFileList"),
    getUploadedFileSummaryList("getUploadedFileSummaryList"),
    removeUploadedFile("removeUploadedFile"),
    getCustomerAlternateIDs("getCustomerAlternateIDs"),
    getCustomerAvailableCampaigns("getCustomerAvailableCampaigns"),
    getTargetList("getTargetList"),
    getTargetSummaryList("getTargetSummaryList"),
    putTarget("putTarget"),
    getTarget("getTarget"),
    setStatusTarget("setStatusTarget"),
    removeTarget("removeTarget"),
    updateCustomer("updateCustomer"),
    updateCustomerParent("updateCustomerParent"),
    removeCustomerParent("removeCustomerParent"),
    getCommunicationChannelList("getCommunicationChannelList"),
    getCommunicationChannelSummaryList("getCommunicationChannelSummaryList"),
    getCommunicationChannel("getCommunicationChannel"),
    putCommunicationChannel("putCommunicationChannel"),
    getBlackoutPeriodsList("getBlackoutPeriodsList"),
    getBlackoutPeriodsSummaryList("getBlackoutPeriodsSummaryList"),
    getBlackoutPeriods("getBlackoutPeriods"),
    putBlackoutPeriods("putBlackoutPeriods"),
    removeBlackoutPeriods("removeBlackoutPeriods"),
    setStatusBlackoutPeriods("setStatusBlackoutPeriods"),
    
    getTimeWindowsList("getTimeWindowsList"),
    getTimeWindowsSummaryList("getTimeWindowsSummaryList"),
    getTimeWindows("getTimeWindows"),
    putTimeWindows("putTimeWindows"),
    removeTimeWindows("removeTimeWindows"),

    getLoyaltyProgramTypeList("getLoyaltyProgramTypeList"),
    getLoyaltyProgramList("getLoyaltyProgramList"),
    getLoyaltyProgramChallengeList("getLoyaltyProgramChallengeList"),
    getLoyaltyProgramMissionList("getLoyaltyProgramMissionList"),
    
    getLoyaltyProgramSummaryList("getLoyaltyProgramSummaryList"),
    getLoyaltyProgramChallengeSummaryList("getLoyaltyProgramChallengeSummaryList"),
    getLoyaltyProgramMissionSummaryList("getLoyaltyProgramMissionSummaryList"),
    
    getLoyaltyProgram("getLoyaltyProgram"),
    getLoyaltyProgramChallenge("getLoyaltyProgramChallenge"),
    getLoyaltyProgramMission("getLoyaltyProgramMission"),
    
    putLoyaltyProgram("putLoyaltyProgram"),
    putLoyaltyProgramChallenge("putLoyaltyProgramChallenge"),
    putLoyaltyProgramMission("putLoyaltyProgramMission"),
    updateMission("updateMission"),
    updateChallenge("updateChallenge"),
    
    removeLoyaltyProgram("removeLoyaltyProgram"),
    setStatusLoyaltyProgram("setStatusLoyaltyProgram"),
    
    getResellerList("getResellerList"),
    getResellerSummaryList("getResellerSummaryList"),
    getReseller("getReseller"),
    putReseller("putReseller"),
    removeReseller("removeReseller"),
    setStatusReseller("setStatusReseller"),
    enterCampaign("enterCampaign"),
    creditBonus("creditBonus"),
    debitBonus("debitBonus"),
    getExclusionInclusionTargetList("getExclusionInclusionTargetList"),
    getExclusionInclusionTargetSummaryList("getExclusionInclusionTargetSummaryList"),
    putExclusionInclusionTarget("putExclusionInclusionTarget"),
    getExclusionInclusionTarget("getExclusionInclusionTarget"),
    removeExclusionInclusionTarget("removeExclusionInclusionTarget"),
    setStatusExclusionInclusionTarget("setStatusExclusionInclusionTarget"),
    getSegmentContactPolicyList("getSegmentContactPolicyList"),
    getSegmentContactPolicySummaryList("getSegmentContactPolicySummaryList"),
    putSegmentContactPolicy("putSegmentContactPolicy"),
    getSegmentContactPolicy("getSegmentContactPolicy"),
    removeSegmentContactPolicy("removeSegmentContactPolicy"),
    setStatusSegmentContactPolicy("setStatusSegmentContactPolicy"),
    getBillingModes("getBillingModes"),
    getPartnerTypes("getPartnerTypes"),
    getCriterionFieldAvailableValuesList("getCriterionFieldAvailableValuesList"),
    getCriterionFieldAvailableValuesSummaryList("getCriterionFieldAvailableValuesSummaryList"),
    getCriterionFieldAvailableValues("getCriterionFieldAvailableValues"),
    putCriterionFieldAvailableValues("putCriterionFieldAvailableValues"),
    removeCriterionFieldAvailableValues("removeCriterionFieldAvailableValues"),
    setStatusCriterionFieldAvailableValues("setStatusCriterionFieldAvailableValues"),
    getEffectiveSystemTime("getEffectiveSystemTime"),
    getCustomerNBOs("getCustomerNBOs"),
    getTokensCodesList("getTokensCodesList"),
    acceptOffer("acceptOffer"),
    purchaseOffer("purchaseOffer"),
    getTokenEventDetails("getTokenEventDetails"),
    getTenantList("getTenantList"),
    getOffersList("getOffersList"),
    launchExtract("launchExtract"),
    downloadExtractFile("downloadExtractFile"),
    launchAndDownloadExtract("launchAndDownloadExtract"),

    getComplexObjectTypeList("getComplexObjectTypeList"),
    getComplexObjectTypeSummaryList("getComplexObjectTypeSummaryList"),
    getComplexObjectType("getComplexObjectType"),
    putComplexObjectType("putComplexObjectType"),
    removeComplexObjectType("removeComplexObjectType"),

    //
    //  configAdaptor APIs
    //

    configAdaptorSupportedLanguages("configAdaptorSupportedLanguages"),
    configAdaptorSubscriberMessageTemplate("configAdaptorSubscriberMessageTemplate"),
    configAdaptorOffer("configAdaptorOffer"),
    configAdaptorProduct("configAdaptorProduct"),
    configAdaptorPresentationStrategy("configAdaptorPresentationStrategy"),
    configAdaptorScoringStrategy("configAdaptorScoringStrategy"),
    configAdaptorCallingChannel("configAdaptorCallingChannel"),
    configAdaptorSalesChannel("configAdaptorSalesChannel"),
    configAdaptorCommunicationChannel("configAdaptorCommunicationChannel"),
    configAdaptorBlackoutPeriods("configAdaptorBlackoutPeriods"),
    configAdaptorContactPolicy("configAdaptorContactPolicy"),
    configAdaptorSegmentationDimension("configAdaptorSegmentationDimension"),
    configAdaptorCampaign("configAdaptorCampaign"),
    configAdaptorJourneyObjective("configAdaptorJourneyObjective"),
    configAdaptorProductType("configAdaptorProductType"),
    configAdaptorOfferObjective("configAdaptorOfferObjective"),
    configAdaptorScoringEngines("configAdaptorScoringEngines"),
    configAdaptorPresentationCriterionFields("configAdaptorPresentationCriterionFields"),
    configAdaptorDefaultNoftificationDailyWindows("configAdaptorDefaultNoftificationDailyWindows"),
    configAdaptorDeliverable("configAdaptorDeliverable"),
    configAdaptorSourceAddress("configAdaptorSourceAddress"),
    
    getSourceAddressList("getSourceAddressList"),
    getSourceAddressSummaryList("getSourceAddressSummaryList"),
    getSourceAddress("getSourceAddress"),
    putSourceAddress("putSourceAddress"),
    removeSourceAddress("removeSourceAddress"),

    setStatusSourceAddress("setStatusSourceAddress"),

    putSimpleOfferThirdParty("putSimpleOfferThirdParty"),
    getSimpleOfferListThirdParty("getSimpleOfferListThirdParty"),
    removeSimpleOfferThirdParty("removeSimpleOfferThirdparty"),

    putSimpleOffer("putSimpleOffer"),
    getSimpleOffer("getSimpleOffer"),
    getSimpleOfferList("getSimpleOfferList"),
    getSimpleOfferSummaryList("getSimpleOfferSummaryList"),
    removeSimpleOffer("removeSimpleOffer"),
    
    loyaltyProgramOptIn("loyaltyProgramOptIn"),
    loyaltyProgramOptOut("loyaltyProgramOptOut"),


    getDependencies("getDependencies"),
    
    getSoftwareVersions("getSoftwareVersions"),

    
    //
    //  structor
    //
    Unknown("(unknown)");
    private int methodIndex;
    private API(int methodIndex) { this.methodIndex = methodIndex; }
    public int getMethodIndex() { return methodIndex; }
    private String externalRepresentation;
    private API(String externalRepresentation) { this.externalRepresentation = externalRepresentation; }
    public String getExternalRepresentation() { return externalRepresentation; }
    public static API fromExternalRepresentation(String externalRepresentation) { for (API enumeratedValue : API.values()) { if (enumeratedValue.getExternalRepresentation().equalsIgnoreCase(externalRepresentation)) return enumeratedValue; } return Unknown; }
  }

  /*****************************************
  *
  *  configuration
  *
  *****************************************/

  //
  //  logger
  //

  private static final Logger log = LoggerFactory.getLogger(GUIManager.class);

  //
  //  license
  //

  private LicenseChecker licenseChecker = null;

  /*****************************************
  *
  *  data
  *
  *****************************************/

  //
  //  static
  //

  private static final int RESTAPIVersion = 1;
  private static Method guiManagerExtensionEvaluateEnumeratedValuesMethod;

  //
  //  instance
  //

  protected KafkaProducer<byte[], byte[]> kafkaProducer;
  private HttpServer restServer;
  protected ElasticsearchClientAPI elasticsearch;
  
  protected DynamicCriterionFieldService dynamicCriterionFieldService;
  protected JourneyService journeyService;
  protected JourneyTemplateService journeyTemplateService;
  protected SegmentationDimensionService segmentationDimensionService;
  protected PointService pointService;
  protected ComplexObjectTypeService complexObjectTypeService;
  protected OfferService offerService;
  protected ReportService reportService;
  protected PaymentMeanService paymentMeanService;
  protected ScoringStrategyService scoringStrategyService;
  protected PresentationStrategyService presentationStrategyService;
  protected DNBOMatrixService dnboMatrixService;
  protected CallingChannelService callingChannelService;
  protected SalesChannelService salesChannelService;
  protected SourceAddressService sourceAddressService;
  protected SupplierService supplierService;
  protected ProductService productService;
  protected CatalogCharacteristicService catalogCharacteristicService;
  protected ContactPolicyService contactPolicyService;
  protected JourneyObjectiveService journeyObjectiveService;
  protected OfferObjectiveService offerObjectiveService;
  protected ProductTypeService productTypeService;
  protected UCGRuleService ucgRuleService;
  protected DeliverableService deliverableService;
  protected TokenTypeService tokenTypeService;
  protected VoucherTypeService voucherTypeService;
  protected VoucherService voucherService;
  protected SubscriberMessageTemplateService subscriberMessageTemplateService;
  protected SubscriberProfileService subscriberProfileService;
  protected SubscriberIDService subscriberIDService;
  protected ReferenceDataReader<String,SubscriberGroupEpoch> subscriberGroupEpochReader;
  protected ReferenceDataReader<String,RenamedProfileCriterionField> renamedProfileCriterionFieldReader;
  protected String getCustomerAlternateID;
  protected UploadedFileService uploadedFileService;
  protected TargetService targetService;
  protected CommunicationChannelBlackoutService communicationChannelBlackoutService;
  protected CommunicationChannelTimeWindowService communicationChannelTimeWindowService;
  protected LoyaltyProgramService loyaltyProgramService;
  protected ExclusionInclusionTargetService exclusionInclusionTargetService;
  protected ResellerService resellerService;
  protected SegmentContactPolicyService segmentContactPolicyService;
  protected SharedIDService subscriberGroupSharedIDService;
  protected DynamicEventDeclarationsService dynamicEventDeclarationsService;
  protected CriterionFieldAvailableValuesService criterionFieldAvailableValuesService;
  protected ElasticsearchManager elasticsearchManager;
  protected static Method externalAPIMethodJourneyActivated;
  protected static Method externalAPIMethodJourneyDeactivated;
  
  protected ZookeeperUniqueKeyServer zuks;
  protected ZookeeperUniqueKeyServer zuksVoucherChange;
  protected KafkaResponseListenerService<StringKey,PurchaseFulfillmentRequest> purchaseResponseListenerService;
  protected KafkaResponseListenerService<StringKey,VoucherChange> voucherChangeResponseListenerService;
  protected int httpTimeout = Deployment.getPurchaseTimeoutMs();

  protected static final String MULTIPART_FORM_DATA = "multipart/form-data"; 
  protected static final String FILE_REQUEST = "file"; 
  protected static final String FILE_UPLOAD_META_DATA= "fileUploadMetaData"; 

  //
  //  context
  //

  protected GUIManagerContext guiManagerContext;
  
  //
  // helper classes
  //
  
  private GUIManagerBaseManagement guiManagerBaseManagement;
  private GUIManagerLoyaltyReporting guiManagerLoyaltyReporting;
  private GUIManagerGeneral guiManagerGeneral;
  
  //
  //  properties
  //
  
  /*****************************************
  *
  *  epochServer
  *
  *****************************************/

  protected static UniqueKeyServer epochServer = new UniqueKeyServer();
  

  /*****************************************
  *
  *  main
  *
  *****************************************/

  public static void main(String[] args) throws Exception
  {
    ClassLoader cl = ClassLoader.getSystemClassLoader();

    URL[] urls = ((URLClassLoader)cl).getURLs();

    for(URL url: urls){
      System.out.println(url.getFile());
    }

    
    NGLMRuntime.initialize(true);
    GUIManager guiManager = new GUIManager();
    new LoggerInitialization().initLogger();
    guiManager.start(args);
  }

  /****************************************
  *
  *  start
  *
  *****************************************/

  private void start(String[] args)
  {
    /*****************************************
    *
    *  configuration
    *
    *****************************************/

    int apiRestPort = Integer.parseInt(args[0]);
    
    String nodeID = System.getProperty("nglm.license.nodeid");

    String bootstrapServers = Deployment.getBrokerServers();
	String apiProcessKey = "NOT_USED";
    String dynamicCriterionFieldTopic = Deployment.getDynamicCriterionFieldTopic();
    String journeyTopic = Deployment.getJourneyTopic();
    String journeyTemplateTopic = Deployment.getJourneyTemplateTopic();
    String segmentationDimensionTopic = Deployment.getSegmentationDimensionTopic();
    String pointTopic = Deployment.getPointTopic();
    String complexObjectTypeTopic = Deployment.getComplexObjectTypeTopic();
    String offerTopic = Deployment.getOfferTopic();
    String reportTopic = Deployment.getReportTopic();
    String paymentMeanTopic = Deployment.getPaymentMeanTopic();
    String presentationStrategyTopic = Deployment.getPresentationStrategyTopic();
    String dnboMatrixTopic = Deployment.getDNBOMatrixTopic();
    String scoringStrategyTopic = Deployment.getScoringStrategyTopic();
    String callingChannelTopic = Deployment.getCallingChannelTopic();
    String salesChannelTopic = Deployment.getSalesChannelTopic();
    String sourceAddresTopic = Deployment.getSourceAddressTopic();
    String supplierTopic = Deployment.getSupplierTopic();
    String productTopic = Deployment.getProductTopic();
    String catalogCharacteristicTopic = Deployment.getCatalogCharacteristicTopic();
    String contactPolicyTopic = Deployment.getContactPolicyTopic();
    String journeyObjectiveTopic = Deployment.getJourneyObjectiveTopic();
    String offerObjectiveTopic = Deployment.getOfferObjectiveTopic();
    String productTypeTopic = Deployment.getProductTypeTopic();
    String ucgRuleTopic = Deployment.getUCGRuleTopic();
    String deliverableTopic = Deployment.getDeliverableTopic();
    String tokenTypeTopic = Deployment.getTokenTypeTopic();
    String voucherTypeTopic = Deployment.getVoucherTypeTopic();
    String voucherTopic = Deployment.getVoucherTopic();
    String subscriberMessageTemplateTopic = Deployment.getSubscriberMessageTemplateTopic();
    String subscriberGroupEpochTopic = Deployment.getSubscriberGroupEpochTopic();
    String renamedProfileCriterionFieldTopic = Deployment.getRenamedProfileCriterionFieldTopic();
    String redisServer = Deployment.getRedisSentinels();
    String subscriberProfileEndpoints = Deployment.getSubscriberProfileEndpoints();
    String uploadedFileTopic = Deployment.getUploadedFileTopic();
    String targetTopic = Deployment.getTargetTopic();
    String communicationChannelTopic = Deployment.getCommunicationChannelTopic();
    String communicationChannelBlackoutTopic = Deployment.getCommunicationChannelBlackoutTopic();
    String communicationChannelTimeWindowTopic = Deployment.getCommunicationChannelTimeWindowTopic();
    String loyaltyProgramTopic = Deployment.getLoyaltyProgramTopic();
    String exclusionInclusionTargetTopic = Deployment.getExclusionInclusionTargetTopic();
    String resellerTopic = Deployment.getResellerTopic();
    String segmentContactPolicyTopic = Deployment.getSegmentContactPolicyTopic();
    String dynamicEventDeclarationsTopic = Deployment.getDynamicEventDeclarationsTopic();
    String criterionFieldAvailableValuesTopic = Deployment.getCriterionFieldAvailableValuesTopic();
    
    this.getCustomerAlternateID = Deployment.getGetCustomerAlternateID();

    //
    //  log
    //

    log.info("main START: on port {}", apiRestPort);

    //
    //  license
    //

    licenseChecker = new LicenseChecker(ProductID, nodeID, Deployment.getZookeeperRoot(), Deployment.getZookeeperConnect());

    //
    //  guiManagerExtensionEvaluateEnumeratedValuesMethod
    //

    try
      {
        guiManagerExtensionEvaluateEnumeratedValuesMethod = (Deployment.getGUIManagerExtensionClass() != null) ? Deployment.getGUIManagerExtensionClass().getMethod("evaluateEnumeratedValues",GUIManagerContext.class,String.class,Date.class,boolean.class) : null;
      }
    catch (NoSuchMethodException e)
      {
        throw new RuntimeException(e);
      }

    //
    //  externalAPIMethodJourneyActivated
    //

    try
      {
        externalAPIMethodJourneyActivated = (Deployment.getEvolutionEngineExternalAPIClass() != null) ? Deployment.getEvolutionEngineExternalAPIClass().getMethod("processDataJourneyActivated", Journey.class) : null;
        externalAPIMethodJourneyDeactivated = (Deployment.getEvolutionEngineExternalAPIClass() != null) ? Deployment.getEvolutionEngineExternalAPIClass().getMethod("processDataJourneyDeactivated", String.class, JourneyService.class) : null;
      }
    catch (NoSuchMethodException e)
      {
        throw new ServerRuntimeException(e);
      }
    
    //
    // ZookeeperUniqueKeyServer
    //
 
    zuks = new ZookeeperUniqueKeyServer(CommodityDeliveryManager.COMMODITY_DELIVERY_TYPE);
    zuksVoucherChange = new ZookeeperUniqueKeyServer("voucherchange");

    //
    // ElasticsearchClientAPI
    //

    try
    {
      elasticsearch = new ElasticsearchClientAPI("GUIManager");
    }
    catch (ElasticsearchException e)
    {
      throw new ServerRuntimeException("could not initialize elasticsearch client", e);
    }

    /*****************************************
    *
    *  kafka producer for the segmentationDimensionListener
    *
    *****************************************/

    Properties producerProperties = new Properties();
    producerProperties.put("bootstrap.servers", bootstrapServers);
    producerProperties.put("acks", "all");
    producerProperties.put("key.serializer", "org.apache.kafka.common.serialization.ByteArraySerializer");
    producerProperties.put("value.serializer", "org.apache.kafka.common.serialization.ByteArraySerializer");
    kafkaProducer = new KafkaProducer<byte[], byte[]>(producerProperties);

    /*****************************************
    *
    *  services - construct
    *
    *****************************************/

    JourneyListener journeyListener = new JourneyListener()
    {
      @Override public void journeyActivated(Journey journey) {
          log.debug("journeyActivated: " + journey.getJourneyID()+" "+journey.getJourneyName());

          //
          // send the evaluate target order to evolution engine
          //

          if (journey.getTargetIDs() != null)
          {
            EvaluateTargets evaluateTargets = new EvaluateTargets(Collections.<String>singleton(journey.getJourneyID()), journey.getTargetIDs());
            kafkaProducer.send(new ProducerRecord<byte[], byte[]>(Deployment.getEvaluateTargetsTopic(), EvaluateTargets
                  .serde().serializer().serialize(Deployment.getEvaluateTargetsTopic(), evaluateTargets)));
          }

          //
          //  externalAPIMethodJourneyActivated
          //

          if (externalAPIMethodJourneyActivated != null)
            {
              try
              {
                Pair<String, JSONObject> result = (Pair<String,JSONObject>) externalAPIMethodJourneyActivated.invoke(null, journey);
                JSONObject json = result.getSecondElement();
                if (json != null)
                  {
                    String topicID = result.getFirstElement();
                    ExternalAPITopic apiTopic = Deployment.getExternalAPITopics().get(topicID);
                    if (apiTopic != null)
                      {
                        String topic = apiTopic.getName();
                        kafkaProducer.send(new ProducerRecord<byte[], byte[]>(
                            topic,
                            new Serdes.StringSerde().serializer().serialize(topic, journey.getJourneyID()),
                            new Serdes.StringSerde().serializer().serialize(topic, json.toJSONString())));
                      }
                    else
                      {
                        log.info("journeyActivated: unknown topicID" + topicID);
                      }
                  }
              }
              catch (IllegalAccessException|InvocationTargetException e)
              {
                throw new RuntimeException(e);
              }
            }

          //
          //  FileVariables
          //

          if (TargetingType.FileVariables == journey.getTargetingType() && journey.getTargetingFileVariableID() != null)
            {
              Date now = SystemTime.getCurrentTime();
              String targetingFileID = journey.getTargetingFileVariableID();
              if (log.isDebugEnabled()) log.debug("fileVariable trigger will be generated from file {} for journey {}", targetingFileID, journey.getGUIManagedObjectDisplay());
              UploadedFile targetingFile = uploadedFileService.getActiveUploadedFile(targetingFileID, now);
              if (targetingFile != null) uploadedFileService.createFileWithVariableEvents(targetingFile, subscriberIDService, kafkaProducer);
            }
        }

      @Override public void journeyDeactivated(String guiManagedObjectID)
      {
        log.debug("journeyDeactivated: " + guiManagedObjectID);
        if (externalAPIMethodJourneyDeactivated != null)
          {
            try
            {
              Pair<String, JSONObject> result = (Pair<String,JSONObject>) externalAPIMethodJourneyDeactivated.invoke(null, guiManagedObjectID, journeyService);
              JSONObject json = result.getSecondElement();
              if (json != null)
                {
                  String topicID = result.getFirstElement();
                  ExternalAPITopic apiTopic = Deployment.getExternalAPITopics().get(topicID);
                  if (apiTopic != null)
                    {
                      String topic = apiTopic.getName();
                      kafkaProducer.send(new ProducerRecord<byte[], byte[]>(
                          topic,
                          new Serdes.StringSerde().serializer().serialize(topic, guiManagedObjectID),
                          new Serdes.StringSerde().serializer().serialize(topic, json.toJSONString())));
                    }
                  else
                    {
                      log.info("journeyDeactivated: unknown topicID" + topicID);
                    }
                }
            }
            catch (IllegalAccessException|InvocationTargetException e)
            {
              throw new RuntimeException(e);
            }
          }
      }
    };
    //TODO: very bad dÃ©geulasse implÃ©mentation : (dÃ©pendence du CriterionContext.initialize(dynamicCriterionFieldService) avec JourneyService)
    dynamicCriterionFieldService = new DynamicCriterionFieldService(bootstrapServers, "guimanager-dynamiccriterionfieldservice-"+apiProcessKey, dynamicCriterionFieldTopic, true);
    CriterionContext.initialize(dynamicCriterionFieldService);
    journeyService = new JourneyService(bootstrapServers, "guimanager-journeyservice-" + apiProcessKey, journeyTopic, true, journeyListener);
    journeyTemplateService = new JourneyTemplateService(bootstrapServers, "guimanager-journeytemplateservice-" + apiProcessKey, journeyTemplateTopic, true);
    dynamicEventDeclarationsService = new DynamicEventDeclarationsService(bootstrapServers, "guimanager-dynamiceventdeclarationsservice-"+apiProcessKey, dynamicEventDeclarationsTopic, true);
    segmentationDimensionService = new SegmentationDimensionService(bootstrapServers, "guimanager-segmentationDimensionservice-" + apiProcessKey, segmentationDimensionTopic, true);
    pointService = new PointService(bootstrapServers, "guimanager-pointservice-" + apiProcessKey, pointTopic, true);
    complexObjectTypeService = new ComplexObjectTypeService(bootstrapServers, "guimanager-complexObjectTypeservice-" + apiProcessKey, complexObjectTypeTopic, true);
    offerService = new OfferService(bootstrapServers, "guimanager-offerservice-" + apiProcessKey, offerTopic, true);
    // set notifyOnSignificantChange = false
    reportService = new ReportService(bootstrapServers, "guimanager-reportservice-" + apiProcessKey, reportTopic, true, null, false);
    paymentMeanService = new PaymentMeanService(bootstrapServers, "guimanager-paymentmeanservice-" + apiProcessKey, paymentMeanTopic, true);
    scoringStrategyService = new ScoringStrategyService(bootstrapServers, "guimanager-scoringstrategyservice-" + apiProcessKey, scoringStrategyTopic, true);
    presentationStrategyService = new PresentationStrategyService(bootstrapServers, "guimanager-presentationstrategyservice-" + apiProcessKey, presentationStrategyTopic, true);
    dnboMatrixService = new DNBOMatrixService(bootstrapServers, "guimanager-dnbomatrixservice-" + apiProcessKey, dnboMatrixTopic, true);
    callingChannelService = new CallingChannelService(bootstrapServers, "guimanager-callingchannelservice-" + apiProcessKey, callingChannelTopic, true);
    salesChannelService = new SalesChannelService(bootstrapServers, "guimanager-saleschannelservice-" + apiProcessKey, salesChannelTopic, true);
    sourceAddressService = new SourceAddressService(bootstrapServers, "guimanager-sourceaddressservice-" + apiProcessKey, sourceAddresTopic, true);
    supplierService = new SupplierService(bootstrapServers, "guimanager-supplierservice-" + apiProcessKey, supplierTopic, true);
    productService = new ProductService(bootstrapServers, "guimanager-productservice-" + apiProcessKey, productTopic, true);
    catalogCharacteristicService = new CatalogCharacteristicService(bootstrapServers, "guimanager-catalogcharacteristicservice-" + apiProcessKey, catalogCharacteristicTopic, true);
    contactPolicyService = new ContactPolicyService(bootstrapServers, "guimanager-contactpolicieservice-" + apiProcessKey, contactPolicyTopic, true);
    journeyObjectiveService = new JourneyObjectiveService(bootstrapServers, "guimanager-journeyobjectiveservice-" + apiProcessKey, journeyObjectiveTopic, true);
    offerObjectiveService = new OfferObjectiveService(bootstrapServers, "guimanager-offerobjectiveservice-" + apiProcessKey, offerObjectiveTopic, true);
    productTypeService = new ProductTypeService(bootstrapServers, "guimanager-producttypeservice-" + apiProcessKey, productTypeTopic, true);
    ucgRuleService = new UCGRuleService(bootstrapServers,"guimanager-ucgruleservice-"+apiProcessKey,ucgRuleTopic,true);
    deliverableService = new DeliverableService(bootstrapServers, "guimanager-deliverableservice-" + apiProcessKey, deliverableTopic, true);
    tokenTypeService = new TokenTypeService(bootstrapServers, "guimanager-tokentypeservice-" + apiProcessKey, tokenTypeTopic, true);
    voucherTypeService = new VoucherTypeService(bootstrapServers, "guimanager-vouchertypeservice-" + apiProcessKey, voucherTypeTopic, true);
    subscriberMessageTemplateService = new SubscriberMessageTemplateService(bootstrapServers, "guimanager-subscribermessagetemplateservice-" + apiProcessKey, subscriberMessageTemplateTopic, true);
    subscriberProfileService = new EngineSubscriberProfileService(subscriberProfileEndpoints, 1);
    subscriberIDService = new SubscriberIDService(redisServer, "guimanager-" + apiProcessKey);
    subscriberGroupEpochReader = ReferenceDataReader.<String,SubscriberGroupEpoch>startReader("guimanager-subscribergroupepoch", bootstrapServers, subscriberGroupEpochTopic, SubscriberGroupEpoch::unpack);
    renamedProfileCriterionFieldReader = ReferenceDataReader.<String,RenamedProfileCriterionField>startReader("guimanager-renamedprofilecriterionfield", bootstrapServers, renamedProfileCriterionFieldTopic, RenamedProfileCriterionField::unpack);
    uploadedFileService = new UploadedFileService(bootstrapServers, "guimanager-uploadfileservice-" + apiProcessKey, uploadedFileTopic, true);
    targetService = new TargetService(bootstrapServers, "guimanager-targetservice-" + apiProcessKey, targetTopic, true);
    voucherService = new VoucherService(bootstrapServers, "guimanager-voucherservice-" + apiProcessKey, voucherTopic, true,elasticsearch,uploadedFileService);
    communicationChannelBlackoutService = new CommunicationChannelBlackoutService(bootstrapServers, "guimanager-blackoutservice-" + apiProcessKey, communicationChannelBlackoutTopic, true);
    communicationChannelTimeWindowService = new CommunicationChannelTimeWindowService(bootstrapServers, "guimanager-timewindowservice-" + apiProcessKey, communicationChannelTimeWindowTopic, true);
    loyaltyProgramService = new LoyaltyProgramService(bootstrapServers, "guimanager-loyaltyprogramservice-"+apiProcessKey, loyaltyProgramTopic, true);
    exclusionInclusionTargetService = new ExclusionInclusionTargetService(bootstrapServers, "guimanager-exclusioninclusiontargetservice-" + apiProcessKey, exclusionInclusionTargetTopic, true);
    resellerService = new ResellerService(bootstrapServers, "guimanager-resellerservice-"+apiProcessKey, resellerTopic, true);
    segmentContactPolicyService = new SegmentContactPolicyService(bootstrapServers, "guimanager-segmentcontactpolicyservice-"+apiProcessKey, segmentContactPolicyTopic, true);
    subscriberGroupSharedIDService = new SharedIDService(segmentationDimensionService, targetService, exclusionInclusionTargetService);
    criterionFieldAvailableValuesService = new CriterionFieldAvailableValuesService(bootstrapServers, "guimanager-criterionfieldavailablevaluesservice-"+apiProcessKey, criterionFieldAvailableValuesTopic, true);
    elasticsearchManager = new ElasticsearchManager(elasticsearch, voucherService, journeyService);
    
    DeliveryManagerDeclaration dmd = Deployment.getDeliveryManagers().get(ThirdPartyManager.PURCHASE_FULFILLMENT_MANAGER_TYPE);
    purchaseResponseListenerService = new KafkaResponseListenerService<>(Deployment.getBrokerServers(),dmd.getResponseTopic(DELIVERY_REQUEST_PRIORITY),StringKey.serde(),PurchaseFulfillmentRequest.serde());
    purchaseResponseListenerService.start();
    voucherChangeResponseListenerService = new KafkaResponseListenerService<>(Deployment.getBrokerServers(),Deployment.getVoucherChangeResponseTopic(),StringKey.serde(),VoucherChange.serde());
    voucherChangeResponseListenerService.start();

    guiManagerBaseManagement = new GUIManagerBaseManagement(journeyService, segmentationDimensionService, pointService, complexObjectTypeService, offerService, reportService, paymentMeanService, scoringStrategyService, presentationStrategyService, callingChannelService, salesChannelService, sourceAddressService, supplierService, productService, catalogCharacteristicService, contactPolicyService, journeyObjectiveService, offerObjectiveService, productTypeService, ucgRuleService, deliverableService, tokenTypeService, voucherTypeService, voucherService, subscriberMessageTemplateService, subscriberProfileService, subscriberIDService, uploadedFileService, targetService, communicationChannelBlackoutService, loyaltyProgramService, resellerService, exclusionInclusionTargetService, segmentContactPolicyService, criterionFieldAvailableValuesService, dnboMatrixService, dynamicCriterionFieldService, dynamicEventDeclarationsService, journeyTemplateService, purchaseResponseListenerService, subscriberGroupSharedIDService, zuks, httpTimeout, kafkaProducer, elasticsearch, subscriberMessageTemplateService, getCustomerAlternateID, guiManagerContext, subscriberGroupEpochReader, renamedProfileCriterionFieldReader);
    guiManagerLoyaltyReporting = new GUIManagerLoyaltyReporting(journeyService, segmentationDimensionService, pointService, complexObjectTypeService, offerService, reportService, paymentMeanService, scoringStrategyService, presentationStrategyService, callingChannelService, salesChannelService, sourceAddressService, supplierService, productService, catalogCharacteristicService, contactPolicyService, journeyObjectiveService, offerObjectiveService, productTypeService, ucgRuleService, deliverableService, tokenTypeService, voucherTypeService, voucherService, subscriberMessageTemplateService, subscriberProfileService, subscriberIDService, uploadedFileService, targetService, communicationChannelBlackoutService, loyaltyProgramService, resellerService, exclusionInclusionTargetService, segmentContactPolicyService, criterionFieldAvailableValuesService, dnboMatrixService, dynamicCriterionFieldService, dynamicEventDeclarationsService, journeyTemplateService, purchaseResponseListenerService, subscriberGroupSharedIDService, zuks, httpTimeout, kafkaProducer, elasticsearch, subscriberMessageTemplateService, getCustomerAlternateID, guiManagerContext, subscriberGroupEpochReader, renamedProfileCriterionFieldReader);
    guiManagerGeneral = new GUIManagerGeneral(journeyService, segmentationDimensionService, pointService, complexObjectTypeService, offerService, reportService, paymentMeanService, scoringStrategyService, presentationStrategyService, callingChannelService, salesChannelService, sourceAddressService, supplierService, productService, catalogCharacteristicService, contactPolicyService, journeyObjectiveService, offerObjectiveService, productTypeService, ucgRuleService, deliverableService, tokenTypeService, voucherTypeService, voucherService, subscriberMessageTemplateService, subscriberProfileService, subscriberIDService, uploadedFileService, targetService, communicationChannelBlackoutService, loyaltyProgramService, resellerService, exclusionInclusionTargetService, segmentContactPolicyService, criterionFieldAvailableValuesService, dnboMatrixService, dynamicCriterionFieldService, dynamicEventDeclarationsService, journeyTemplateService, purchaseResponseListenerService, subscriberGroupSharedIDService, zuks, httpTimeout, kafkaProducer, elasticsearch, subscriberMessageTemplateService, getCustomerAlternateID, guiManagerContext, subscriberGroupEpochReader, renamedProfileCriterionFieldReader);

    /*****************************************
    *
    *  Register Service Listener
    *
    *****************************************/
    GUIManagedObjectListener dynamicEventDeclarationsListener = new GUIManagedObjectListener() {

      @Override
      public void guiManagedObjectActivated(GUIManagedObject guiManagedObject)
      {
        dynamicEventDeclarationsService.refreshSegmentationChangeEvent(segmentationDimensionService, guiManagedObject.getTenantID());         
      }

      @Override
      public void guiManagedObjectDeactivated(String objectID, int tenantID)
      {
        dynamicEventDeclarationsService.refreshSegmentationChangeEvent(segmentationDimensionService, tenantID);         
      }      
    };
    segmentationDimensionService.registerListener(dynamicEventDeclarationsListener);
    
    dynamicEventDeclarationsListener = new GUIManagedObjectListener() {

      @Override
      public void guiManagedObjectActivated(GUIManagedObject guiManagedObject)
      {
        dynamicEventDeclarationsService.refreshLoyaltyProgramChangeEvent(loyaltyProgramService, guiManagedObject.getTenantID());         
      }

      @Override
      public void guiManagedObjectDeactivated(String objectID, int tenantID)
      {
        dynamicEventDeclarationsService.refreshLoyaltyProgramChangeEvent(loyaltyProgramService, tenantID);         
      }      
    };
    loyaltyProgramService.registerListener(dynamicEventDeclarationsListener);

    /*****************************************
    *
    *  clean payment means and deliverables (need to be done before initialProducts, ...)
    *
    *****************************************/

    long providerEpoch = epochServer.getKey();
    for(Tenant tenant : Deployment.getTenants()) {
      int tenantID = tenant.getTenantID();
      for (DeliveryManagerAccount deliveryManagerAccount : Deployment.getDeployment(tenantID).getDeliveryManagerAccounts().values())
        {
          /*****************************************
          *
          *  provider
          *
          *****************************************/
  
          String providerID = deliveryManagerAccount.getProviderID();
          DeliveryManagerDeclaration provider = Deployment.getFulfillmentProviders().get(providerID);
          if (provider == null)
            {
              throw new ServerRuntimeException("Delivery manager accounts : could not retrieve provider with ID " + providerID);
            }
  
          /*****************************************
          *
          *  accounts
          *
          *****************************************/
  
          Set<String> configuredDeliverableIDs = new HashSet<String>();
          Set<String> configuredPaymentMeanIDs = new HashSet<String>();
          for (Account account : deliveryManagerAccount.getAccounts())
            {
              /*****************************************
              *
              *  create/update deliverable 
              *
              *****************************************/
  
              if (account.getCreditable())
                {
                  //
                  //  find existing deliverable (by name) and use/generate deliverableID
                  //
  
                  GUIManagedObject existingDeliverable = deliverableService.getStoredDeliverableByName(account.getName(), tenantID);
                  String deliverableID = (existingDeliverable != null) ? existingDeliverable.getGUIManagedObjectID() : deliverableService.generateDeliverableID();
                  configuredDeliverableIDs.add(deliverableID);
  
                  //
                  //  deliverable
                  //
  
                  Deliverable deliverable = null;
                  try
                    {
                      Map<String, Object> deliverableMap = new HashMap<String, Object>();
                      deliverableMap.put("id", deliverableID);
                      deliverableMap.put("fulfillmentProviderID", providerID);
                      deliverableMap.put("externalAccountID", account.getExternalAccountID());
                      deliverableMap.put("name", account.getName());
                      deliverableMap.put("display", account.getName());
                      deliverableMap.put("active", true);
                      deliverableMap.put("unitaryCost", 0);
                      deliverableMap.put("readOnly", true);
                      deliverableMap.put("generatedFromAccount", true);
                      deliverableMap.put("label", account.getLabel());
                      deliverable = new Deliverable(JSONUtilities.encodeObject(deliverableMap), providerEpoch, null, tenantID);
                    }
                  catch (GUIManagerException e)
                    {
                      throw new ServerRuntimeException("could not add deliverable related to provider "+providerID+" (account "+account.getName()+")", e);
                    }
  
                  //
                  //  create/update deliverable if necessary)
                  //
  
                  if (existingDeliverable == null || ! Objects.equals(existingDeliverable, deliverable))
                    {
                      //
                      //  log
                      //
  
                      log.info("provider deliverable {} {}", deliverableID, (existingDeliverable == null) ? "create" : "update");
  
                      //
                      //  create/update deliverable
                      //
  
                      deliverableService.putDeliverable(deliverable, (existingDeliverable == null), "0");
                    }
                }
  
              /*****************************************
              *
              *  create/update paymentMean
              *
              *****************************************/
  
              if (account.getDebitable())
                {
                  //
                  //  find existing paymentMean (by name) and use/generate paymentMeanID
                  //
  
                  GUIManagedObject existingPaymentMean = paymentMeanService.getStoredPaymentMeanByName(account.getName(), tenantID);
                  String paymentMeanID = (existingPaymentMean != null) ? existingPaymentMean.getGUIManagedObjectID() : paymentMeanService.generatePaymentMeanID();
                  configuredPaymentMeanIDs.add(paymentMeanID);
  
                  //
                  //  paymentMean
                  //
  
                  PaymentMean paymentMean = null;
                  try
                    {
                      Map<String, Object> paymentMeanMap = new HashMap<String, Object>();
                      paymentMeanMap.put("id", paymentMeanID);
                      paymentMeanMap.put("fulfillmentProviderID", providerID);
                      paymentMeanMap.put("externalAccountID", account.getExternalAccountID());
                      paymentMeanMap.put("name", account.getName());
                      paymentMeanMap.put("display", account.getName());
                      paymentMeanMap.put("active", true);
                      paymentMeanMap.put("readOnly", true);
                      paymentMeanMap.put("generatedFromAccount", true);
                      paymentMeanMap.put("label", account.getLabel());
                      paymentMean = new PaymentMean(JSONUtilities.encodeObject(paymentMeanMap), providerEpoch, null, tenantID);
                    }
                  catch (GUIManagerException e)
                    {
                      throw new ServerRuntimeException("could not add paymentMean related to provider "+providerID+" (account "+account.getName()+")", e);
                    }
  
                  // 
                  //  create/update paymentMean (if ncessary)
                  //
  
                  if (existingPaymentMean == null || ! Objects.equals(existingPaymentMean, paymentMean))
                    {
                      //
                      //  log
                      //
  
                      log.info("provider paymentMean {} {}", paymentMeanID, (existingPaymentMean == null) ? "create" : "update");
  
                      //
                      //  create/update paymentMean
                      //
  
                      paymentMeanService.putPaymentMean(paymentMean, (existingPaymentMean == null), "0");
                    }
                }
            }
  
          if (tenantID != 0) {
            /*****************************************
             *
             *  remove unused deliverables
             *
             *****************************************/
          
            for (Deliverable deliverable : deliverableService.getActiveDeliverables(SystemTime.getCurrentTime(), tenantID))
              {
                if (Objects.equals(providerID, deliverable.getFulfillmentProviderID()) && deliverable.getGeneratedFromAccount() && ! configuredDeliverableIDs.contains(deliverable.getDeliverableID()))
                  {
                    deliverableService.removeDeliverable(deliverable.getDeliverableID(), "0", tenantID);
                    log.info("provider deliverable {} {}", deliverable.getDeliverableID(), "remove");
                  }
              }
          
            /*****************************************
             *
             *  remove unused paymentMeans
             *
             *****************************************/
  
            for (PaymentMean paymentMean : paymentMeanService.getActivePaymentMeans(SystemTime.getCurrentTime(), tenantID))
              {
                if (Objects.equals(providerID, paymentMean.getFulfillmentProviderID()) && paymentMean.getGeneratedFromAccount() && ! configuredPaymentMeanIDs.contains(paymentMean.getPaymentMeanID()))
                  {
                    paymentMeanService.removePaymentMean(paymentMean.getPaymentMeanID(), "0", tenantID);
                    log.info("provider paymentMean {} {}", paymentMean.getPaymentMeanID(), "remove");
                  }
              }
          }
        }
      }

    /*****************************************
    *
    *  services - initialize
    *
    *****************************************/

    //
    //  catalogCharacteristics
    //

    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (catalogCharacteristicService.getStoredCatalogCharacteristics(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialCatalogCharacteristicsJSONArray = Deployment.getDeployment(tenantID).getInitialCatalogCharacteristicsJSONArray();
                for (int i=0; i<initialCatalogCharacteristicsJSONArray.size(); i++)
                  {
                    JSONObject catalogCharacteristicJSON = (JSONObject) initialCatalogCharacteristicsJSONArray.get(i);
                    guiManagerGeneral.processPutCatalogCharacteristic("0", catalogCharacteristicJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    //
    //  tokenTypes
    //
    
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (tokenTypeService.getStoredTokenTypes(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialTokenTypesJSONArray = Deployment.getDeployment(tenantID).getInitialTokenTypesJSONArray();
                for (int i=0; i<initialTokenTypesJSONArray.size(); i++)
                  {
                    JSONObject tokenTypeJSON = (JSONObject) initialTokenTypesJSONArray.get(i);
                    guiManagerGeneral.processPutTokenType("0", tokenTypeJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    //
    //  productTypes
    //
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (productTypeService.getStoredProductTypes(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialProductTypesJSONArray = Deployment.getDeployment(tenantID).getInitialProductTypesJSONArray();
                for (int i=0; i<initialProductTypesJSONArray.size(); i++)
                  {
                    JSONObject productTypeJSON = (JSONObject) initialProductTypesJSONArray.get(i);
                    processPutProductType("0", productTypeJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    //
    //  reports
    //

    // Always update reports with initialReports. When we upgrade, new effectiveScheduling is merged with existing one (EVPRO-244)
    for(Tenant tenant : Deployment.getTenants())
      { 
        int tenantID = tenant.getTenantID();
        try
        {
          Date now = SystemTime.getCurrentTime();
          Collection<Report> existingReports = reportService.getActiveReports(now, tenantID);
          JSONArray initialReportsJSONArray = Deployment.getDeployment(tenantID).getInitialReportsJSONArray();
          for (int i=0; i<initialReportsJSONArray.size(); i++)
            {
              JSONObject reportJSON = (JSONObject) initialReportsJSONArray.get(i);
              String name = JSONUtilities.decodeString(reportJSON, "display", false);
              boolean create = true;
              if (name != null)
                {
                  for (Report report : existingReports)
                    {
                      if (name.equals(report.getGUIManagedObjectDisplay()))
                        {
                          // this report already exists (same name), do not create it
                          create = false;
                          log.info("Report " + name + " (id " + report.getReportID() + " ) already exists, do not create");
                          break;
                        }
                    }
                }
              if (create)
              {
                guiManagerLoyaltyReporting.processPutReport("0", reportJSON, tenantID); // TODO-EVPRO-99 check this related to tenancy...
              }
            }
        }
        catch (JSONUtilitiesException e)
        {
          throw new ServerRuntimeException("deployment", e);
        }
      }


    //
    //  calling channels
    //
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (callingChannelService.getStoredCallingChannels(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialCallingChannelsJSONArray = Deployment.getDeployment(tenantID).getInitialCallingChannelsJSONArray();
                for (int i=0; i<initialCallingChannelsJSONArray.size(); i++)
                  {
                    JSONObject  callingChannelJSON = (JSONObject) initialCallingChannelsJSONArray.get(i);
                    processPutCallingChannel("0", callingChannelJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    //
    //  sales channels
    //

    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (salesChannelService.getStoredSalesChannels(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialSalesChannelsJSONArray = Deployment.getDeployment(tenantID).getInitialSalesChannelsJSONArray();
                for (int i=0; i<initialSalesChannelsJSONArray.size(); i++)
                  {
                    JSONObject  salesChannelJSON = (JSONObject) initialSalesChannelsJSONArray.get(i);
                    processPutSalesChannel("0", salesChannelJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }
    
    //
    //  suppliers
    //
    
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (supplierService.getStoredSuppliers(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialSuppliersJSONArray = Deployment.getDeployment(tenantID).getInitialSuppliersJSONArray();
                for (int i=0; i<initialSuppliersJSONArray.size(); i++)
                  {
                    JSONObject supplierJSON = (JSONObject) initialSuppliersJSONArray.get(i);
                    processPutSupplier("0", supplierJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    //
    //  products
    //
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (productService.getStoredProducts(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialProductsJSONArray = Deployment.getDeployment(tenantID).getInitialProductsJSONArray();
                for (int i=0; i<initialProductsJSONArray.size(); i++)
                  {
                    JSONObject productJSON = (JSONObject) initialProductsJSONArray.get(i);
                    processPutProduct("0", productJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    //
    //  Source Addresses not before communicationChannels
    //
    
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (sourceAddressService.getStoredSourceAddresss(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialSourceAddressesJSONArray = Deployment.getDeployment(tenantID).getInitialSourceAddressesJSONArray();
                for (int i=0; i<initialSourceAddressesJSONArray.size(); i++)
                  {
                    JSONObject  sourceAddresslJSON = (JSONObject) initialSourceAddressesJSONArray.get(i);
                    processPutSourceAddress("0", sourceAddresslJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    //
    //  contactPolicies
    //
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (contactPolicyService.getStoredContactPolicies(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialContactPoliciesJSONArray = Deployment.getDeployment(tenantID).getInitialContactPoliciesJSONArray();
                for (int i=0; i<initialContactPoliciesJSONArray.size(); i++)
                  {
                    JSONObject contactPolicyJSON = (JSONObject) initialContactPoliciesJSONArray.get(i);
                    processPutContactPolicy("0", contactPolicyJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }
        
    //
    //  journeyTemplates
    //
    
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (journeyTemplateService.getStoredJourneyTemplates(tenantID).size() == 0)
          {
            try
            {
              JSONArray initialJourneyTemplatesJSONArray = Deployment.getDeployment(tenantID).getInitialJourneyTemplatesJSONArray();
              for (int i=0; i<initialJourneyTemplatesJSONArray.size(); i++)
                {
                  JSONObject journeyTemplateJSON = (JSONObject) initialJourneyTemplatesJSONArray.get(i);
                  processPutJourneyTemplate("0", journeyTemplateJSON, tenantID);
                }
            }
          catch (JSONUtilitiesException e)
            {
              throw new ServerRuntimeException("deployment", e);
            }
          }
      }
    
    
    //
    //  journeyObjectives
    //

    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (journeyObjectiveService.getStoredJourneyObjectives(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialJourneyObjectivesJSONArray = Deployment.getDeployment(tenantID).getInitialJourneyObjectivesJSONArray();
                for (int i=0; i<initialJourneyObjectivesJSONArray.size(); i++)
                  {
                    JSONObject journeyObjectiveJSON = (JSONObject) initialJourneyObjectivesJSONArray.get(i);
                    processPutJourneyObjective("0", journeyObjectiveJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    //
    //  offerObjectives
    //

    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (offerObjectiveService.getStoredOfferObjectives(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialOfferObjectivesJSONArray = Deployment.getDeployment(tenantID).getInitialOfferObjectivesJSONArray();
                for (int i=0; i<initialOfferObjectivesJSONArray.size(); i++)
                  {
                    JSONObject offerObjectiveJSON = (JSONObject) initialOfferObjectivesJSONArray.get(i);
                    processPutOfferObjective("0", offerObjectiveJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }
    

    //
    //  segmentationDimensions
    //
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (segmentationDimensionService.getStoredSegmentationDimensions(tenantID).size() == 0)
          {
            try
              {
                JSONArray initialSegmentationDimensionsJSONArray = Deployment.getDeployment(tenantID).getInitialSegmentationDimensionsJSONArray();
                for (int i=0; i<initialSegmentationDimensionsJSONArray.size(); i++)
                  {
                    JSONObject segmentationDimensionJSON = (JSONObject) initialSegmentationDimensionsJSONArray.get(i);
                    guiManagerBaseManagement.processPutSegmentationDimension("0", segmentationDimensionJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    //
    //  complexObject
    //
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        if (complexObjectTypeService.getActiveComplexObjectTypes(SystemTime.getCurrentTime(), tenantID).size() == 0)
          {
            try
              {
                JSONArray initialComplexObjectJSONArray = Deployment.getInitialComplexObjectJSONArray();
                for (int i=0; i<initialComplexObjectJSONArray.size(); i++)
                  {
                    JSONObject initialComplexObjectJSON = (JSONObject) initialComplexObjectJSONArray.get(i);
                    guiManagerGeneral.processPutComplexObjectType("0", initialComplexObjectJSON, tenantID);
                  }
              }
            catch (JSONUtilitiesException e)
              {
                throw new ServerRuntimeException("deployment", e);
              }
          }
      }

    /*****************************************
    *
    *  simple profile dimensions
    *
    *****************************************/

    //
    // remove all existing simple profile dimensions
    //
    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        for (GUIManagedObject dimensionObject : segmentationDimensionService.getStoredSegmentationDimensions(tenantID))
          {
            if (dimensionObject instanceof SegmentationDimension)
              {
                SegmentationDimension dimension = (SegmentationDimension)dimensionObject;
                if (dimension.getIsSimpleProfileDimension())
                  {
                    segmentationDimensionService.removeSegmentationDimension(dimension.getSegmentationDimensionID(), "0", tenantID);
                  }
              }
          }
      }

    //
    // re-create simple profile dimensions (=> so we are sure that dimensions are in line with profile fields)
    //

    Date now = SystemTime.getCurrentTime();

    for(Tenant tenant : Deployment.getTenants())
      {
        int tenantID = tenant.getTenantID();
        Map<String,CriterionField> profileCriterionFields = CriterionContext.FullProfile(tenantID).getCriterionFields(tenantID);
        for (CriterionField criterion : profileCriterionFields.values())
          {
            if (Deployment.getDeployment(tenantID).getGenerateSimpleProfileDimensions() || criterion.getGenerateDimension())
              {
                List<JSONObject> availableValues = evaluateAvailableValues(criterion, now, false, tenantID);
                if (availableValues != null && availableValues.size() > 0)
                  {
                    //
                    // create dimension
                    //
    
                    String dimensionID = "simple.subscriber." + criterion.getID();
                    HashMap<String,Object> newSimpleProfileDimensionJSON = new HashMap<String,Object>();
                    newSimpleProfileDimensionJSON.put("isSimpleProfileDimension", true);
                    newSimpleProfileDimensionJSON.put("id", dimensionID);
                    newSimpleProfileDimensionJSON.put("name", normalizeSegmentName(criterion.getName()));
                    newSimpleProfileDimensionJSON.put("display", criterion.getDisplay());
                    newSimpleProfileDimensionJSON.put("description", "Simple profile criteria (from "+criterion.getName()+")");
                    newSimpleProfileDimensionJSON.put("targetingType", SegmentationDimensionTargetingType.ELIGIBILITY.getExternalRepresentation());
                    newSimpleProfileDimensionJSON.put("active", Boolean.TRUE);
                    newSimpleProfileDimensionJSON.put("readOnly", Boolean.TRUE);
    
                    //
                    // create all segments of this dimension
                    //
    
                    ArrayList<Object> newSimpleProfileDimensionSegments = new ArrayList<Object>();
                    for (JSONObject availableValue : availableValues)
                      {
                        HashMap<String,Object> segmentJSON = new HashMap<String,Object>();
                        ArrayList<Object> segmentProfileCriteriaList = new ArrayList<Object>();
                        switch (criterion.getFieldDataType())
                          {
                            case StringCriterion:
    
                              //
                              // create a segment
                              //
    
                              String stringValueID = JSONUtilities.decodeString(availableValue, "id", true);
                              String stringValueDisplay = JSONUtilities.decodeString(availableValue, "display", true);
                              segmentJSON.put("id", dimensionID + "." + stringValueID);
                              segmentJSON.put("name", normalizeSegmentName(stringValueDisplay));
                              if (!newSimpleProfileDimensionSegments.isEmpty())
                                {
                                  // first element is the default value => fill criteria for all values except the first
                                  HashMap<String,Object> segmentProfileCriteria = new HashMap<String,Object> ();
                                  segmentProfileCriteria.put("criterionField", criterion.getName());
                                  segmentProfileCriteria.put("criterionOperator", CriterionOperator.EqualOperator.getExternalRepresentation());
                                  HashMap<String,Object> argument = new HashMap<String,Object> ();
                                  argument.put("expression", "'"+stringValueID+"'");
                                  segmentProfileCriteria.put("argument", JSONUtilities.encodeObject(argument));
                                  segmentProfileCriteriaList.add(JSONUtilities.encodeObject(segmentProfileCriteria));
                                }
                              segmentJSON.put("profileCriteria", JSONUtilities.encodeArray(segmentProfileCriteriaList));
                              newSimpleProfileDimensionSegments.add((newSimpleProfileDimensionSegments.isEmpty() ? 0 : newSimpleProfileDimensionSegments.size() - 1), JSONUtilities.encodeObject(segmentJSON)); // first element is the default value => need to be the last element of segments list
                              break;
    
                            case BooleanCriterion:
    
                              //
                              // create a segment
                              //
    
                              boolean booleanValueID = JSONUtilities.decodeBoolean(availableValue, "id", true);
                              String booleanValueDisplay = JSONUtilities.decodeString(availableValue, "display", true);
                              segmentJSON.put("id", dimensionID + "." + booleanValueID);
                              segmentJSON.put("name", normalizeSegmentName(booleanValueDisplay));
                              if (!newSimpleProfileDimensionSegments.isEmpty())
                                {
                                  // first element is the default value => fill criteria for all values except the first
                                  HashMap<String,Object> segmentProfileCriteria = new HashMap<String,Object> ();
                                  segmentProfileCriteria.put("criterionField", criterion.getName());
                                  segmentProfileCriteria.put("criterionOperator", CriterionOperator.EqualOperator.getExternalRepresentation());
                                  HashMap<String,Object> argument = new HashMap<String,Object> ();
                                  argument.put("expression", Boolean.toString(booleanValueID));
                                  segmentProfileCriteria.put("argument", JSONUtilities.encodeObject(argument));
                                  segmentProfileCriteriaList.add(JSONUtilities.encodeObject(segmentProfileCriteria));
                                }
                              segmentJSON.put("profileCriteria", JSONUtilities.encodeArray(segmentProfileCriteriaList));
                              newSimpleProfileDimensionSegments.add((newSimpleProfileDimensionSegments.isEmpty() ? 0 : newSimpleProfileDimensionSegments.size() - 1), JSONUtilities.encodeObject(segmentJSON)); // first element is the default value => need to be the last element of segments list
                              break;
    
                            case IntegerCriterion:
    
                              //
                              // create a segment
                              //
    
                              int intValueID = JSONUtilities.decodeInteger(availableValue, "id", true);
                              String intValueDisplay = JSONUtilities.decodeString(availableValue, "display", true);
                              segmentJSON.put("id", dimensionID + "." + intValueID);
                              segmentJSON.put("name", normalizeSegmentName(intValueDisplay));
                              if (!newSimpleProfileDimensionSegments.isEmpty())
                                {
                                  // first element is the default value => fill criteria for all values except the first
                                  HashMap<String,Object> segmentProfileCriteria = new HashMap<String,Object> ();
                                  segmentProfileCriteria.put("criterionField", criterion.getName());
                                  segmentProfileCriteria.put("criterionOperator", CriterionOperator.EqualOperator.getExternalRepresentation());
                                  HashMap<String,Object> argument = new HashMap<String,Object> ();
                                  argument.put("expression", ""+intValueID);
                                  segmentProfileCriteria.put("argument", JSONUtilities.encodeObject(argument));
                                  segmentProfileCriteriaList.add(JSONUtilities.encodeObject(segmentProfileCriteria));
                                }
                              segmentJSON.put("profileCriteria", JSONUtilities.encodeArray(segmentProfileCriteriaList));
                              newSimpleProfileDimensionSegments.add((newSimpleProfileDimensionSegments.isEmpty() ? 0 : newSimpleProfileDimensionSegments.size() - 1), JSONUtilities.encodeObject(segmentJSON)); // first element is the default value => need to be the last element of segments list
                              break;
    
                            default:
                              //DoubleCriterion
                              //DateCriterion
                              break;
                          }
                      }
    
                    newSimpleProfileDimensionJSON.put("segments", JSONUtilities.encodeArray(newSimpleProfileDimensionSegments));
                    newSimpleProfileDimensionJSON.put("tenantID", tenantID);
                    JSONObject newSimpleProfileDimension = JSONUtilities.encodeObject(newSimpleProfileDimensionJSON);
                    guiManagerBaseManagement.processPutSegmentationDimension("0", newSimpleProfileDimension, JSONUtilities.decodeInteger(newSimpleProfileDimension, "tenantID", true));
                  }
              }
          }
      }

    /*****************************************
    *
    *  services - start
    *
    *****************************************/

    journeyObjectiveService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    targetService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    contactPolicyService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    journeyService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    dynamicCriterionFieldService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);    
    segmentationDimensionService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    pointService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    complexObjectTypeService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    offerService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    reportService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    paymentMeanService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    scoringStrategyService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    presentationStrategyService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    dnboMatrixService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    callingChannelService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    salesChannelService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    sourceAddressService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    supplierService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    productService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    catalogCharacteristicService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);    
    offerObjectiveService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    productTypeService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    ucgRuleService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    deliverableService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    tokenTypeService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    voucherTypeService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    subscriberMessageTemplateService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    subscriberProfileService.start();
    uploadedFileService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);    
    voucherService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    communicationChannelBlackoutService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    loyaltyProgramService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    exclusionInclusionTargetService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    resellerService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    segmentContactPolicyService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    dynamicEventDeclarationsService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    for(Tenant tenant : Deployment.getTenants())
      {
        dynamicEventDeclarationsService.refreshSegmentationChangeEvent(segmentationDimensionService, tenant.getTenantID());
        dynamicEventDeclarationsService.refreshLoyaltyProgramChangeEvent(loyaltyProgramService, tenant.getTenantID());
      }

    criterionFieldAvailableValuesService.start(elasticsearch, journeyService, journeyObjectiveService, targetService, contactPolicyService);
    elasticsearchManager.start();

    /*****************************************
    *
    *  REST interface -- server and handlers
    *
    *****************************************/

    try
      {
        InetSocketAddress addr = new InetSocketAddress(apiRestPort);
        restServer = HttpServer.create(addr, 0);
        restServer.createContext("/nglm-guimanager/getStaticConfiguration", new APISimpleHandler(API.getStaticConfiguration));
        restServer.createContext("/nglm-guimanager/getSupportedLanguages", new APISimpleHandler(API.getSupportedLanguages));
        restServer.createContext("/nglm-guimanager/getSupportedCurrencies", new APISimpleHandler(API.getSupportedCurrencies));
        restServer.createContext("/nglm-guimanager/getSupportedTimeUnits", new APISimpleHandler(API.getSupportedTimeUnits));
        restServer.createContext("/nglm-guimanager/getSupportedRelationships", new APISimpleHandler(API.getSupportedRelationships));
        restServer.createContext("/nglm-guimanager/getCallingChannelProperties", new APISimpleHandler(API.getCallingChannelProperties));
        restServer.createContext("/nglm-guimanager/getCatalogCharacteristicUnits", new APISimpleHandler(API.getCatalogCharacteristicUnits));
        restServer.createContext("/nglm-guimanager/getSupportedDataTypes", new APISimpleHandler(API.getSupportedDataTypes));
        restServer.createContext("/nglm-guimanager/getSupportedEvents", new APISimpleHandler(API.getSupportedEvents));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramPointsEvents", new APISimpleHandler(API.getLoyaltyProgramPointsEvents));
        restServer.createContext("/nglm-guimanager/getSupportedTargetingTypes", new APISimpleHandler(API.getSupportedTargetingTypes));
        restServer.createContext("/nglm-guimanager/getProfileCriterionFields", new APISimpleHandler(API.getProfileCriterionFields));
        restServer.createContext("/nglm-guimanager/getProfileCriterionFieldIDs", new APISimpleHandler(API.getProfileCriterionFieldIDs));
        restServer.createContext("/nglm-guimanager/getProfileCriterionField", new APISimpleHandler(API.getProfileCriterionField));
        restServer.createContext("/nglm-guimanager/getFullProfileCriterionFields", new APISimpleHandler(API.getFullProfileCriterionFields));
        restServer.createContext("/nglm-guimanager/getFullProfileCriterionFieldIDs", new APISimpleHandler(API.getFullProfileCriterionFieldIDs));
        restServer.createContext("/nglm-guimanager/getFullProfileCriterionField", new APISimpleHandler(API.getFullProfileCriterionField));
        restServer.createContext("/nglm-guimanager/getPresentationCriterionFields", new APISimpleHandler(API.getPresentationCriterionFields));
        restServer.createContext("/nglm-guimanager/getPresentationCriterionFieldIDs", new APISimpleHandler(API.getPresentationCriterionFieldIDs));
        restServer.createContext("/nglm-guimanager/getPresentationCriterionField", new APISimpleHandler(API.getPresentationCriterionField));
        restServer.createContext("/nglm-guimanager/getJourneyCriterionFields", new APISimpleHandler(API.getJourneyCriterionFields));
        restServer.createContext("/nglm-guimanager/getJourneyCriterionFieldIDs", new APISimpleHandler(API.getJourneyCriterionFieldIDs));
        restServer.createContext("/nglm-guimanager/getJourneyCriterionField", new APISimpleHandler(API.getJourneyCriterionField));
        restServer.createContext("/nglm-guimanager/getJourneyTriggerTargetingCriterionFields", new APISimpleHandler(API.getJourneyTriggerTargetingCriterionFields));
        restServer.createContext("/nglm-guimanager/getOfferProperties", new APISimpleHandler(API.getOfferProperties));
        restServer.createContext("/nglm-guimanager/getScoringEngines", new APISimpleHandler(API.getScoringEngines));
        restServer.createContext("/nglm-guimanager/getOfferOptimizationAlgorithms", new APISimpleHandler(API.getOfferOptimizationAlgorithms));
        restServer.createContext("/nglm-guimanager/getNodeTypes", new APISimpleHandler(API.getNodeTypes));
        restServer.createContext("/nglm-guimanager/getJourneyToolbox", new APISimpleHandler(API.getJourneyToolbox));
        restServer.createContext("/nglm-guimanager/getJourneyList", new APISimpleHandler(API.getJourneyList));
        restServer.createContext("/nglm-guimanager/getJourneySummaryList", new APISimpleHandler(API.getJourneySummaryList));
        restServer.createContext("/nglm-guimanager/getJourney", new APISimpleHandler(API.getJourney));
        restServer.createContext("/nglm-guimanager/putJourney", new APISimpleHandler(API.putJourney));
        restServer.createContext("/nglm-guimanager/removeJourney", new APISimpleHandler(API.removeJourney));
        restServer.createContext("/nglm-guimanager/updateJourney", new APISimpleHandler(API.updateJourney));
        restServer.createContext("/nglm-guimanager/setStatusJourney", new APISimpleHandler(API.setStatusJourney));
        restServer.createContext("/nglm-guimanager/startJourney", new APISimpleHandler(API.startJourney));
        restServer.createContext("/nglm-guimanager/stopJourney", new APISimpleHandler(API.stopJourney));
        restServer.createContext("/nglm-guimanager/getCampaignToolbox", new APISimpleHandler(API.getCampaignToolbox));
        restServer.createContext("/nglm-guimanager/getCampaignList", new APISimpleHandler(API.getCampaignList));
        restServer.createContext("/nglm-guimanager/getCampaignSummaryList", new APISimpleHandler(API.getCampaignSummaryList));
        restServer.createContext("/nglm-guimanager/getCampaign", new APISimpleHandler(API.getCampaign));
        restServer.createContext("/nglm-guimanager/putCampaign", new APISimpleHandler(API.putCampaign));
        restServer.createContext("/nglm-guimanager/removeCampaign", new APISimpleHandler(API.removeCampaign));
        restServer.createContext("/nglm-guimanager/updateCampaign", new APISimpleHandler(API.updateCampaign));
        restServer.createContext("/nglm-guimanager/setStatusCampaign", new APISimpleHandler(API.setStatusCampaign));
        restServer.createContext("/nglm-guimanager/startCampaign", new APISimpleHandler(API.startCampaign));
        restServer.createContext("/nglm-guimanager/stopCampaign", new APISimpleHandler(API.stopCampaign));
        restServer.createContext("/nglm-guimanager/getWorkflowToolbox", new APISimpleHandler(API.getWorkflowToolbox));
        restServer.createContext("/nglm-guimanager/getWorkflowList", new APISimpleHandler(API.getWorkflowList));
        restServer.createContext("/nglm-guimanager/getFullWorkflowList", new APISimpleHandler(API.getFullWorkflowList));
        restServer.createContext("/nglm-guimanager/getWorkflowSummaryList", new APISimpleHandler(API.getWorkflowSummaryList));
        restServer.createContext("/nglm-guimanager/getWorkflow", new APISimpleHandler(API.getWorkflow));
        restServer.createContext("/nglm-guimanager/putWorkflow", new APISimpleHandler(API.putWorkflow));
        restServer.createContext("/nglm-guimanager/removeWorkflow", new APISimpleHandler(API.removeWorkflow));
        restServer.createContext("/nglm-guimanager/updateWorkflow", new APISimpleHandler(API.updateWorkflow));
        restServer.createContext("/nglm-guimanager/setStatusWorkflow", new APISimpleHandler(API.setStatusWorkflow));        
       
        restServer.createContext("/nglm-guimanager/getLoyaltyWorkflowToolbox", new APISimpleHandler(API.getLoyaltyWorkflowToolbox));
        
        restServer.createContext("/nglm-guimanager/getBulkCampaignList", new APISimpleHandler(API.getBulkCampaignList));
        restServer.createContext("/nglm-guimanager/getBulkCampaignSummaryList", new APISimpleHandler(API.getBulkCampaignSummaryList));
        restServer.createContext("/nglm-guimanager/getBulkCampaign", new APISimpleHandler(API.getBulkCampaign));
        restServer.createContext("/nglm-guimanager/getBulkCampaignCapacity", new APISimpleHandler(API.getBulkCampaignCapacity));
        restServer.createContext("/nglm-guimanager/putBulkCampaign", new APISimpleHandler(API.putBulkCampaign));
        restServer.createContext("/nglm-guimanager/removeBulkCampaign", new APISimpleHandler(API.removeBulkCampaign));
        restServer.createContext("/nglm-guimanager/updateBulkCampaign", new APISimpleHandler(API.updateBulkCampaign));
        restServer.createContext("/nglm-guimanager/setStatusBulkCampaign", new APISimpleHandler(API.setStatusBulkCampaign));
        restServer.createContext("/nglm-guimanager/startBulkCampaign", new APISimpleHandler(API.startBulkCampaign));
        restServer.createContext("/nglm-guimanager/stopBulkCampaign", new APISimpleHandler(API.stopBulkCampaign));
        restServer.createContext("/nglm-guimanager/getJourneyTemplateList", new APISimpleHandler(API.getJourneyTemplateList));
        restServer.createContext("/nglm-guimanager/getJourneyTemplateSummaryList", new APISimpleHandler(API.getJourneyTemplateSummaryList));
        restServer.createContext("/nglm-guimanager/getJourneyTemplate", new APISimpleHandler(API.getJourneyTemplate));
        restServer.createContext("/nglm-guimanager/putJourneyTemplate", new APISimpleHandler(API.putJourneyTemplate));
        restServer.createContext("/nglm-guimanager/removeJourneyTemplate", new APISimpleHandler(API.removeJourneyTemplate));
        restServer.createContext("/nglm-guimanager/setStatusJourneyTemplate", new APISimpleHandler(API.setStatusJourneyTemplate));
        restServer.createContext("/nglm-guimanager/getJourneyNodeCount", new APISimpleHandler(API.getJourneyNodeCount));
        restServer.createContext("/nglm-guimanager/getSegmentationDimensionList", new APISimpleHandler(API.getSegmentationDimensionList));
        restServer.createContext("/nglm-guimanager/getSegmentationDimensionSummaryList", new APISimpleHandler(API.getSegmentationDimensionSummaryList));
        restServer.createContext("/nglm-guimanager/getSegmentationDimension", new APISimpleHandler(API.getSegmentationDimension));
        restServer.createContext("/nglm-guimanager/putSegmentationDimension", new APISimpleHandler(API.putSegmentationDimension));
        restServer.createContext("/nglm-guimanager/removeSegmentationDimension", new APISimpleHandler(API.removeSegmentationDimension));
        restServer.createContext("/nglm-guimanager/setStatusSegmentationDimension", new APISimpleHandler(API.setStatusSegmentationDimension));
        restServer.createContext("/nglm-guimanager/getCountBySegmentationRanges", new APISimpleHandler(API.getCountBySegmentationRanges));
        restServer.createContext("/nglm-guimanager/getCountBySegmentationRangesBySegmentID", new APISimpleHandler(API.getCountBySegmentationRangesBySegmentID));
        restServer.createContext("/nglm-guimanager/getCountBySegmentationEligibility", new APISimpleHandler(API.getCountBySegmentationEligibility));
        restServer.createContext("/nglm-guimanager/evaluateProfileCriteria", new APISimpleHandler(API.evaluateProfileCriteria));
        restServer.createContext("/nglm-guimanager/getUCGDimensionSummaryList", new APISimpleHandler(API.getUCGDimensionSummaryList));
        restServer.createContext("/nglm-guimanager/getPointList", new APISimpleHandler(API.getPointList));
        restServer.createContext("/nglm-guimanager/getPointSummaryList", new APISimpleHandler(API.getPointSummaryList));
        restServer.createContext("/nglm-guimanager/getPoint", new APISimpleHandler(API.getPoint));
        restServer.createContext("/nglm-guimanager/putPoint", new APISimpleHandler(API.putPoint));
        restServer.createContext("/nglm-guimanager/removePoint", new APISimpleHandler(API.removePoint));
        restServer.createContext("/nglm-guimanager/setStatusPoint", new APISimpleHandler(API.setStatusPoint));
        restServer.createContext("/nglm-guimanager/getComplexObjectTypeList", new APISimpleHandler(API.getComplexObjectTypeList));
        restServer.createContext("/nglm-guimanager/getComplexObjectTypeSummaryList", new APISimpleHandler(API.getComplexObjectTypeSummaryList));
        restServer.createContext("/nglm-guimanager/getComplexObjectType", new APISimpleHandler(API.getComplexObjectType));
        restServer.createContext("/nglm-guimanager/putComplexObjectType", new APISimpleHandler(API.putComplexObjectType));
        restServer.createContext("/nglm-guimanager/removeComplexObjectType", new APISimpleHandler(API.removeComplexObjectType));
        restServer.createContext("/nglm-guimanager/getOfferList", new APISimpleHandler(API.getOfferList));
        restServer.createContext("/nglm-guimanager/getOfferSummaryList", new APISimpleHandler(API.getOfferSummaryList));
        restServer.createContext("/nglm-guimanager/getOffer", new APISimpleHandler(API.getOffer));
        restServer.createContext("/nglm-guimanager/putOffer", new APISimpleHandler(API.putOffer));
        restServer.createContext("/nglm-guimanager/removeOffer", new APISimpleHandler(API.removeOffer));
        restServer.createContext("/nglm-guimanager/updateOffer", new APISimpleHandler(API.updateOffer));
        restServer.createContext("/nglm-guimanager/setStatusOffer", new APISimpleHandler(API.setStatusOffer));
        restServer.createContext("/nglm-guimanager/getPresentationStrategyList", new APISimpleHandler(API.getPresentationStrategyList));
        restServer.createContext("/nglm-guimanager/getReportGlobalConfiguration", new APISimpleHandler(API.getReportGlobalConfiguration));
        restServer.createContext("/nglm-guimanager/getReportList", new APISimpleHandler(API.getReportList));
        restServer.createContext("/nglm-guimanager/putReport", new APISimpleHandler(API.putReport));
        restServer.createContext("/nglm-guimanager/launchReport", new APISimpleHandler(API.launchReport));
        restServer.createContext("/nglm-guimanager/downloadReport", new APIComplexHandler(API.downloadReport));
        restServer.createContext("/nglm-guimanager/getPresentationStrategySummaryList", new APISimpleHandler(API.getPresentationStrategySummaryList));
        restServer.createContext("/nglm-guimanager/getPresentationStrategy", new APISimpleHandler(API.getPresentationStrategy));
        restServer.createContext("/nglm-guimanager/putPresentationStrategy", new APISimpleHandler(API.putPresentationStrategy));
        restServer.createContext("/nglm-guimanager/removePresentationStrategy", new APISimpleHandler(API.removePresentationStrategy));
        restServer.createContext("/nglm-guimanager/setStatusPresentationStrategy", new APISimpleHandler(API.setStatusPresentationStrategy));
        restServer.createContext("/nglm-guimanager/getDNBOMatrixList", new APISimpleHandler(API.getDNBOMatrixList));
        restServer.createContext("/nglm-guimanager/getDNBOMatrixSummaryList", new APISimpleHandler(API.getDNBOMatrixSummaryList));
        restServer.createContext("/nglm-guimanager/getDNBOMatrix", new APISimpleHandler(API.getDNBOMatrix));
        restServer.createContext("/nglm-guimanager/putDNBOMatrix", new APISimpleHandler(API.putDNBOMatrix));
        restServer.createContext("/nglm-guimanager/setStatusDNBOMatrix", new APISimpleHandler(API.setStatusDNBOMatrix));
        restServer.createContext("/nglm-guimanager/removeDNBOMatrix", new APISimpleHandler(API.removeDNBOMatrix));
        restServer.createContext("/nglm-guimanager/getScoringTypesList", new APISimpleHandler(API.getScoringTypesList));
        restServer.createContext("/nglm-guimanager/getDNBOMatrixVariablesList", new APISimpleHandler(API.getDNBOMatrixVariablesList));
        restServer.createContext("/nglm-guimanager/getScoringStrategyList", new APISimpleHandler(API.getScoringStrategyList));
        restServer.createContext("/nglm-guimanager/getScoringStrategySummaryList", new APISimpleHandler(API.getScoringStrategySummaryList));
        restServer.createContext("/nglm-guimanager/getScoringStrategy", new APISimpleHandler(API.getScoringStrategy));
        restServer.createContext("/nglm-guimanager/putScoringStrategy", new APISimpleHandler(API.putScoringStrategy));
        restServer.createContext("/nglm-guimanager/removeScoringStrategy", new APISimpleHandler(API.removeScoringStrategy));
        restServer.createContext("/nglm-guimanager/setStatusScoringStrategy", new APISimpleHandler(API.setStatusScoringStrategy));
        restServer.createContext("/nglm-guimanager/getCallingChannelList", new APISimpleHandler(API.getCallingChannelList));
        restServer.createContext("/nglm-guimanager/getCallingChannelSummaryList", new APISimpleHandler(API.getCallingChannelSummaryList));
        restServer.createContext("/nglm-guimanager/getCallingChannel", new APISimpleHandler(API.getCallingChannel));
        restServer.createContext("/nglm-guimanager/putCallingChannel", new APISimpleHandler(API.putCallingChannel));
        restServer.createContext("/nglm-guimanager/removeCallingChannel", new APISimpleHandler(API.removeCallingChannel));
        restServer.createContext("/nglm-guimanager/setStatusCallingChannel", new APISimpleHandler(API.setStatusCallingChannel));
        restServer.createContext("/nglm-guimanager/getSalesChannelList", new APISimpleHandler(API.getSalesChannelList));
        restServer.createContext("/nglm-guimanager/getSalesChannelSummaryList", new APISimpleHandler(API.getSalesChannelSummaryList));
        restServer.createContext("/nglm-guimanager/getSalesChannel", new APISimpleHandler(API.getSalesChannel));
        restServer.createContext("/nglm-guimanager/putSalesChannel", new APISimpleHandler(API.putSalesChannel));
        restServer.createContext("/nglm-guimanager/removeSalesChannel", new APISimpleHandler(API.removeSalesChannel));
        restServer.createContext("/nglm-guimanager/setStatusSalesChannel", new APISimpleHandler(API.setStatusSalesChannel));
        restServer.createContext("/nglm-guimanager/getSupplierList", new APISimpleHandler(API.getSupplierList));
        restServer.createContext("/nglm-guimanager/getSupplierSummaryList", new APISimpleHandler(API.getSupplierSummaryList));
        restServer.createContext("/nglm-guimanager/getSupplier", new APISimpleHandler(API.getSupplier));
        restServer.createContext("/nglm-guimanager/putSupplier", new APISimpleHandler(API.putSupplier));
        restServer.createContext("/nglm-guimanager/removeSupplier", new APISimpleHandler(API.removeSupplier));
        restServer.createContext("/nglm-guimanager/setStatusSupplier", new APISimpleHandler(API.setStatusSupplier));
        restServer.createContext("/nglm-guimanager/getProductList", new APISimpleHandler(API.getProductList));
        restServer.createContext("/nglm-guimanager/getProductSummaryList", new APISimpleHandler(API.getProductSummaryList));
        restServer.createContext("/nglm-guimanager/getProduct", new APISimpleHandler(API.getProduct));
        restServer.createContext("/nglm-guimanager/putProduct", new APISimpleHandler(API.putProduct));
        restServer.createContext("/nglm-guimanager/updateProduct", new APISimpleHandler(API.updateProduct));
        restServer.createContext("/nglm-guimanager/setStatusProduct", new APISimpleHandler(API.setStatusProduct));
        restServer.createContext("/nglm-guimanager/removeProduct", new APISimpleHandler(API.removeProduct));
        restServer.createContext("/nglm-guimanager/getCatalogCharacteristicList", new APISimpleHandler(API.getCatalogCharacteristicList));
        restServer.createContext("/nglm-guimanager/getCatalogCharacteristicSummaryList", new APISimpleHandler(API.getCatalogCharacteristicSummaryList));
        restServer.createContext("/nglm-guimanager/getCatalogCharacteristic", new APISimpleHandler(API.getCatalogCharacteristic));
        restServer.createContext("/nglm-guimanager/putCatalogCharacteristic", new APISimpleHandler(API.putCatalogCharacteristic));
        restServer.createContext("/nglm-guimanager/removeCatalogCharacteristic", new APISimpleHandler(API.removeCatalogCharacteristic));
        restServer.createContext("/nglm-guimanager/setStatusCatalogCharacteristic", new APISimpleHandler(API.setStatusCatalogCharacteristic));
        restServer.createContext("/nglm-guimanager/getContactPolicyList", new APISimpleHandler(API.getContactPolicyList));
        restServer.createContext("/nglm-guimanager/getContactPolicySummaryList", new APISimpleHandler(API.getContactPolicySummaryList));
        restServer.createContext("/nglm-guimanager/getContactPolicy", new APISimpleHandler(API.getContactPolicy));
        restServer.createContext("/nglm-guimanager/putContactPolicy", new APISimpleHandler(API.putContactPolicy));
        restServer.createContext("/nglm-guimanager/removeContactPolicy", new APISimpleHandler(API.removeContactPolicy));
        restServer.createContext("/nglm-guimanager/setStatusContactPolicy", new APISimpleHandler(API.setStatusContactPolicy));
        restServer.createContext("/nglm-guimanager/getJourneyObjectiveList", new APISimpleHandler(API.getJourneyObjectiveList));
        restServer.createContext("/nglm-guimanager/getJourneyObjectiveSummaryList", new APISimpleHandler(API.getJourneyObjectiveSummaryList));
        restServer.createContext("/nglm-guimanager/getJourneyObjective", new APISimpleHandler(API.getJourneyObjective));
        restServer.createContext("/nglm-guimanager/putJourneyObjective", new APISimpleHandler(API.putJourneyObjective));
        restServer.createContext("/nglm-guimanager/setStatusJourneyObjective", new APISimpleHandler(API.setStatusJourneyObjective));
        restServer.createContext("/nglm-guimanager/removeJourneyObjective", new APISimpleHandler(API.removeJourneyObjective));
        restServer.createContext("/nglm-guimanager/getOfferObjectiveList", new APISimpleHandler(API.getOfferObjectiveList));
        restServer.createContext("/nglm-guimanager/getOfferObjectiveSummaryList", new APISimpleHandler(API.getOfferObjectiveSummaryList));
        restServer.createContext("/nglm-guimanager/getOfferObjective", new APISimpleHandler(API.getOfferObjective));
        restServer.createContext("/nglm-guimanager/putOfferObjective", new APISimpleHandler(API.putOfferObjective));
        restServer.createContext("/nglm-guimanager/removeOfferObjective", new APISimpleHandler(API.removeOfferObjective));
        restServer.createContext("/nglm-guimanager/setStatusOfferObjective", new APISimpleHandler(API.setStatusOfferObjective));
        restServer.createContext("/nglm-guimanager/getProductTypeList", new APISimpleHandler(API.getProductTypeList));
        restServer.createContext("/nglm-guimanager/getProductTypeSummaryList", new APISimpleHandler(API.getProductTypeSummaryList));
        restServer.createContext("/nglm-guimanager/getProductType", new APISimpleHandler(API.getProductType));
        restServer.createContext("/nglm-guimanager/putProductType", new APISimpleHandler(API.putProductType));
        restServer.createContext("/nglm-guimanager/removeProductType", new APISimpleHandler(API.removeProductType));
        restServer.createContext("/nglm-guimanager/setStatusProductType", new APISimpleHandler(API.setStatusProductType));
        restServer.createContext("/nglm-guimanager/getUCGRuleList", new APISimpleHandler(API.getUCGRuleList));
        restServer.createContext("/nglm-guimanager/getUCGRuleSummaryList",new APISimpleHandler(API.getUCGRuleSummaryList));
        restServer.createContext("/nglm-guimanager/getUCGRule", new APISimpleHandler(API.getUCGRule));
        restServer.createContext("/nglm-guimanager/putUCGRule", new APISimpleHandler(API.putUCGRule));
        restServer.createContext("/nglm-guimanager/removeUCGRule", new APISimpleHandler(API.removeUCGRule));
        restServer.createContext("/nglm-guimanager/setStatusUCGRule", new APISimpleHandler(API.setStatusUCGRule));
        restServer.createContext("/nglm-guimanager/getDeliverableList", new APISimpleHandler(API.getDeliverableList));
        restServer.createContext("/nglm-guimanager/getDeliverableSummaryList", new APISimpleHandler(API.getDeliverableSummaryList));
        restServer.createContext("/nglm-guimanager/getDeliverable", new APISimpleHandler(API.getDeliverable));
        restServer.createContext("/nglm-guimanager/putDeliverable", new APISimpleHandler(API.putDeliverable));
        restServer.createContext("/nglm-guimanager/removeDeliverable", new APISimpleHandler(API.removeDeliverable));
        restServer.createContext("/nglm-guimanager/setStatusDeliverable", new APISimpleHandler(API.setStatusDeliverable));
        restServer.createContext("/nglm-guimanager/getDeliverableByName", new APISimpleHandler(API.getDeliverableByName));
        restServer.createContext("/nglm-guimanager/getTokenTypeList", new APISimpleHandler(API.getTokenTypeList));
        restServer.createContext("/nglm-guimanager/getTokenTypeSummaryList", new APISimpleHandler(API.getTokenTypeSummaryList));
        restServer.createContext("/nglm-guimanager/putTokenType", new APISimpleHandler(API.putTokenType));
        restServer.createContext("/nglm-guimanager/getTokenType", new APISimpleHandler(API.getTokenType));
        restServer.createContext("/nglm-guimanager/removeTokenType", new APISimpleHandler(API.removeTokenType));
        restServer.createContext("/nglm-guimanager/getTokenCodesFormats", new APISimpleHandler(API.getTokenCodesFormats));
        restServer.createContext("/nglm-guimanager/setStatusTokenType", new APISimpleHandler(API.setStatusTokenType));
        
        restServer.createContext("/nglm-guimanager/getVoucherTypeList", new APISimpleHandler(API.getVoucherTypeList));
        restServer.createContext("/nglm-guimanager/getVoucherTypeSummaryList", new APISimpleHandler(API.getVoucherTypeSummaryList));
        restServer.createContext("/nglm-guimanager/putVoucherType", new APISimpleHandler(API.putVoucherType));
        restServer.createContext("/nglm-guimanager/getVoucherType", new APISimpleHandler(API.getVoucherType));
        restServer.createContext("/nglm-guimanager/removeVoucherType", new APISimpleHandler(API.removeVoucherType));
        restServer.createContext("/nglm-guimanager/setStatusVoucherType", new APISimpleHandler(API.setStatusVoucherType));
        restServer.createContext("/nglm-guimanager/getVoucherCodeFormatList", new APISimpleHandler(API.getVoucherCodeFormatList));
        
        restServer.createContext("/nglm-guimanager/getVoucherList", new APISimpleHandler(API.getVoucherList));
        restServer.createContext("/nglm-guimanager/getVoucherSummaryList", new APISimpleHandler(API.getVoucherSummaryList));
        restServer.createContext("/nglm-guimanager/putVoucher", new APISimpleHandler(API.putVoucher));
        restServer.createContext("/nglm-guimanager/getVoucher", new APISimpleHandler(API.getVoucher));
        restServer.createContext("/nglm-guimanager/removeVoucher", new APISimpleHandler(API.removeVoucher));
        restServer.createContext("/nglm-guimanager/setStatusVoucher", new APISimpleHandler(API.setStatusVoucher));
        restServer.createContext("/nglm-guimanager/redeemVoucher", new APISimpleHandler(API.redeemVoucher));
        restServer.createContext("/nglm-guimanager/extendVoucherValidity", new APISimpleHandler(API.extendVoucherValidity));
        restServer.createContext("/nglm-guimanager/expireVoucher", new APISimpleHandler(API.expireVoucher));
        
        restServer.createContext("/nglm-guimanager/getVoucherCodePatternList", new APISimpleHandler(API.getVoucherCodePatternList));
        restServer.createContext("/nglm-guimanager/generateVouchers", new APISimpleHandler(API.generateVouchers));

        restServer.createContext("/nglm-guimanager/getMailTemplateList", new APISimpleHandler(API.getMailTemplateList));
        restServer.createContext("/nglm-guimanager/getFullMailTemplateList", new APISimpleHandler(API.getFullMailTemplateList));
        restServer.createContext("/nglm-guimanager/getMailTemplateSummaryList", new APISimpleHandler(API.getMailTemplateSummaryList));
        restServer.createContext("/nglm-guimanager/getMailTemplate", new APISimpleHandler(API.getMailTemplate));
        restServer.createContext("/nglm-guimanager/putMailTemplate", new APISimpleHandler(API.putMailTemplate));
        restServer.createContext("/nglm-guimanager/removeMailTemplate", new APISimpleHandler(API.removeMailTemplate));
        restServer.createContext("/nglm-guimanager/setStatusMailTemplate", new APISimpleHandler(API.setStatusMailTemplate));
        restServer.createContext("/nglm-guimanager/getSMSTemplateList", new APISimpleHandler(API.getSMSTemplateList));
        restServer.createContext("/nglm-guimanager/getFullSMSTemplateList", new APISimpleHandler(API.getFullSMSTemplateList));
        restServer.createContext("/nglm-guimanager/getSMSTemplateSummaryList", new APISimpleHandler(API.getSMSTemplateSummaryList));
        restServer.createContext("/nglm-guimanager/getSMSTemplate", new APISimpleHandler(API.getSMSTemplate));
        restServer.createContext("/nglm-guimanager/putSMSTemplate", new APISimpleHandler(API.putSMSTemplate));
        restServer.createContext("/nglm-guimanager/removeSMSTemplate", new APISimpleHandler(API.removeSMSTemplate));
        restServer.createContext("/nglm-guimanager/setStatusSMSTemplate", new APISimpleHandler(API.setStatusSMSTemplate));
        
        restServer.createContext("/nglm-guimanager/getPushTemplateList", new APISimpleHandler(API.getPushTemplateList));
        restServer.createContext("/nglm-guimanager/getFullPushTemplateList", new APISimpleHandler(API.getFullPushTemplateList));
        restServer.createContext("/nglm-guimanager/getPushTemplateSummaryList", new APISimpleHandler(API.getPushTemplateSummaryList));
        restServer.createContext("/nglm-guimanager/getPushTemplate", new APISimpleHandler(API.getPushTemplate));
        restServer.createContext("/nglm-guimanager/putPushTemplate", new APISimpleHandler(API.putPushTemplate));
        restServer.createContext("/nglm-guimanager/removePushTemplate", new APISimpleHandler(API.removePushTemplate));
        restServer.createContext("/nglm-guimanager/setStatusPushTemplate", new APISimpleHandler(API.setStatusPushTemplate));
        
        restServer.createContext("/nglm-guimanager/getDialogTemplateList", new APISimpleHandler(API.getDialogTemplateList));
        restServer.createContext("/nglm-guimanager/getDialogTemplateSummaryList", new APISimpleHandler(API.getDialogTemplateSummaryList));
        restServer.createContext("/nglm-guimanager/getDialogTemplate", new APISimpleHandler(API.getDialogTemplate));
        restServer.createContext("/nglm-guimanager/putDialogTemplate", new APISimpleHandler(API.putDialogTemplate));
        restServer.createContext("/nglm-guimanager/removeDialogTemplate", new APISimpleHandler(API.removeDialogTemplate));
        restServer.createContext("/nglm-guimanager/setStatusDialogTemplate", new APISimpleHandler(API.setStatusDialogTemplate));
        
        restServer.createContext("/nglm-guimanager/getFulfillmentProviders", new APISimpleHandler(API.getFulfillmentProviders));
        restServer.createContext("/nglm-guimanager/getPaymentMeans", new APISimpleHandler(API.getPaymentMeans));
        restServer.createContext("/nglm-guimanager/getPaymentMeanList", new APISimpleHandler(API.getPaymentMeanList));
        restServer.createContext("/nglm-guimanager/getPaymentMeanSummaryList", new APISimpleHandler(API.getPaymentMeanSummaryList));
        restServer.createContext("/nglm-guimanager/getPaymentMean", new APISimpleHandler(API.getPaymentMean));
        restServer.createContext("/nglm-guimanager/putPaymentMean", new APISimpleHandler(API.putPaymentMean));
        restServer.createContext("/nglm-guimanager/removePaymentMean", new APISimpleHandler(API.removePaymentMean));
        restServer.createContext("/nglm-guimanager/setStatusPaymentMean", new APISimpleHandler(API.setStatusPaymentMean));
        restServer.createContext("/nglm-guimanager/getDashboardCounts", new APISimpleHandler(API.getDashboardCounts));
        restServer.createContext("/nglm-guimanager/getCustomer", new APISimpleHandler(API.getCustomer));
        restServer.createContext("/nglm-guimanager/getCustomerMetaData", new APISimpleHandler(API.getCustomerMetaData));
        restServer.createContext("/nglm-guimanager/getCustomerBDRs", new APISimpleHandler(API.getCustomerBDRs));
        restServer.createContext("/nglm-guimanager/getCustomerEDRs", new APISimpleHandler(API.getCustomerEDRs));
        restServer.createContext("/nglm-guimanager/getCustomerODRs", new APISimpleHandler(API.getCustomerODRs));
        restServer.createContext("/nglm-guimanager/getCustomerMessages", new APISimpleHandler(API.getCustomerMessages));
        restServer.createContext("/nglm-guimanager/getCustomerJourneys", new APISimpleHandler(API.getCustomerJourneys));
        restServer.createContext("/nglm-guimanager/getCustomerCampaigns", new APISimpleHandler(API.getCustomerCampaigns));
        restServer.createContext("/nglm-guimanager/getCustomerPoints", new APISimpleHandler(API.getCustomerPoints));
        restServer.createContext("/nglm-guimanager/getCustomerLoyaltyPrograms", new APISimpleHandler(API.getCustomerLoyaltyPrograms));
        restServer.createContext("/nglm-guimanager/refreshUCG", new APISimpleHandler(API.refreshUCG));
        restServer.createContext("/nglm-guimanager/getUploadedFileList", new APISimpleHandler(API.getUploadedFileList));
        restServer.createContext("/nglm-guimanager/getUploadedFileSummaryList", new APISimpleHandler(API.getUploadedFileSummaryList));
        restServer.createContext("/nglm-guimanager/removeUploadedFile", new APISimpleHandler(API.removeUploadedFile));
        restServer.createContext("/nglm-guimanager/putUploadedFile", new APIComplexHandler(API.putUploadedFile));
        restServer.createContext("/nglm-guimanager/putUploadedFileWithVariables", new APIComplexHandler(API.putUploadedFileWithVariables));
        restServer.createContext("/nglm-guimanager/getCustomerAlternateIDs", new APISimpleHandler(API.getCustomerAlternateIDs));
        restServer.createContext("/nglm-guimanager/getCustomerAvailableCampaigns", new APISimpleHandler(API.getCustomerAvailableCampaigns));
        restServer.createContext("/nglm-guimanager/getTargetList", new APISimpleHandler(API.getTargetList));
        restServer.createContext("/nglm-guimanager/getTargetSummaryList", new APISimpleHandler(API.getTargetSummaryList));
        restServer.createContext("/nglm-guimanager/putTarget", new APISimpleHandler(API.putTarget));
        restServer.createContext("/nglm-guimanager/getTarget", new APISimpleHandler(API.getTarget));
        restServer.createContext("/nglm-guimanager/setStatusTarget", new APISimpleHandler(API.setStatusTarget));
        restServer.createContext("/nglm-guimanager/removeTarget", new APISimpleHandler(API.removeTarget));
        restServer.createContext("/nglm-guimanager/updateCustomer", new APISimpleHandler(API.updateCustomer));
        restServer.createContext("/nglm-guimanager/updateCustomerParent", new APISimpleHandler(API.updateCustomerParent));
        restServer.createContext("/nglm-guimanager/removeCustomerParent", new APISimpleHandler(API.removeCustomerParent));
        restServer.createContext("/nglm-guimanager/getCommunicationChannelList", new APISimpleHandler(API.getCommunicationChannelList));
        restServer.createContext("/nglm-guimanager/getCommunicationChannelSummaryList", new APISimpleHandler(API.getCommunicationChannelSummaryList));
        restServer.createContext("/nglm-guimanager/getCommunicationChannel", new APISimpleHandler(API.getCommunicationChannel));
        restServer.createContext("/nglm-guimanager/putCommunicationChannel", new APISimpleHandler(API.putCommunicationChannel));
        restServer.createContext("/nglm-guimanager/getBlackoutPeriodsList", new APISimpleHandler(API.getBlackoutPeriodsList));
        restServer.createContext("/nglm-guimanager/getBlackoutPeriodsSummaryList", new APISimpleHandler(API.getBlackoutPeriodsSummaryList));
        restServer.createContext("/nglm-guimanager/getBlackoutPeriods", new APISimpleHandler(API.getBlackoutPeriods));
        restServer.createContext("/nglm-guimanager/putBlackoutPeriods", new APISimpleHandler(API.putBlackoutPeriods));
        restServer.createContext("/nglm-guimanager/setStatusBlackoutPeriods", new APISimpleHandler(API.setStatusBlackoutPeriods));
        
        restServer.createContext("/nglm-guimanager/getTimeWindowsList", new APISimpleHandler(API.getTimeWindowsList));
        restServer.createContext("/nglm-guimanager/getTimeWindowsSummaryList", new APISimpleHandler(API.getTimeWindowsSummaryList));
        restServer.createContext("/nglm-guimanager/getTimeWindows", new APISimpleHandler(API.getTimeWindows));
        restServer.createContext("/nglm-guimanager/putTimeWindows", new APISimpleHandler(API.putTimeWindows));

        restServer.createContext("/nglm-guimanager/removeBlackoutPeriods", new APISimpleHandler(API.removeBlackoutPeriods));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramTypeList", new APISimpleHandler(API.getLoyaltyProgramTypeList));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramList", new APISimpleHandler(API.getLoyaltyProgramList));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramChallengeList", new APISimpleHandler(API.getLoyaltyProgramChallengeList));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramMissionList", new APISimpleHandler(API.getLoyaltyProgramMissionList));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramSummaryList", new APISimpleHandler(API.getLoyaltyProgramSummaryList));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramChallengeSummaryList", new APISimpleHandler(API.getLoyaltyProgramChallengeSummaryList));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramMissionSummaryList", new APISimpleHandler(API.getLoyaltyProgramMissionSummaryList));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgram", new APISimpleHandler(API.getLoyaltyProgram));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramChallenge", new APISimpleHandler(API.getLoyaltyProgramChallenge));
        restServer.createContext("/nglm-guimanager/getLoyaltyProgramMission", new APISimpleHandler(API.getLoyaltyProgramMission));
        restServer.createContext("/nglm-guimanager/putLoyaltyProgram", new APISimpleHandler(API.putLoyaltyProgram));
        restServer.createContext("/nglm-guimanager/putLoyaltyProgramChallenge", new APISimpleHandler(API.putLoyaltyProgramChallenge));
        restServer.createContext("/nglm-guimanager/putLoyaltyProgramMission", new APISimpleHandler(API.putLoyaltyProgramMission));
        restServer.createContext("/nglm-guimanager/updateMission", new APISimpleHandler(API.updateMission));
        restServer.createContext("/nglm-guimanager/updateChallenge", new APISimpleHandler(API.updateChallenge));
        restServer.createContext("/nglm-guimanager/removeLoyaltyProgram", new APISimpleHandler(API.removeLoyaltyProgram));
        restServer.createContext("/nglm-guimanager/setStatusLoyaltyProgram", new APISimpleHandler(API.setStatusLoyaltyProgram));
        restServer.createContext("/nglm-guimanager/getResellerList", new APISimpleHandler(API.getResellerList));
        restServer.createContext("/nglm-guimanager/getResellerSummaryList", new APISimpleHandler(API.getResellerSummaryList));
        restServer.createContext("/nglm-guimanager/getReseller", new APISimpleHandler(API.getReseller));
        restServer.createContext("/nglm-guimanager/putReseller", new APISimpleHandler(API.putReseller));
        restServer.createContext("/nglm-guimanager/setStatusReseller", new APISimpleHandler(API.setStatusReseller));
        restServer.createContext("/nglm-guimanager/removeReseller", new APISimpleHandler(API.removeReseller));
        restServer.createContext("/nglm-guimanager/enterCampaign", new APISimpleHandler(API.enterCampaign));
        restServer.createContext("/nglm-guimanager/creditBonus", new APISimpleHandler(API.creditBonus));
        restServer.createContext("/nglm-guimanager/debitBonus", new APISimpleHandler(API.debitBonus));
        restServer.createContext("/nglm-guimanager/getExclusionInclusionTargetList", new APISimpleHandler(API.getExclusionInclusionTargetList));
        restServer.createContext("/nglm-guimanager/getExclusionInclusionTargetSummaryList", new APISimpleHandler(API.getExclusionInclusionTargetSummaryList));
        restServer.createContext("/nglm-guimanager/putExclusionInclusionTarget", new APISimpleHandler(API.putExclusionInclusionTarget));
        restServer.createContext("/nglm-guimanager/getExclusionInclusionTarget", new APISimpleHandler(API.getExclusionInclusionTarget));
        restServer.createContext("/nglm-guimanager/removeExclusionInclusionTarget", new APISimpleHandler(API.removeExclusionInclusionTarget));
        restServer.createContext("/nglm-guimanager/getSegmentContactPolicyList", new APISimpleHandler(API.getSegmentContactPolicyList));
        restServer.createContext("/nglm-guimanager/setStatusExclusionInclusionTarget", new APISimpleHandler(API.setStatusExclusionInclusionTarget));
        restServer.createContext("/nglm-guimanager/getSegmentContactPolicySummaryList", new APISimpleHandler(API.getSegmentContactPolicySummaryList));
        restServer.createContext("/nglm-guimanager/putSegmentContactPolicy", new APISimpleHandler(API.putSegmentContactPolicy));
        restServer.createContext("/nglm-guimanager/getSegmentContactPolicy", new APISimpleHandler(API.getSegmentContactPolicy));
        restServer.createContext("/nglm-guimanager/removeSegmentContactPolicy", new APISimpleHandler(API.removeSegmentContactPolicy)); 
        restServer.createContext("/nglm-guimanager/setStatusSegmentContactPolicy", new APISimpleHandler(API.setStatusSegmentContactPolicy));
        restServer.createContext("/nglm-configadaptor/getSupportedLanguages", new APISimpleHandler(API.configAdaptorSupportedLanguages));
        restServer.createContext("/nglm-configadaptor/getSubscriberMessageTemplate", new APISimpleHandler(API.configAdaptorSubscriberMessageTemplate));
        restServer.createContext("/nglm-configadaptor/getOffer", new APISimpleHandler(API.configAdaptorOffer));
        restServer.createContext("/nglm-configadaptor/getProduct", new APISimpleHandler(API.configAdaptorProduct));
        restServer.createContext("/nglm-configadaptor/getPresentationStrategy", new APISimpleHandler(API.configAdaptorPresentationStrategy));
        restServer.createContext("/nglm-configadaptor/getScoringStrategy", new APISimpleHandler(API.configAdaptorScoringStrategy));
        restServer.createContext("/nglm-configadaptor/getCallingChannel", new APISimpleHandler(API.configAdaptorCallingChannel));
        restServer.createContext("/nglm-configadaptor/getSalesChannel", new APISimpleHandler(API.configAdaptorSalesChannel));
        restServer.createContext("/nglm-configadaptor/getCommunicationChannel", new APISimpleHandler(API.configAdaptorCommunicationChannel));
        restServer.createContext("/nglm-configadaptor/getBlackoutPeriods", new APISimpleHandler(API.configAdaptorBlackoutPeriods));
        restServer.createContext("/nglm-configadaptor/getContactPolicy", new APISimpleHandler(API.configAdaptorContactPolicy));
        restServer.createContext("/nglm-configadaptor/getSegmentationDimension", new APISimpleHandler(API.configAdaptorSegmentationDimension));
        restServer.createContext("/nglm-configadaptor/getCampaign", new APISimpleHandler(API.configAdaptorCampaign));
        restServer.createContext("/nglm-configadaptor/getJourneyObjective", new APISimpleHandler(API.configAdaptorJourneyObjective));
        restServer.createContext("/nglm-configadaptor/getProductType", new APISimpleHandler(API.configAdaptorProductType));
        restServer.createContext("/nglm-configadaptor/getOfferObjective", new APISimpleHandler(API.configAdaptorOfferObjective));
        restServer.createContext("/nglm-configadaptor/getScoringEngines", new APISimpleHandler(API.configAdaptorScoringEngines));
        restServer.createContext("/nglm-configadaptor/getPresentationCriterionFields", new APISimpleHandler(API.configAdaptorPresentationCriterionFields));
        restServer.createContext("/nglm-configadaptor/getDefaultNoftificationDailyWindows", new APISimpleHandler(API.configAdaptorDefaultNoftificationDailyWindows));
        restServer.createContext("/nglm-configadaptor/getDeliverable", new APISimpleHandler(API.configAdaptorDeliverable));
        restServer.createContext("/nglm-configadaptor/getSourceAddress", new APISimpleHandler(API.configAdaptorSourceAddress));
        restServer.createContext("/nglm-guimanager/getBillingModes", new APISimpleHandler(API.getBillingModes));
        restServer.createContext("/nglm-guimanager/getPartnerTypes", new APISimpleHandler(API.getPartnerTypes));
        restServer.createContext("/nglm-guimanager/getCriterionFieldAvailableValuesList", new APISimpleHandler(API.getCriterionFieldAvailableValuesList));
        restServer.createContext("/nglm-guimanager/getCriterionFieldAvailableValuesSummaryList", new APISimpleHandler(API.getCriterionFieldAvailableValuesSummaryList));
        restServer.createContext("/nglm-guimanager/getCriterionFieldAvailableValues", new APISimpleHandler(API.getCriterionFieldAvailableValues));
        restServer.createContext("/nglm-guimanager/putCriterionFieldAvailableValues", new APISimpleHandler(API.putCriterionFieldAvailableValues));
        restServer.createContext("/nglm-guimanager/removeCriterionFieldAvailableValues", new APISimpleHandler(API.removeCriterionFieldAvailableValues));
        restServer.createContext("/nglm-guimanager/setStatusCriterionFieldAvailableValues", new APISimpleHandler(API.setStatusCriterionFieldAvailableValues));
        restServer.createContext("/nglm-guimanager/getEffectiveSystemTime", new APISimpleHandler(API.getEffectiveSystemTime));
        restServer.createContext("/nglm-guimanager/getCustomerNBOs", new APISimpleHandler(API.getCustomerNBOs));
        restServer.createContext("/nglm-guimanager/getTokensCodesList", new APISimpleHandler(API.getTokensCodesList));
        restServer.createContext("/nglm-guimanager/acceptOffer", new APISimpleHandler(API.acceptOffer));
        restServer.createContext("/nglm-guimanager/purchaseOffer", new APISimpleHandler(API.purchaseOffer));
        restServer.createContext("/nglm-guimanager/getOffersList", new APISimpleHandler(API.getOffersList));

        restServer.createContext("/nglm-guimanager/getTokenEventDetails", new APISimpleHandler(API.getTokenEventDetails));
        restServer.createContext("/nglm-guimanager/getTenantList", new APISimpleHandler(API.getTenantList));
        
        restServer.createContext("/nglm-guimanager/getSourceAddressList", new APISimpleHandler(API.getSourceAddressList));
        restServer.createContext("/nglm-guimanager/getSourceAddressSummaryList", new APISimpleHandler(API.getSourceAddressSummaryList));
        restServer.createContext("/nglm-guimanager/getSourceAddress", new APISimpleHandler(API.getSourceAddress));
        restServer.createContext("/nglm-guimanager/putSourceAddress", new APISimpleHandler(API.putSourceAddress));
        restServer.createContext("/nglm-guimanager/removeSourceAddress", new APISimpleHandler(API.removeSourceAddress));

        restServer.createContext("/nglm-guimanager/setStatusSourceAddress", new APISimpleHandler(API.setStatusSourceAddress));
        
        restServer.createContext("/nglm-guimanager/putSimpleOfferThirdParty", new APISimpleHandler(API.putSimpleOfferThirdParty));
        restServer.createContext("/nglm-guimanager/getSimpleOfferListThirdParty", new APISimpleHandler(API.getSimpleOfferListThirdParty));
        restServer.createContext("/nglm-guimanager/removeSimpleOfferThirdParty", new APISimpleHandler(API.removeSimpleOfferThirdParty));
        restServer.createContext("/nglm-guimanager/loyaltyProgramOptIn", new APISimpleHandler(API.loyaltyProgramOptIn));
        restServer.createContext("/nglm-guimanager/loyaltyProgramOptOut", new APISimpleHandler(API.loyaltyProgramOptOut));
        restServer.createContext("/nglm-guimanager/getDependencies", new APISimpleHandler(API.getDependencies));
        restServer.createContext("/nglm-guimanager/getSoftwareVersions", new APISimpleHandler(API.getSoftwareVersions));

        restServer.createContext("/nglm-guimanager/launchExtract", new APISimpleHandler(API.launchExtract));
        restServer.createContext("/nglm-guimanager/downloadExtractFile", new APIComplexHandler(API.downloadExtractFile));
        restServer.createContext("/nglm-guimanager/launchAndDownloadExtract", new APIComplexHandler(API.launchAndDownloadExtract));
        
        restServer.createContext("/nglm-guimanager/putSimpleOffer", new APISimpleHandler(API.putSimpleOffer));
        restServer.createContext("/nglm-guimanager/getSimpleOffer", new APISimpleHandler(API.getSimpleOffer));
        restServer.createContext("/nglm-guimanager/getSimpleOfferList", new APISimpleHandler(API.getSimpleOfferList));
        restServer.createContext("/nglm-guimanager/getSimpleOfferSummaryList", new APISimpleHandler(API.getSimpleOfferSummaryList));
        restServer.createContext("/nglm-guimanager/removeSimpleOffer", new APISimpleHandler(API.removeSimpleOffer));

        
        restServer.setExecutor(Executors.newFixedThreadPool(10));
        restServer.start();
      }
    catch (IOException e)
      {
        throw new ServerRuntimeException("could not initialize REST server", e);
      }

    /*****************************************
    *
    *  context
    *
    *****************************************/

    guiManagerContext = new GUIManagerContext(journeyService, segmentationDimensionService, pointService, complexObjectTypeService, offerService, reportService, paymentMeanService, scoringStrategyService, presentationStrategyService, callingChannelService, salesChannelService, sourceAddressService, supplierService, productService, catalogCharacteristicService, contactPolicyService, journeyObjectiveService, offerObjectiveService, productTypeService, ucgRuleService, deliverableService, tokenTypeService, voucherTypeService, voucherService, subscriberMessageTemplateService, subscriberProfileService, subscriberIDService, uploadedFileService, targetService, communicationChannelBlackoutService, loyaltyProgramService, resellerService, exclusionInclusionTargetService, segmentContactPolicyService, criterionFieldAvailableValuesService);

    /*****************************************
    *
    *  shutdown hook
    *
    *****************************************/

    NGLMRuntime.addShutdownHook(new ShutdownHook(kafkaProducer, restServer, dynamicCriterionFieldService, journeyService, segmentationDimensionService, pointService, complexObjectTypeService, offerService, scoringStrategyService, presentationStrategyService, callingChannelService, salesChannelService, sourceAddressService, supplierService, productService, catalogCharacteristicService, contactPolicyService, journeyObjectiveService, offerObjectiveService, productTypeService, ucgRuleService, deliverableService, tokenTypeService, voucherTypeService, voucherService, subscriberProfileService, subscriberIDService, subscriberGroupEpochReader, renamedProfileCriterionFieldReader, reportService, subscriberMessageTemplateService, uploadedFileService, targetService, communicationChannelBlackoutService, loyaltyProgramService, resellerService, exclusionInclusionTargetService, dnboMatrixService, segmentContactPolicyService, criterionFieldAvailableValuesService, elasticsearchManager));

    /*****************************************
    *
    *  guiManagerJobScheduler
    *
    *****************************************/
    
    JobScheduler guiManagerJobScheduler = new JobScheduler("GUIManager");
    String periodicGenerationCronEntry = "5 1,6,11,16,21 * * *";
    String qaCronEntry = "5,10,15,30,45,59 * * * *";
    ScheduledJob recurrnetCampaignCreationJob = new RecurrentCampaignCreationJob("Recurrent Campaign(create)", periodicGenerationCronEntry, Deployment.getDefault().getTimeZone(), false); // TODO EVPRO-99 i used systemTimeZone instead of BaseTimeZone pet tenant, check if correct
    ScheduledJob challengesOccurrenceJob = new ChallengesOccurrenceJob("Challenges Occurrence", periodicGenerationCronEntry, Deployment.getDefault().getTimeZone(), false);
    if(recurrnetCampaignCreationJob.isProperlyConfigured() && challengesOccurrenceJob.isProperlyConfigured())
      {
        guiManagerJobScheduler.schedule(recurrnetCampaignCreationJob);
        guiManagerJobScheduler.schedule(challengesOccurrenceJob);
        new Thread(guiManagerJobScheduler::runScheduler, "guiManagerJobScheduler").start();
      }
    else
      {
        if (log.isErrorEnabled()) log.error("invalid recurrnetCampaignCreationJob or ChallengesOccurrenceJob cron");
      }
    
    /*****************************************
    *
    *  Ensure Grafana configuration per tenant
    *
    *****************************************/  
    Thread grafanaThread = new Thread(new Runnable()
    {      
      @Override
      public void run()
      {
        boolean grafanaStarted = false;
        while (!grafanaStarted) {
          grafanaStarted = GrafanaUtils.prepareGrafanaForTenants();
        }        
      }
    });
    grafanaThread.start();


  /*****************************************
   *
   * log restServerStarted
   *
   *****************************************/

  log.info("main restServerStarted");

  }

  /*****************************************
  *
  *  class ShutdownHook
  *
  *****************************************/

  private static class ShutdownHook implements NGLMRuntime.NGLMShutdownHook
  {
    //
    //  data
    //

    private KafkaProducer<byte[], byte[]> kafkaProducer;
    private HttpServer restServer;
    private DynamicCriterionFieldService dynamicCriterionFieldService;
    private JourneyService journeyService;
    private SegmentationDimensionService segmentationDimensionService;
    private DNBOMatrixService dnboMatrixService;
    private PointService pointService;
    private ComplexObjectTypeService complexObjectTypeService;
    private OfferService offerService;
    private ReportService reportService;
    private ScoringStrategyService scoringStrategyService;
    private PresentationStrategyService presentationStrategyService;
    private CallingChannelService callingChannelService;
    private SalesChannelService salesChannelService;
    private SourceAddressService sourceAddressService;
    private SupplierService supplierService;
    private ProductService productService;
    private CatalogCharacteristicService catalogCharacteristicService;
    private ContactPolicyService contactPolicyService;
    private JourneyObjectiveService journeyObjectiveService;
    private OfferObjectiveService offerObjectiveService;
    private ProductTypeService productTypeService;
    private UCGRuleService ucgRuleService;
    private DeliverableService deliverableService;
    private TokenTypeService tokenTypeService;
    private VoucherTypeService voucherTypeService;
    private VoucherService voucherService;
    private SubscriberMessageTemplateService subscriberMessageTemplateService;
    private SubscriberProfileService subscriberProfileService;
    private SubscriberIDService subscriberIDService;
    private ReferenceDataReader<String,SubscriberGroupEpoch> subscriberGroupEpochReader;
    private ReferenceDataReader<String,RenamedProfileCriterionField> renamedProfileCriterionFieldReader;
    private UploadedFileService uploadedFileService;
    private TargetService targetService;
    private CommunicationChannelBlackoutService communicationChannelBlackoutService;
    private LoyaltyProgramService loyaltyProgramService;
    private ExclusionInclusionTargetService exclusionInclusionTargetService;
    private ResellerService resellerService;
    private SegmentContactPolicyService segmentContactPolicyService;
    private CriterionFieldAvailableValuesService criterionFieldAvailableValuesService;
    private ElasticsearchManager elasticsearchManager;

    //
    //  constructor
    //
    
    private ShutdownHook(KafkaProducer<byte[], byte[]> kafkaProducer, HttpServer restServer, DynamicCriterionFieldService dynamicCriterionFieldService, JourneyService journeyService, SegmentationDimensionService segmentationDimensionService, PointService pointService, ComplexObjectTypeService complexObjectTypeService, OfferService offerService, ScoringStrategyService scoringStrategyService, PresentationStrategyService presentationStrategyService, CallingChannelService callingChannelService, SalesChannelService salesChannelService, SourceAddressService sourceAddressService, SupplierService supplierService, ProductService productService, CatalogCharacteristicService catalogCharacteristicService, ContactPolicyService contactPolicyService, JourneyObjectiveService journeyObjectiveService, OfferObjectiveService offerObjectiveService, ProductTypeService productTypeService, UCGRuleService ucgRuleService, DeliverableService deliverableService, TokenTypeService tokenTypeService, VoucherTypeService voucherTypeService, VoucherService voucherService, SubscriberProfileService subscriberProfileService, SubscriberIDService subscriberIDService, ReferenceDataReader<String,SubscriberGroupEpoch> subscriberGroupEpochReader, ReferenceDataReader<String,RenamedProfileCriterionField> renamedProfileCriterionFieldReader, ReportService reportService, SubscriberMessageTemplateService subscriberMessageTemplateService, UploadedFileService uploadedFileService, TargetService targetService, CommunicationChannelBlackoutService communicationChannelBlackoutService, LoyaltyProgramService loyaltyProgramService, ResellerService resellerService, ExclusionInclusionTargetService exclusionInclusionTargetService, DNBOMatrixService dnboMatrixService, SegmentContactPolicyService segmentContactPolicyService, CriterionFieldAvailableValuesService criterionFieldAvailableValuesService, ElasticsearchManager elasticsearchManager)
    {
      this.kafkaProducer = kafkaProducer;
      this.restServer = restServer;
      this.dynamicCriterionFieldService = dynamicCriterionFieldService;
      this.journeyService = journeyService;
      this.segmentationDimensionService = segmentationDimensionService;
      this.pointService = pointService;
      this.complexObjectTypeService = complexObjectTypeService;
      this.offerService = offerService;
      this.reportService = reportService;
      this.scoringStrategyService = scoringStrategyService;
      this.presentationStrategyService = presentationStrategyService;
      this.callingChannelService = callingChannelService;
      this.salesChannelService = salesChannelService;
      this.sourceAddressService = sourceAddressService;
      this.supplierService = supplierService;
      this.productService = productService;
      this.catalogCharacteristicService = catalogCharacteristicService;
      this.contactPolicyService = contactPolicyService;
      this.journeyObjectiveService = journeyObjectiveService;
      this.offerObjectiveService = offerObjectiveService;
      this.productTypeService = productTypeService;
      this.ucgRuleService = ucgRuleService;
      this.deliverableService = deliverableService;
      this.tokenTypeService = tokenTypeService;
      this.voucherTypeService = voucherTypeService;
      this.voucherService = voucherService;
      this.subscriberMessageTemplateService = subscriberMessageTemplateService;
      this.subscriberProfileService = subscriberProfileService;
      this.subscriberIDService = subscriberIDService;
      this.subscriberGroupEpochReader = subscriberGroupEpochReader;
      this.renamedProfileCriterionFieldReader = renamedProfileCriterionFieldReader;
      this.uploadedFileService = uploadedFileService;
      this.targetService = targetService;
      this.communicationChannelBlackoutService = communicationChannelBlackoutService;
      this.loyaltyProgramService = loyaltyProgramService;
      this.exclusionInclusionTargetService = exclusionInclusionTargetService;
      this.resellerService = resellerService;
      this.dnboMatrixService = dnboMatrixService;
      this.segmentContactPolicyService = segmentContactPolicyService;
      this.criterionFieldAvailableValuesService = criterionFieldAvailableValuesService;
      this.elasticsearchManager = elasticsearchManager;
    }

    //
    //  shutdown
    //

    @Override public void shutdown(boolean normalShutdown)
    {

      if (elasticsearchManager != null) elasticsearchManager.stop();

      //
      //  services 
      //

      if (dynamicCriterionFieldService != null) dynamicCriterionFieldService.stop();
      if (journeyService != null) journeyService.stop();
      if (segmentationDimensionService != null) segmentationDimensionService.stop();
      if (pointService != null) pointService.stop();
      if (complexObjectTypeService != null) complexObjectTypeService.stop();
      if (offerService != null) offerService.stop();
      if (reportService != null) reportService.stop();
      if (scoringStrategyService != null) scoringStrategyService.stop();
      if (presentationStrategyService != null) presentationStrategyService.stop();
      if (callingChannelService != null) callingChannelService.stop();
      if (salesChannelService != null) salesChannelService.stop();
      if (sourceAddressService != null) sourceAddressService.stop();
      if (supplierService != null) supplierService.stop();
      if (productService != null) productService.stop();
      if (catalogCharacteristicService != null) catalogCharacteristicService.stop();
      if (contactPolicyService != null) contactPolicyService.stop();
      if (journeyObjectiveService != null) journeyObjectiveService.stop();
      if (offerObjectiveService != null) offerObjectiveService.stop();
      if (productTypeService != null) productTypeService.stop();
      if (ucgRuleService != null) ucgRuleService.stop();
      if (deliverableService != null) deliverableService.stop();
      if (tokenTypeService != null) tokenTypeService.stop();
      if (voucherTypeService != null) voucherTypeService.stop();
      if (voucherService != null) voucherService.stop();
      if (subscriberMessageTemplateService != null) subscriberMessageTemplateService.stop();
      if (subscriberProfileService != null) subscriberProfileService.stop();
      if (subscriberIDService != null) subscriberIDService.stop();
      if (uploadedFileService != null) uploadedFileService.stop();
      if (targetService != null) targetService.stop();
      if (loyaltyProgramService != null) loyaltyProgramService.stop();
      if (exclusionInclusionTargetService != null) exclusionInclusionTargetService.stop();
      if (resellerService != null) resellerService.stop();
      if (dnboMatrixService != null) dnboMatrixService.stop();
      if (segmentContactPolicyService != null) segmentContactPolicyService.stop();
      if (criterionFieldAvailableValuesService != null) criterionFieldAvailableValuesService.stop();

      //
      //  rest server
      //

      if (restServer != null) restServer.stop(1);

      //
      //  kafkaProducer
      //

      if (kafkaProducer != null) kafkaProducer.close();
    }
  }

  /*****************************************
  *
  *  handleAPI
  *
  *****************************************/

  private synchronized void handleSimpleHandler(API api, HttpExchange exchange) throws IOException
  {
    try
      {
        /*****************************************
        *
        *  get the user
        *
        *****************************************/

        String userID = null;
        if (exchange.getRequestURI().getQuery() != null)
          {
            Pattern pattern = Pattern.compile("^(.*\\&user_id|user_id)=(.*?)(\\&.*$|$)");
            Matcher matcher = pattern.matcher(exchange.getRequestURI().getQuery());
            if (matcher.matches())
              {
                userID = matcher.group(2);
              }
          }

        /*****************************************
        *
        *  get the body
        *
        *****************************************/

        StringBuilder requestBodyStringBuilder = new StringBuilder();
        BufferedReader reader = new BufferedReader(new InputStreamReader(exchange.getRequestBody()));
        while (true)
          {
            String line = reader.readLine();
            if (line == null) break;
            requestBodyStringBuilder.append(line);
          }
        reader.close();
        log.debug("API (raw request): {} {}",api,requestBodyStringBuilder.toString());
        JSONObject jsonRoot = (JSONObject) (new JSONParser()).parse(requestBodyStringBuilder.toString());
        
        /*****************************************
        *
        *  get the tenant
        *
        *****************************************/
        
        Integer tenantID = JSONUtilities.decodeInteger(jsonRoot, "tenantID", null);

        /*****************************************
        *
        *  validate
        *
        *****************************************/

        int apiVersion = JSONUtilities.decodeInteger(jsonRoot, "apiVersion", true);
        if (apiVersion > RESTAPIVersion)
          {
            throw new ServerRuntimeException("unknown api version " + apiVersion);
          }
        jsonRoot.remove("apiVersion");

        /*****************************************
        *
        *  license state
        *
        *****************************************/

        LicenseState licenseState = licenseChecker.checkLicense();
        Alarm licenseAlarm = licenseState.getHighestAlarm();
        boolean allowAccess = true;
        switch (licenseAlarm.getLevel())
          {
            case None:
            case Alert:
            case Alarm:
              allowAccess = true;
              break;

            case Limit:
            case Block:
              allowAccess = false;
              break;
          }

        /*****************************************
        *
        *  userID
        *
        *****************************************/

        String jsonUserID = JSONUtilities.decodeString(jsonRoot, "userID", false);
        if (jsonUserID == null && userID != null)
          {
            jsonRoot.put("userID", userID);
          }

        /*****************************************
        *
        *  includeArchived
        *
        *****************************************/

        boolean includeArchived = JSONUtilities.decodeBoolean(jsonRoot, "includeArchived", Boolean.FALSE);

        /*****************************************
        *
        *  process
        *
        *****************************************/

        JSONObject jsonResponse = null;
        if (licenseState.isValid() && allowAccess)
          {
            switch (api)
              {
                case getStaticConfiguration:
                  jsonResponse = guiManagerGeneral.processGetStaticConfiguration(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case getSupportedLanguages:
                  jsonResponse = guiManagerGeneral.processGetSupportedLanguages(userID, jsonRoot, tenantID);
                  break;

                case getSupportedCurrencies:
                  jsonResponse = guiManagerGeneral.processGetSupportedCurrencies(userID, jsonRoot, tenantID);
                  break;

                case getSupportedTimeUnits:
                  jsonResponse = guiManagerGeneral.processGetSupportedTimeUnits(userID, jsonRoot, tenantID);
                  break;

                case getSupportedRelationships:
                  jsonResponse = processGetSupportedRelationships(userID, jsonRoot, tenantID);
                  break;

                case getCallingChannelProperties:
                  jsonResponse = processGetCallingChannelProperties(userID, jsonRoot, tenantID);
                  break;

                case getCatalogCharacteristicUnits:
                  jsonResponse = guiManagerGeneral.processGetCatalogCharacteristicUnits(userID, jsonRoot, tenantID);
                  break;

                case getSupportedDataTypes:
                  jsonResponse = guiManagerGeneral.processGetSupportedDataTypes(userID, jsonRoot, tenantID);
                  break;

                case getSupportedEvents:
                  jsonResponse = guiManagerGeneral.processGetSupportedEvents(userID, jsonRoot, tenantID);
                  break;

                case getLoyaltyProgramPointsEvents:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgramPointsEvents(userID, jsonRoot, tenantID);
                  break;

                case getSupportedTargetingTypes:
                  jsonResponse = processGetSupportedTargetingTypes(userID, jsonRoot, tenantID);
                  break;

                case getProfileCriterionFields:
                  jsonResponse = processGetProfileCriterionFields(userID, jsonRoot, getIncludeDynamicParameter(jsonRoot) ? CriterionContext.DynamicProfile(tenantID) : CriterionContext.Profile(tenantID), tenantID);
                  break;

                case getProfileCriterionFieldIDs:
                  jsonResponse = processGetProfileCriterionFieldIDs(userID, jsonRoot, getIncludeDynamicParameter(jsonRoot) ? CriterionContext.DynamicProfile(tenantID) : CriterionContext.Profile(tenantID), tenantID);
                  break;

                case getProfileCriterionField:
                  jsonResponse = processGetProfileCriterionField(userID, jsonRoot, getIncludeDynamicParameter(jsonRoot) ? CriterionContext.DynamicProfile(tenantID) : CriterionContext.Profile(tenantID), tenantID);
                  break;

                case getFullProfileCriterionFields:
                  jsonResponse = processGetProfileCriterionFields(userID, jsonRoot, getIncludeDynamicParameter(jsonRoot) ? CriterionContext.FullDynamicProfile(tenantID) : CriterionContext.FullProfile(tenantID), tenantID);
                  break;

                case getFullProfileCriterionFieldIDs:
                  jsonResponse = processGetProfileCriterionFieldIDs(userID, jsonRoot, getIncludeDynamicParameter(jsonRoot) ? CriterionContext.FullDynamicProfile(tenantID) : CriterionContext.FullProfile(tenantID), tenantID);
                  break;

                case getFullProfileCriterionField:
                  jsonResponse = processGetProfileCriterionField(userID, jsonRoot, getIncludeDynamicParameter(jsonRoot) ? CriterionContext.FullDynamicProfile(tenantID) : CriterionContext.FullProfile(tenantID), tenantID);
                  break;

                case getPresentationCriterionFields:
                  jsonResponse = processGetPresentationCriterionFields(userID, jsonRoot, tenantID);
                  break;

                case getPresentationCriterionFieldIDs:
                  jsonResponse = processGetPresentationCriterionFieldIDs(userID, jsonRoot, tenantID);
                  break;

                case getPresentationCriterionField:
                  jsonResponse = processGetPresentationCriterionField(userID, jsonRoot, tenantID);
                  break;

                case getJourneyCriterionFields:
                  jsonResponse = processGetJourneyCriterionFields(userID, jsonRoot, tenantID);
                  break;

                case getJourneyCriterionFieldIDs:
                  jsonResponse = processGetJourneyCriterionFieldIDs(userID, jsonRoot, tenantID);
                  break;

                case getJourneyCriterionField:
                  jsonResponse = processGetJourneyCriterionField(userID, jsonRoot, tenantID);
                  break;
                  
                case getJourneyTriggerTargetingCriterionFields:
                  jsonResponse = processGetJourneyTriggerTargetingCriterionFields(userID, jsonRoot, tenantID);
                  break;

                case getOfferProperties:
                  jsonResponse = processGetOfferProperties(userID, jsonRoot, tenantID);
                  break;

                case getScoringEngines:
                  jsonResponse = processGetScoringEngines(userID, jsonRoot, tenantID);
                  break;

                case getOfferOptimizationAlgorithms:
                  jsonResponse = processGetOfferOptimizationAlgorithms(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case getNodeTypes:
                  jsonResponse = processGetNodeTypes(userID, jsonRoot, tenantID);
                  break;

                case getJourneyToolbox:
                  jsonResponse = processGetJourneyToolbox(userID, jsonRoot, tenantID);
                  break;

                case getJourneyList:
                  jsonResponse = processGetJourneyList(userID, jsonRoot, GUIManagedObjectType.Journey, true, true, includeArchived, tenantID);
                  break;

                case getJourneySummaryList:
                  jsonResponse = processGetJourneyList(userID, jsonRoot, GUIManagedObjectType.Journey, false, true, includeArchived, tenantID);
                  break;

                case getJourney:
                  jsonResponse = processGetJourney(userID, jsonRoot, GUIManagedObjectType.Journey, true, includeArchived, tenantID);
                  break;

                case putJourney:
                  jsonResponse = processPutJourney(userID, jsonRoot, GUIManagedObjectType.Journey, tenantID);
                  break;

                case removeJourney:
                  jsonResponse = processRemoveJourney(userID, jsonRoot, GUIManagedObjectType.Journey, tenantID);
                  break;
                  
                case updateJourney:
                  jsonResponse = processUpdateJourney(userID, jsonRoot, GUIManagedObjectType.Journey, tenantID);
                  break;

                case setStatusJourney:
                  jsonResponse = processSetStatusJourney(userID, jsonRoot, GUIManagedObjectType.Journey, tenantID);
                  break;

                case startJourney:
                  jsonResponse = processSetActive(userID, jsonRoot, GUIManagedObjectType.Journey, true, tenantID);
                  break;

                case stopJourney:
                  jsonResponse = processSetActive(userID, jsonRoot, GUIManagedObjectType.Journey, false, tenantID);
                  break;

                case getCampaignToolbox:
                  jsonResponse = processGetCampaignToolbox(userID, jsonRoot, tenantID);
                  break;

                case getCampaignList:
                  jsonResponse = processGetJourneyList(userID, jsonRoot, GUIManagedObjectType.Campaign, true, true, includeArchived, tenantID);
                  break;

                case getCampaignSummaryList:
                  jsonResponse = processGetJourneyList(userID, jsonRoot, GUIManagedObjectType.Campaign, false, true, includeArchived, tenantID);
                  break;

                case getCampaign:
                  jsonResponse = processGetJourney(userID, jsonRoot, GUIManagedObjectType.Campaign, true, includeArchived, tenantID);
                  break;

                case putCampaign:
                  jsonResponse = processPutJourney(userID, jsonRoot, GUIManagedObjectType.Campaign, tenantID);
                  break;

                case removeCampaign:
                  jsonResponse = processRemoveJourney(userID, jsonRoot, GUIManagedObjectType.Campaign, tenantID);
                  break;
                  
                case updateCampaign:
                  jsonResponse = processUpdateJourney(userID, jsonRoot, GUIManagedObjectType.Campaign, tenantID);
                  break;


                case setStatusCampaign:
                  jsonResponse = processSetStatusJourney(userID, jsonRoot, GUIManagedObjectType.Campaign, tenantID);
                  break;

                case startCampaign:
                  jsonResponse = processSetActive(userID, jsonRoot, GUIManagedObjectType.Campaign, true, tenantID);
                  break;

                case stopCampaign:
                  jsonResponse = processSetActive(userID, jsonRoot, GUIManagedObjectType.Campaign, false, tenantID);
                  break;

                case getWorkflowToolbox:
                  jsonResponse = processGetWorkflowToolbox(userID, jsonRoot, tenantID);
                  break;

                case getWorkflowList:
                  jsonResponse = processGetJourneyList(userID, jsonRoot, GUIManagedObjectType.Workflow, true, true, includeArchived, tenantID);
                  break;

                case getFullWorkflowList:
                  jsonResponse = processGetJourneyList(userID, jsonRoot, GUIManagedObjectType.Workflow, true, false, includeArchived, tenantID);
                  break;

                case getWorkflowSummaryList:
                  jsonResponse = processGetJourneyList(userID, jsonRoot, GUIManagedObjectType.Workflow, false, true, includeArchived, tenantID);
                  break;

                case getWorkflow:
                  jsonResponse = processGetJourney(userID, jsonRoot, GUIManagedObjectType.Workflow, true, includeArchived, tenantID);
                  break;

                case putWorkflow:
                  jsonResponse = processPutJourney(userID, jsonRoot, GUIManagedObjectType.Workflow, tenantID);
                  break;

                case removeWorkflow:
                  jsonResponse = processRemoveJourney(userID, jsonRoot, GUIManagedObjectType.Workflow, tenantID);
                  break;
                  
                case updateWorkflow:
                  jsonResponse = processUpdateJourney(userID, jsonRoot, GUIManagedObjectType.Workflow, tenantID);
                  break;

                case setStatusWorkflow:
                  jsonResponse = processSetStatusJourney(userID, jsonRoot, GUIManagedObjectType.Workflow, tenantID);
                  break;                  
               
                  
                case getLoyaltyWorkflowToolbox:
                  jsonResponse = processGetLoyaltyWorkflowToolbox(userID, jsonRoot, tenantID);
                  break;
                  
                case getBulkCampaignList:
                  jsonResponse = processGetJourneyList(userID, jsonRoot, GUIManagedObjectType.BulkCampaign, true, true, includeArchived, tenantID);
                  break;                  
           
                case getBulkCampaignSummaryList:
                  jsonResponse = processGetJourneyList(userID, jsonRoot, GUIManagedObjectType.BulkCampaign, false, true, includeArchived, tenantID);
                  break;

                case getBulkCampaign:
                  jsonResponse = processGetJourney(userID, jsonRoot, GUIManagedObjectType.BulkCampaign, true, includeArchived, tenantID);
                  break;

                case getBulkCampaignCapacity:
                  jsonResponse = processGetBulkCampaignCapacity(userID, jsonRoot, tenantID);
                  break;

                case putBulkCampaign:
                  jsonResponse = processPutBulkCampaign(userID, jsonRoot, tenantID);
                  break;

                case removeBulkCampaign:
                  jsonResponse = processRemoveJourney(userID, jsonRoot, GUIManagedObjectType.BulkCampaign, tenantID);
                  break;
                  
                case updateBulkCampaign:
                  jsonResponse = processUpdateBulkCampaign(userID, jsonRoot, tenantID);
                  break;

                case setStatusBulkCampaign:
                  jsonResponse = processSetStatusJourney(userID, jsonRoot, GUIManagedObjectType.BulkCampaign, tenantID);
                  break;

                case startBulkCampaign:
                  jsonResponse = processSetActive(userID, jsonRoot, GUIManagedObjectType.BulkCampaign, true, tenantID);
                  break;

                case stopBulkCampaign:
                  jsonResponse = processSetActive(userID, jsonRoot, GUIManagedObjectType.BulkCampaign, false, tenantID);
                  break;

                case getJourneyTemplateList:
                  jsonResponse = processGetJourneyTemplateList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getJourneyTemplateSummaryList:
                  jsonResponse = processGetJourneyTemplateList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getJourneyTemplate:
                  jsonResponse = processGetJourneyTemplate(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putJourneyTemplate:
                  jsonResponse = processPutJourneyTemplate(userID, jsonRoot, tenantID);
                  break;

                case removeJourneyTemplate:
                  jsonResponse = processRemoveJourneyTemplate(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusJourneyTemplate:
                  jsonResponse = processSetStatusJourneyTemplate(userID, jsonRoot, tenantID);
                  break;

                case getJourneyNodeCount:
                  jsonResponse = processGetJourneyNodeCount(userID, jsonRoot, tenantID);
                  break;
                  
                case getSegmentationDimensionList:
                  jsonResponse = guiManagerBaseManagement.processGetSegmentationDimensionList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getSegmentationDimensionSummaryList:
                  jsonResponse = guiManagerBaseManagement.processGetSegmentationDimensionList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getSegmentationDimension:
                  jsonResponse = guiManagerBaseManagement.processGetSegmentationDimension(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putSegmentationDimension:
                  jsonResponse = guiManagerBaseManagement.processPutSegmentationDimension(userID, jsonRoot, tenantID);
                  break;

                case removeSegmentationDimension:
                  jsonResponse = guiManagerBaseManagement.processRemoveSegmentationDimension(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusSegmentationDimension:
                  jsonResponse = guiManagerBaseManagement.processSetStatusSegmentationDimension(userID, jsonRoot, tenantID);
                  break;

                case getCountBySegmentationRanges:
                  jsonResponse = guiManagerGeneral.processGetCountBySegmentationRanges(userID, jsonRoot, tenantID);
                  break;

                case getCountBySegmentationRangesBySegmentID:
                  jsonResponse = guiManagerGeneral.processGetCountBySegmentationRangesBySegmentId(userID, jsonRoot, tenantID);
                  break;

                case getCountBySegmentationEligibility:
                  jsonResponse = guiManagerGeneral.processGetCountBySegmentationEligibility(userID, jsonRoot, tenantID);
                  break;

                case evaluateProfileCriteria:
                  jsonResponse = guiManagerGeneral.processEvaluateProfileCriteria(userID, jsonRoot, tenantID);
                  break;

                case getUCGDimensionSummaryList:
                  jsonResponse = guiManagerBaseManagement.processGetUCGDimensionList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getPointList:
                  jsonResponse = guiManagerGeneral.processGetPointList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getPointSummaryList:
                  jsonResponse = guiManagerGeneral.processGetPointList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getPoint:
                  jsonResponse = guiManagerGeneral.processGetPoint(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putPoint:
                  jsonResponse = guiManagerGeneral.processPutPoint(userID, jsonRoot, tenantID);
                  break;

                case removePoint:
                  jsonResponse = guiManagerGeneral.processRemovePoint(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusPoint:
                  jsonResponse = guiManagerGeneral.processSetStatusPoint(userID, jsonRoot, tenantID);
                  break;

                case getComplexObjectTypeList:
                  jsonResponse = guiManagerGeneral.processGetComplexObjectTypeList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getComplexObjectTypeSummaryList:
                  jsonResponse = guiManagerGeneral.processGetComplexObjectTypeList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getComplexObjectType:
                  jsonResponse = guiManagerGeneral.processGetComplexObjectType(userID, jsonRoot, includeArchived);
                  break;

                case putComplexObjectType:
                  jsonResponse = guiManagerGeneral.processPutComplexObjectType(userID, jsonRoot, tenantID);
                  break;

                case removeComplexObjectType:
                  jsonResponse = guiManagerGeneral.processRemoveComplexObjectType(userID, jsonRoot, tenantID);
                  break;

                case getOfferList:
                  jsonResponse = processGetOfferList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getOfferSummaryList:
                  jsonResponse = processGetOfferList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getOffer:
                  jsonResponse = processGetOffer(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putOffer:
                  jsonResponse = processPutOffer(userID, jsonRoot, tenantID);
                  break;

                case removeOffer:
                  jsonResponse = processRemoveOffer(userID, jsonRoot, tenantID);
                  break;
                  
                case updateOffer:
                  jsonResponse = processUpdateOffer(userID, jsonRoot, tenantID);
                  break;

                case setStatusOffer:
                  jsonResponse = processSetStatusOffer(userID, jsonRoot, tenantID);
                  break;

                case getReportGlobalConfiguration:
                  jsonResponse = guiManagerLoyaltyReporting.processGetReportGlobalConfiguration(userID, jsonRoot, tenantID);
                  break;

                case getReportList:
                  jsonResponse = guiManagerLoyaltyReporting.processGetReportList(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putReport:
                  jsonResponse = guiManagerLoyaltyReporting.processPutReport(userID, jsonRoot, tenantID);
                  break;

                case launchReport:
                  jsonResponse = guiManagerLoyaltyReporting.processLaunchReport(userID, jsonRoot, tenantID);
                  break;

                case getPresentationStrategyList:
                  jsonResponse = processGetPresentationStrategyList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getPresentationStrategySummaryList:
                  jsonResponse = processGetPresentationStrategyList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getPresentationStrategy:
                  jsonResponse = processGetPresentationStrategy(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putPresentationStrategy:
                  jsonResponse = processPutPresentationStrategy(userID, jsonRoot, tenantID);
                  break;

                case removePresentationStrategy:
                  jsonResponse = processRemovePresentationStrategy(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusPresentationStrategy:
                  jsonResponse = processSetStatusPresentationStrategy(userID, jsonRoot, tenantID);
                  break;

                case getDNBOMatrixList:
                  jsonResponse = processGetDNBOMatrixList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getDNBOMatrixSummaryList:
                  jsonResponse = processGetDNBOMatrixList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getDNBOMatrix:
                  jsonResponse = processGetDNBOMatrix(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putDNBOMatrix:
                  jsonResponse = processPutDNBOMatrix(userID, jsonRoot, tenantID);
                  break;

                case removeDNBOMatrix:
                  jsonResponse = processRemoveDNBOMatrix(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusDNBOMatrix:
                  jsonResponse = processSetStatusDNBOMatrix(userID, jsonRoot, tenantID);
                  break;
                  
                case getScoringTypesList:
                  jsonResponse = processGetScoringTypesList(userID, jsonRoot, tenantID);
                  break;
                  
                case getDNBOMatrixVariablesList:
                  jsonResponse = processGetDNBOMatrixVariablesList(userID, jsonRoot, tenantID);
                  break;
                  
                case getScoringStrategyList:
                  jsonResponse = processGetScoringStrategyList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getScoringStrategySummaryList:
                  jsonResponse = processGetScoringStrategyList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getScoringStrategy:
                  jsonResponse = processGetScoringStrategy(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putScoringStrategy:
                  jsonResponse = processPutScoringStrategy(userID, jsonRoot, tenantID);
                  break;

                case removeScoringStrategy:
                  jsonResponse = processRemoveScoringStrategy(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusScoringStrategy:
                  jsonResponse = processSetStatusScoringStrategy(userID, jsonRoot, tenantID);
                  break;

                case getCallingChannelList:
                  jsonResponse = processGetCallingChannelList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getCallingChannelSummaryList:
                  jsonResponse = processGetCallingChannelList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getCallingChannel:
                  jsonResponse = processGetCallingChannel(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putCallingChannel:
                  jsonResponse = processPutCallingChannel(userID, jsonRoot, tenantID);
                  break;

                case removeCallingChannel:
                  jsonResponse = processRemoveCallingChannel(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusCallingChannel:
                  jsonResponse = processSetStatusCallingChannel(userID, jsonRoot, tenantID);
                  break;

                case getSalesChannelList:
                  jsonResponse = processGetSalesChannelList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getSalesChannelSummaryList:
                  jsonResponse = processGetSalesChannelList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getSalesChannel:
                  jsonResponse = processGetSalesChannel(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putSalesChannel:
                  jsonResponse = processPutSalesChannel(userID, jsonRoot, tenantID);
                  break;

                case removeSalesChannel:
                  jsonResponse = processRemoveSalesChannel(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusSalesChannel:
                  jsonResponse = processSetStatusSalesChannel(userID, jsonRoot, tenantID);
                  break;

                case getSupplierList:
                  jsonResponse = processGetSupplierList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getSupplierSummaryList:
                  jsonResponse = processGetSupplierList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getSupplier:
                  jsonResponse = processGetSupplier(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putSupplier:
                  jsonResponse = processPutSupplier(userID, jsonRoot, tenantID);
                  break;

                case removeSupplier:
                  jsonResponse = processRemoveSupplier(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusSupplier:
                  jsonResponse = processSetStatusSupplier(userID, jsonRoot, tenantID);
                  break;

                case getProductList:
                  jsonResponse = processGetProductList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getProductSummaryList:
                  jsonResponse = processGetProductList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getProduct:
                  jsonResponse = processGetProduct(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putProduct:
                  jsonResponse = processPutProduct(userID, jsonRoot, tenantID);
                  break;

                case updateProduct:
                  jsonResponse = processUpdateProduct(userID, jsonRoot, tenantID);
                  break;

                case removeProduct:
                  jsonResponse = processRemoveProduct(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusProduct:
                  jsonResponse = processSetStatusProduct(userID, jsonRoot, tenantID);
                  break;

                case getCatalogCharacteristicList:
                  jsonResponse = guiManagerGeneral.processGetCatalogCharacteristicList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getCatalogCharacteristicSummaryList:
                  jsonResponse = guiManagerGeneral.processGetCatalogCharacteristicList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getCatalogCharacteristic:
                  jsonResponse = guiManagerGeneral.processGetCatalogCharacteristic(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putCatalogCharacteristic:
                  jsonResponse = guiManagerGeneral.processPutCatalogCharacteristic(userID, jsonRoot, tenantID);
                  break;

                case removeCatalogCharacteristic:
                  jsonResponse = guiManagerGeneral.processRemoveCatalogCharacteristic(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusCatalogCharacteristic:
                  jsonResponse = guiManagerGeneral.processSetStatusCatalogCharacteristic(userID, jsonRoot, tenantID);
                  break;

                case getContactPolicyList:
                  jsonResponse = processGetContactPolicyList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getContactPolicySummaryList:
                  jsonResponse = processGetContactPolicyList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getContactPolicy:
                  jsonResponse = processGetContactPolicy(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putContactPolicy:
                  jsonResponse = processPutContactPolicy(userID, jsonRoot, tenantID);
                  break;

                case removeContactPolicy:
                  jsonResponse = processRemoveContactPolicy(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusContactPolicy:
                  jsonResponse = processSetStatusContactPolicy(userID, jsonRoot, tenantID);
                  break;

                case getJourneyObjectiveList:
                  jsonResponse = processGetJourneyObjectiveList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getJourneyObjectiveSummaryList:
                  jsonResponse = processGetJourneyObjectiveList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getJourneyObjective:
                  jsonResponse = processGetJourneyObjective(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putJourneyObjective:
                  jsonResponse = processPutJourneyObjective(userID, jsonRoot, tenantID);
                  break;

                case removeJourneyObjective:
                  jsonResponse = processRemoveJourneyObjective(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusJourneyObjective:
                  jsonResponse = processSetStatusJourneyObjective(userID, jsonRoot, tenantID);
                  break;

                case getOfferObjectiveList:
                  jsonResponse = processGetOfferObjectiveList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getOfferObjectiveSummaryList:
                  jsonResponse = processGetOfferObjectiveList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getOfferObjective:
                  jsonResponse = processGetOfferObjective(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putOfferObjective:
                  jsonResponse = processPutOfferObjective(userID, jsonRoot, tenantID);
                  break;

                case removeOfferObjective:
                  jsonResponse = processRemoveOfferObjective(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusOfferObjective:
                  jsonResponse = processSetStatusOfferObjective(userID, jsonRoot, tenantID);
                  break;

                case getProductTypeList:
                  jsonResponse = processGetProductTypeList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getProductTypeSummaryList:
                  jsonResponse = processGetProductTypeList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getProductType:
                  jsonResponse = processGetProductType(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putProductType:
                  jsonResponse = processPutProductType(userID, jsonRoot, tenantID);
                  break;

                case removeProductType:
                  jsonResponse = processRemoveProductType(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusProductType:
                  jsonResponse = processSetStatusProductType(userID, jsonRoot, tenantID);
                  break;

                case getUCGRuleList:
                  jsonResponse = guiManagerBaseManagement.processGetUCGRuleList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getUCGRuleSummaryList:
                  jsonResponse = guiManagerBaseManagement.processGetUCGRuleList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getUCGRule:
                  jsonResponse = guiManagerBaseManagement.processGetUCGRule(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putUCGRule:
                  jsonResponse = guiManagerBaseManagement.processPutUCGRule(userID, jsonRoot, tenantID);
                  break;

                case removeUCGRule:
                  jsonResponse = guiManagerBaseManagement.processRemoveUCGRule(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusUCGRule:
                  jsonResponse = guiManagerBaseManagement.processSetStatusUCGRule(userID, jsonRoot, tenantID);
                  break;

                case getDeliverableList:
                  jsonResponse = processGetDeliverableList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getDeliverableSummaryList:
                  jsonResponse = processGetDeliverableList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getDeliverable:
                  jsonResponse = guiManagerGeneral.processGetDeliverable(userID, jsonRoot, includeArchived, tenantID);
                  break;
                  
                case putDeliverable:
                  jsonResponse = guiManagerGeneral.processPutDeliverable(userID, jsonRoot, tenantID);
                  break;
                  
                case removeDeliverable:
                  jsonResponse = guiManagerGeneral.processRemoveDeliverable(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusDeliverable:
                  jsonResponse = guiManagerGeneral.processSetStatusDeliverable(userID, jsonRoot, tenantID);
                  break;
                 
                case getDeliverableByName:
                  jsonResponse = guiManagerGeneral.processGetDeliverableByName(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case getTokenTypeList:
                  jsonResponse = guiManagerGeneral.processGetTokenTypeList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getTokenTypeSummaryList:
                  jsonResponse = guiManagerGeneral.processGetTokenTypeList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case putTokenType:
                  jsonResponse = guiManagerGeneral.processPutTokenType(userID, jsonRoot, tenantID);
                  break;

                case getTokenType:
                  jsonResponse = guiManagerGeneral.processGetTokenType(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case removeTokenType:
                  jsonResponse = guiManagerGeneral.processRemoveTokenType(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusTokenType:
                  jsonResponse = guiManagerGeneral.processSetStatusTokenType(userID, jsonRoot, tenantID);
                  break;

                case getTokenCodesFormats:
                  jsonResponse = guiManagerGeneral.processGetTokenCodesFormats(userID, jsonRoot, tenantID);
                  break;

                case getVoucherCodePatternList:
                  jsonResponse = guiManagerGeneral.processGetVoucherCodePatternList(userID, jsonRoot, tenantID);
                  break;
                  
                case generateVouchers:
                  jsonResponse = guiManagerGeneral.processGenerateVouchers(userID, jsonRoot, tenantID);
                  break;
                  
                case getVoucherTypeList:
                  jsonResponse = processGetVoucherTypeList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getVoucherTypeSummaryList:
                  jsonResponse = processGetVoucherTypeList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case putVoucherType:
                  jsonResponse = processPutVoucherType(userID, jsonRoot, tenantID);
                  break;

                case getVoucherType:
                  jsonResponse = processGetVoucherType(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case removeVoucherType:
                  jsonResponse = processRemoveVoucherType(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusVoucherType:
                  jsonResponse = processSetStatusVoucherType(userID, jsonRoot, tenantID);
                  break;

                case getVoucherCodeFormatList:
                  jsonResponse = processGetVoucherCodeFormatList(userID, jsonRoot, tenantID);
                  break;

                case getVoucherList:
                  jsonResponse = processGetVoucherList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getVoucherSummaryList:
                  jsonResponse = processGetVoucherList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case putVoucher:
                  jsonResponse = processPutVoucher(userID, jsonRoot, tenantID);
                  break;

                case getVoucher:
                  jsonResponse = processGetVoucher(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case removeVoucher:
                  jsonResponse = processRemoveVoucher(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusVoucher:
                  jsonResponse = processSetStatusVoucher(userID, jsonRoot, tenantID);
                  break;

                case redeemVoucher:
                  jsonResponse = processVoucherChange(userID, jsonRoot, VoucherChange.VoucherChangeAction.Redeem, tenantID);
                  break;

                case extendVoucherValidity:
                  jsonResponse = processVoucherChange(userID, jsonRoot, VoucherChange.VoucherChangeAction.Extend, tenantID);
                  break;

                case expireVoucher:
                  jsonResponse = processVoucherChange(userID, jsonRoot, VoucherChange.VoucherChangeAction.Expire, tenantID);
                  break;

                case getMailTemplateList:
                  jsonResponse = processGetMailTemplateList(userID, jsonRoot, true, true, includeArchived, tenantID);
                  break;

                case getFullMailTemplateList:
                  jsonResponse = processGetMailTemplateList(userID, jsonRoot, true, false, includeArchived, tenantID);
                  break;

                case getMailTemplateSummaryList:
                  jsonResponse = processGetMailTemplateList(userID, jsonRoot, false, true, includeArchived, tenantID);
                  break;

                case getMailTemplate:
                  jsonResponse = processGetMailTemplate(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putMailTemplate:
                  jsonResponse = processPutMailTemplate(userID, jsonRoot, tenantID);
                  break;

                case removeMailTemplate:
                  jsonResponse = processRemoveMailTemplate(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusMailTemplate:
                  jsonResponse = processSetStatusMailTemplate(userID, jsonRoot, tenantID);
                  break;

                case getSMSTemplateList:
                  jsonResponse = processGetSMSTemplateList(userID, jsonRoot, true, true, includeArchived, tenantID);
                  break;

                case getFullSMSTemplateList:
                  jsonResponse = processGetSMSTemplateList(userID, jsonRoot, true, false, includeArchived, tenantID);
                  break;

                case getSMSTemplateSummaryList:
                  jsonResponse = processGetSMSTemplateList(userID, jsonRoot, false, true, includeArchived, tenantID);
                  break;

                case getSMSTemplate:
                  jsonResponse = processGetSMSTemplate(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putSMSTemplate:
                  jsonResponse = processPutSMSTemplate(userID, jsonRoot, tenantID);
                  break;

                case removeSMSTemplate:
                  jsonResponse = processRemoveSMSTemplate(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusSMSTemplate:
                  jsonResponse = processSetStatusSMSTemplate(userID, jsonRoot, tenantID);
                  break;

                case getPushTemplateList:
                  jsonResponse = processGetPushTemplateList(userID, jsonRoot, true, true, includeArchived, tenantID);
                  break;

                case getFullPushTemplateList:
                  jsonResponse = processGetPushTemplateList(userID, jsonRoot, true, false, includeArchived, tenantID);
                  break;

                case getPushTemplateSummaryList:
                  jsonResponse = processGetPushTemplateList(userID, jsonRoot, false, true, includeArchived, tenantID);
                  break;

                case getPushTemplate:
                  jsonResponse = processGetPushTemplate(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putPushTemplate:
                  jsonResponse = processPutPushTemplate(userID, jsonRoot, tenantID);
                  break;

                case removePushTemplate:
                  jsonResponse = processRemovePushTemplate(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusPushTemplate:
                  jsonResponse = processSetStatusPushTemplate(userID, jsonRoot, tenantID);
                  break;
                  
                case getDialogTemplateList:
                  jsonResponse = processGetDialogTemplateList(userID, jsonRoot, true, true, includeArchived, tenantID);
                  break;

                case getFullDialogTemplateList:
                  jsonResponse = processGetDialogTemplateList(userID, jsonRoot, true, false, includeArchived, tenantID);
                  break;

                case getDialogTemplateSummaryList:
                  jsonResponse = processGetDialogTemplateList(userID, jsonRoot, false, true, includeArchived, tenantID);
                  break;

                case getDialogTemplate:
                  jsonResponse = processGetDialogTemplate(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putDialogTemplate:
                  jsonResponse = processPutDialogTemplate(userID, jsonRoot, tenantID);
                  break;

                case removeDialogTemplate:
                  jsonResponse = processRemoveDialogTemplate(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusDialogTemplate:
                  jsonResponse = processSetStatusDialogTemplate(userID, jsonRoot, tenantID);
                  break;

                case getFulfillmentProviders:
                  jsonResponse = processGetFulfillmentProviders(userID, jsonRoot, tenantID);
                  break;

                case getPaymentMeans:
                  jsonResponse = processGetPaymentMeanList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getPaymentMeanList:
                  jsonResponse = processGetPaymentMeanList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getPaymentMeanSummaryList:
                  jsonResponse = processGetPaymentMeanList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getPaymentMean:
                  jsonResponse = guiManagerGeneral.processGetPaymentMean(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putPaymentMean:
                  jsonResponse = guiManagerGeneral.processPutPaymentMean(userID, jsonRoot, tenantID);
                  break;

                case removePaymentMean:
                  jsonResponse = guiManagerGeneral.processRemovePaymentMean(userID, jsonRoot, tenantID);
                  break;

                case getDashboardCounts:
                  jsonResponse = guiManagerLoyaltyReporting.processGetDashboardCounts(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case getCustomer:
                  jsonResponse = processGetCustomer(userID, jsonRoot, tenantID);
                  break;

                case getCustomerMetaData:
                  jsonResponse = processGetCustomerMetaData(userID, jsonRoot, tenantID);
                  break;

                case getCustomerBDRs:
                  jsonResponse = processGetCustomerBDRs(userID, jsonRoot, tenantID);
                  break;
                  
                case getCustomerEDRs:
                  jsonResponse = processGetCustomerEDRs(userID, jsonRoot, tenantID);
                  break;

                case getCustomerODRs:
                  jsonResponse = processGetCustomerODRs(userID, jsonRoot, tenantID);
                  break;

                case getCustomerMessages:
                  jsonResponse = processGetCustomerMessages(userID, jsonRoot, tenantID);
                  break;

                case getCustomerJourneys:
                  jsonResponse = processGetCustomerJourneys(userID, jsonRoot, tenantID);
                  break;

                case getCustomerCampaigns:
                  jsonResponse = processGetCustomerCampaigns(userID, jsonRoot, tenantID);
                  break;

                case getCustomerPoints:
                  jsonResponse = processGetCustomerPoints(userID, jsonRoot, tenantID);
                  break;

                case getCustomerLoyaltyPrograms:
                  jsonResponse = processGetCustomerLoyaltyPrograms(userID, jsonRoot, tenantID);
                  break;

                case refreshUCG:
                  jsonResponse = guiManagerBaseManagement.processRefreshUCG(userID, jsonRoot, tenantID);
                  break;

                case getUploadedFileList:
                  jsonResponse = guiManagerGeneral.processGetFilesList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getUploadedFileSummaryList:
                  jsonResponse = guiManagerGeneral.processGetFilesList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case removeUploadedFile:
                  jsonResponse = guiManagerGeneral.processRemoveUploadedFile(userID, jsonRoot, tenantID);
                  break;

                case getCustomerAlternateIDs:
                  jsonResponse = processGetCustomerAlternateIDs(userID, jsonRoot, tenantID);
                  break;

                case getCustomerAvailableCampaigns:
                  jsonResponse = processGetCustomerAvailableCampaigns(userID, jsonRoot, tenantID);
                  break;

                case getTargetList:
                  jsonResponse = guiManagerBaseManagement.processGetTargetList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getTargetSummaryList:
                  jsonResponse = guiManagerBaseManagement.processGetTargetList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getTarget:
                  jsonResponse = guiManagerBaseManagement.processGetTarget(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putTarget:
                  jsonResponse = guiManagerBaseManagement.processPutTarget(userID, jsonRoot, tenantID);
                  break;

                case removeTarget:
                  jsonResponse = guiManagerBaseManagement.processRemoveTarget(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusTarget:
                  jsonResponse = guiManagerBaseManagement.processSetStatusTarget(userID, jsonRoot, tenantID);
                  break;

                case updateCustomer:
                  jsonResponse = processUpdateCustomer(userID, jsonRoot, tenantID);
                  break;

                case updateCustomerParent:
                  jsonResponse = processUpdateCustomerParent(userID, jsonRoot, tenantID);
                  break;

                case removeCustomerParent:
                  jsonResponse = processRemoveCustomerParent(userID, jsonRoot, tenantID);
                  break;
                  
                case getCommunicationChannelList:
                  jsonResponse = processGetCommunicationChannelList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getCommunicationChannelSummaryList:
                  jsonResponse = processGetCommunicationChannelList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getCommunicationChannel:
                  jsonResponse = processGetCommunicationChannel(userID, jsonRoot, includeArchived, tenantID);
                  break;
                  
                case putCommunicationChannel:
                  jsonResponse = processPutCommunicationChannel(userID, jsonRoot, tenantID);
                  break;


                case getBlackoutPeriodsList:
                  jsonResponse = processGetBlackoutPeriodsList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getBlackoutPeriodsSummaryList:
                  jsonResponse = processGetBlackoutPeriodsList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getBlackoutPeriods:
                  jsonResponse = processGetBlackoutPeriods(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putBlackoutPeriods:
                  jsonResponse = processPutBlackoutPeriods(userID, jsonRoot, tenantID);
                  break;

                case removeBlackoutPeriods:
                  jsonResponse = processRemoveBlackoutPeriods(userID, jsonRoot, tenantID);
                  break;
                  
                  
                  
                case getTimeWindowsList:
                  jsonResponse = CommunicationChannelTimeWindow.processGetChannelTimeWindowList(userID, jsonRoot, true, includeArchived, communicationChannelTimeWindowService, tenantID);
                  break;

                case getTimeWindowsSummaryList:
                  jsonResponse = CommunicationChannelTimeWindow.processGetChannelTimeWindowList(userID, jsonRoot, false, includeArchived, communicationChannelTimeWindowService, tenantID);
                  break;

                case getTimeWindows:
                  jsonResponse = CommunicationChannelTimeWindow.processGetTimeWindows(userID, jsonRoot, includeArchived, communicationChannelTimeWindowService);
                  break;

                case putTimeWindows:
                  jsonResponse = CommunicationChannelTimeWindow.processPutTimeWindows(userID, jsonRoot, communicationChannelTimeWindowService, epochServer, tenantID);
                  break;

                case removeTimeWindows:
                  jsonResponse = CommunicationChannelTimeWindow.processRemoveTimeWindows(userID, jsonRoot, communicationChannelTimeWindowService, tenantID);
                  break;

                case getLoyaltyProgramTypeList:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgramTypeList(userID, jsonRoot, tenantID);
                  break;

                case getLoyaltyProgramList:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgramList(userID, jsonRoot, LoyaltyProgramType.POINTS, true, includeArchived, tenantID);
                  break;
                  
                case getLoyaltyProgramChallengeList:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgramList(userID, jsonRoot, LoyaltyProgramType.CHALLENGE, true, includeArchived, tenantID);
                  break;
                  
                case getLoyaltyProgramMissionList:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgramList(userID, jsonRoot, LoyaltyProgramType.MISSION, true, includeArchived, tenantID);
                  break;

                case getLoyaltyProgramSummaryList:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgramList(userID, jsonRoot, LoyaltyProgramType.POINTS, false, includeArchived, tenantID);
                  break;
                  
                case getLoyaltyProgramChallengeSummaryList:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgramList(userID, jsonRoot, LoyaltyProgramType.CHALLENGE, false, includeArchived, tenantID);
                  break;
                  
                case getLoyaltyProgramMissionSummaryList:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgramList(userID, jsonRoot, LoyaltyProgramType.MISSION, false, includeArchived, tenantID);
                  break;

                case getLoyaltyProgram:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgram(userID, jsonRoot, LoyaltyProgramType.POINTS, includeArchived, tenantID);
                  break;
                  
                case getLoyaltyProgramChallenge:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgram(userID, jsonRoot, LoyaltyProgramType.CHALLENGE, includeArchived, tenantID);
                  break;
                  
                case getLoyaltyProgramMission:
                  jsonResponse = guiManagerLoyaltyReporting.processGetLoyaltyProgram(userID, jsonRoot, LoyaltyProgramType.MISSION, includeArchived, tenantID);
                  break;

                case putLoyaltyProgram:
                  jsonResponse = guiManagerLoyaltyReporting.processPutLoyaltyProgram(userID, jsonRoot, LoyaltyProgramType.POINTS, tenantID);
                  break;
                  
                case putLoyaltyProgramChallenge:
                  jsonResponse = guiManagerLoyaltyReporting.processPutLoyaltyProgram(userID, jsonRoot, LoyaltyProgramType.CHALLENGE, tenantID);
                  break;
                  
                case putLoyaltyProgramMission:
                  jsonResponse = guiManagerLoyaltyReporting.processPutLoyaltyProgram(userID, jsonRoot, LoyaltyProgramType.MISSION, tenantID);
                  break;
                  
                case updateMission:
                  jsonResponse = guiManagerLoyaltyReporting.processUpdateLoyalty(userID, jsonRoot, LoyaltyProgramType.MISSION, tenantID);
                  break;
                  
                case updateChallenge:
                  jsonResponse = guiManagerLoyaltyReporting.processUpdateLoyalty(userID, jsonRoot, LoyaltyProgramType.CHALLENGE, tenantID);
                  break;

                case removeLoyaltyProgram:
                  jsonResponse = guiManagerLoyaltyReporting.processRemoveLoyaltyProgram(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusLoyaltyProgram:
                  jsonResponse = guiManagerLoyaltyReporting.processSetStatusLoyaltyProgram(userID, jsonRoot, tenantID);
                  break;
                  
                case getResellerList:
                  jsonResponse = processGetResellerList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getResellerSummaryList:
                  jsonResponse = processGetResellerList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getReseller:
                  jsonResponse = processGetReseller(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putReseller:
                  jsonResponse = processPutReseller(userID, jsonRoot, tenantID);
                  break;

                case removeReseller:
                  jsonResponse = processRemoveReseller(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusReseller:
                  jsonResponse = processSetStatusReseller(userID, jsonRoot, tenantID);
                  break;  

                case enterCampaign:
                  jsonResponse = processEnterCampaign(userID, jsonRoot, tenantID);
                  break;
                  
                case creditBonus:
                  jsonResponse = processCreditBonus(userID, jsonRoot, tenantID);
                  break;
                  
                case debitBonus:
                  jsonResponse = processDebitBonus(userID, jsonRoot, tenantID);
                  break;
                  
                case getExclusionInclusionTargetList:  
                  jsonResponse = guiManagerBaseManagement.processGetExclusionInclusionTargetList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;
                  
                case getExclusionInclusionTargetSummaryList:
                  jsonResponse = guiManagerBaseManagement.processGetExclusionInclusionTargetList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;
                  
                case getExclusionInclusionTarget:
                  jsonResponse = guiManagerBaseManagement.processGetExclusionInclusionTarget(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putExclusionInclusionTarget:
                  jsonResponse = guiManagerBaseManagement.processPutExclusionInclusionTarget(userID, jsonRoot, tenantID);
                  break;
                  
                case removeExclusionInclusionTarget:
                  jsonResponse = guiManagerBaseManagement.processRemoveExclusionInclusionTarget(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusExclusionInclusionTarget:
                  jsonResponse = guiManagerBaseManagement.processSetStatusExclusionInclusionTarget(userID, jsonRoot, tenantID);
                  break;
                  
                case getSegmentContactPolicyList:  
                  jsonResponse = processGetSegmentContactPolicyList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;
                  
                case getSegmentContactPolicySummaryList:
                  jsonResponse = processGetSegmentContactPolicyList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getSegmentContactPolicy:
                  jsonResponse = processGetSegmentContactPolicy(userID, jsonRoot, includeArchived, tenantID);
                  break;
                  
                case putSegmentContactPolicy:
                  jsonResponse = processPutSegmentContactPolicy(userID, jsonRoot, tenantID);
                  break;
                  
                case removeSegmentContactPolicy:
                  jsonResponse = processRemoveSegmentContactPolicy(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusSegmentContactPolicy:
                  jsonResponse = processSetStatusSegmentContactPolicy(userID, jsonRoot, tenantID);
                  break;
                  
                case getBillingModes:
                  jsonResponse = guiManagerLoyaltyReporting.processGetBillingModes(userID, jsonRoot, tenantID);
                  break;

                case getPartnerTypes:
                  jsonResponse = guiManagerLoyaltyReporting.processGetPartnerTypes(userID, jsonRoot, tenantID);
                  break;

                case configAdaptorSupportedLanguages:
                  jsonResponse = guiManagerGeneral.processConfigAdaptorSupportedLanguages(jsonRoot, tenantID);
                  break;

                case configAdaptorSubscriberMessageTemplate:
                  jsonResponse = processConfigAdaptorSubscriberMessageTemplate(jsonRoot, tenantID);
                  break;

                case configAdaptorOffer:
                  jsonResponse = processConfigAdaptorOffer(jsonRoot, tenantID);
                  break;

                case configAdaptorProduct:
                  jsonResponse = processConfigAdaptorProduct(jsonRoot, tenantID);
                  break;

                case configAdaptorPresentationStrategy:
                  jsonResponse = processConfigAdaptorPresentationStrategy(jsonRoot, tenantID);
                  break;

                case configAdaptorScoringStrategy:
                  jsonResponse = processConfigAdaptorScoringStrategy(jsonRoot, tenantID);
                  break;

                case configAdaptorCallingChannel:
                  jsonResponse = processConfigAdaptorCallingChannel(jsonRoot, tenantID);
                  break;

                case configAdaptorSalesChannel:
                  jsonResponse = processConfigAdaptorSalesChannel(jsonRoot, tenantID);
                  break;

                case configAdaptorCommunicationChannel:
                  jsonResponse = processConfigAdaptorCommunicationChannel(jsonRoot, tenantID);
                  break;

                case configAdaptorBlackoutPeriods:
                  jsonResponse = processConfigAdaptorBlackoutPeriods(jsonRoot, tenantID);
                  break;

                case configAdaptorContactPolicy:
                  jsonResponse = processConfigAdaptorContactPolicy(jsonRoot, tenantID);
                  break;
                  
                case configAdaptorSegmentationDimension:
                  jsonResponse = guiManagerBaseManagement.processConfigAdaptorSegmentationDimension(jsonRoot, tenantID);
                  break;

                case configAdaptorCampaign:
                  jsonResponse = processConfigAdaptorCampaign(jsonRoot, tenantID);
                  break;

                case configAdaptorJourneyObjective:
                  jsonResponse = processConfigAdaptorJourneyObjective(jsonRoot, tenantID);
                  break;

                case configAdaptorProductType:
                  jsonResponse = processConfigAdaptorProductType(jsonRoot, tenantID);
                  break;

                case configAdaptorOfferObjective:
                  jsonResponse = processConfigAdaptorOfferObjective(jsonRoot, tenantID);
                  break;

                case configAdaptorScoringEngines:
                  jsonResponse = processConfigAdaptorScoringEngines(jsonRoot, tenantID);
                  break;

                case configAdaptorPresentationCriterionFields:
                  jsonResponse = processConfigAdaptorPresentationCriterionFields(jsonRoot, tenantID);
                  break;

                case configAdaptorDefaultNoftificationDailyWindows:
                  jsonResponse = processConfigAdaptorDefaultNoftificationDailyWindows(jsonRoot, tenantID);
                  break;

                case configAdaptorDeliverable:
                  jsonResponse = processConfigAdaptorDeliverable(jsonRoot, tenantID);
                  break;

                case configAdaptorSourceAddress:
                  jsonResponse = processConfigAdaptorSourceAddress(jsonRoot, tenantID);
                  break;

                case getCriterionFieldAvailableValuesList:
                  jsonResponse = processGetCriterionFieldAvailableValuesList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getCriterionFieldAvailableValuesSummaryList:
                  jsonResponse = processGetCriterionFieldAvailableValuesList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getCriterionFieldAvailableValues:
                  jsonResponse = processGetCriterionFieldAvailableValues(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putCriterionFieldAvailableValues:
                  jsonResponse = processPutCriterionFieldAvailableValues(userID, jsonRoot, tenantID);
                  break;

                case removeCriterionFieldAvailableValues:
                  jsonResponse = processRemoveCriterionFieldAvailableValues(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusCriterionFieldAvailableValues:
                  jsonResponse = processSetStatusCriterionFieldAvailableValues(userID, jsonRoot, tenantID);
                  break;

                case getEffectiveSystemTime:
                  jsonResponse = guiManagerGeneral.processGetEffectiveSystemTime(userID, jsonRoot, tenantID);
                  break;

                case getCustomerNBOs:
                  jsonResponse = processGetCustomerNBOs(userID, jsonRoot, tenantID);
                  break;

                case getTokensCodesList:
                  jsonResponse = processGetTokensCodesList(userID, jsonRoot, tenantID);
                  break;

                case acceptOffer:
                  jsonResponse = processAcceptOffer(userID, jsonRoot, tenantID);
                  break;

                case purchaseOffer:
                  jsonResponse = processPurchaseOffer(userID, jsonRoot, tenantID);
                  break;

                case getOffersList:
                  jsonResponse = processGetOffersList(userID, jsonRoot, tenantID);
                  break;

                case getTokenEventDetails:
                  jsonResponse = processGetTokenEventDetails(userID, jsonRoot, tenantID);
                  break;
                  
                case getSourceAddressList:
                  jsonResponse = processGetSourceAddressList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;

                case getSourceAddressSummaryList:
                  jsonResponse = processGetSourceAddressList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;

                case getSourceAddress:
                  jsonResponse = processGetSourceAddress(userID, jsonRoot, includeArchived, tenantID);
                  break;

                case putSourceAddress:
                  jsonResponse = processPutSourceAddress(userID, jsonRoot, tenantID);
                  break;

                case removeSourceAddress:
                  jsonResponse = processRemoveSourceAddress(userID, jsonRoot, tenantID);
                  break;
                  
                case setStatusSourceAddress:
                  jsonResponse = processSetStatusSourceAddress(userID, jsonRoot, tenantID);
                  break;

                case getTenantList:
                  jsonResponse = guiManagerGeneral.processGetTenantList(userID, jsonRoot, true, includeArchived);
                  break;
                  
                case putSimpleOfferThirdParty:
                  jsonResponse = processPutSimpleOfferThirdParty(userID, jsonRoot, tenantID);
                  break;
                  
                case getSimpleOfferListThirdParty:
                  jsonResponse = processGetSimpleOfferListThirdParty(userID, jsonRoot, tenantID);
                  break;
                  
                case removeSimpleOfferThirdParty:
                  jsonResponse = processRemoveSimpleOfferThirdParty(userID, jsonRoot, tenantID);
                  break;  
 
                case loyaltyProgramOptIn:
                  jsonResponse = guiManagerLoyaltyReporting.processLoyaltyProgramOptInOut(jsonRoot, true, tenantID);
                  break;
                  
                case loyaltyProgramOptOut:
                  jsonResponse = guiManagerLoyaltyReporting.processLoyaltyProgramOptInOut(jsonRoot, false, tenantID);
                  break;

                case getDependencies:
                  jsonResponse = guiManagerGeneral.processGetDependencies(userID, jsonRoot, tenantID);
                  break;
                  
                case putSimpleOffer:
                  jsonResponse = processPutSimpleOffer(userID, jsonRoot, tenantID);
                  break;
                  
                case getSimpleOffer:
                  jsonResponse = processGetSimpleOffer(userID, jsonRoot, includeArchived, tenantID);
                  break;
                  
                case getSimpleOfferList:
                  jsonResponse = processGetSimpleOfferList(userID, jsonRoot, true, includeArchived, tenantID);
                  break;
                  
                case getSimpleOfferSummaryList:
                  jsonResponse = processGetSimpleOfferList(userID, jsonRoot, false, includeArchived, tenantID);
                  break;
                  
                case removeSimpleOffer:
                  jsonResponse = processRemoveSimpleOffer(userID, jsonRoot, tenantID);
                  break;   


                case getSoftwareVersions:
                jsonResponse = processSoftwareVersions(userID, jsonRoot, 1); // for the moment, will see later
                break;

              }
          }
        else
          {
            jsonResponse = processFailedLicenseCheck(licenseState);
            log.warn("Failed license check {} ", licenseState);
          }

        //
        //  validate
        //

        if (jsonResponse == null)
          {
            throw new ServerException("no handler for " + api);
          }

        /*****************************************
        *
        *  send response
        *
        *****************************************/

        //
        //  standard response fields
        //

        jsonResponse.put("apiVersion", RESTAPIVersion);
        jsonResponse.put("licenseCheck", licenseAlarm.getJSONRepresentation());

        //
        //  log
        //

        log.debug("API (raw response): {}", jsonResponse.toString());

        //
        //  send
        //

        exchange.sendResponseHeaders(200, 0);
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(exchange.getResponseBody()));
        writer.write(jsonResponse.toString());
        writer.close();
        exchange.close();
      }
    catch (org.json.simple.parser.ParseException | GUIManagerException | IOException | ServerException | RuntimeException e )
      {
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.error("Exception processing REST api: {}", stackTraceWriter.toString().replace('\n', '\u2028'));

        //
        //  send error response
        //

        HashMap<String,Object> response = new HashMap<String,Object>();
        response.put("responseCode", "systemError");
        response.put("responseMessage", e.getMessage());
        JSONObject jsonResponse = JSONUtilities.encodeObject(response);
        exchange.sendResponseHeaders(200, 0);
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(exchange.getResponseBody()));
        writer.write(jsonResponse.toString());
        writer.close();
        exchange.close();
      }
  }

  /*****************************************
  *
  *  handleFileAPI
  *
  *****************************************/

  private synchronized void handleComplexAPI(API api, HttpExchange exchange) throws IOException
  {
    try
      {
        /*****************************************
        *
        *  get the user
        *
        *****************************************/

        String userID = null;
        if (exchange.getRequestURI().getQuery() != null)
          {
            Pattern pattern = Pattern.compile("^(.*\\&user_id|user_id)=(.*?)(\\&.*$|$)");
            Matcher matcher = pattern.matcher(exchange.getRequestURI().getQuery());
            if (matcher.matches())
              {
                userID = matcher.group(2);
              }
          }

        /*****************************************
        *
        *  get the body
        *
        *****************************************/

        JSONObject jsonRoot = null;
        switch (api)
          {
            case putUploadedFile:
            case putUploadedFileWithVariables:
              break;

            default:
              StringBuilder requestBodyStringBuilder = new StringBuilder();
              BufferedReader reader = new BufferedReader(new InputStreamReader(exchange.getRequestBody()));
              while (true)
                {
                  String line = reader.readLine();
                  if (line == null) break;
                  requestBodyStringBuilder.append(line);
                }
              reader.close();
              log.debug("API (raw request): {} {}",api,requestBodyStringBuilder.toString());
              jsonRoot = (JSONObject) (new JSONParser()).parse(requestBodyStringBuilder.toString());

              /*****************************************
              *
              *  validate
              *
              *****************************************/

              int apiVersion = JSONUtilities.decodeInteger(jsonRoot, "apiVersion", true);
              if (apiVersion > RESTAPIVersion)
                {
                  throw new ServerRuntimeException("unknown api version " + apiVersion);
                }
              jsonRoot.remove("apiVersion");

              /*****************************************
              *
              *  userID
              *
              *****************************************/

              String jsonUserID = JSONUtilities.decodeString(jsonRoot, "userID", false);
              if (jsonUserID == null && userID != null)
                {
                  jsonRoot.put("userID", userID);
                }

              /*****************************************
              *
              *  break
              *
              *****************************************/

              break;
          }
        

        /*****************************************
        *
        *  license state
        *
        *****************************************/

        LicenseState licenseState = licenseChecker.checkLicense();
        Alarm licenseAlarm = licenseState.getHighestAlarm();
        boolean allowAccess = true;
        switch (licenseAlarm.getLevel())
          {
            case None:
            case Alert:
            case Alarm:
              allowAccess = true;
              break;

            case Limit:
            case Block:
              allowAccess = false;
              break;
          }

        /*****************************************
        *
        *  process
        *
        *****************************************/

        //
        //  standard response fields
        //
        JSONObject jsonResponse = new JSONObject();
        jsonResponse.put("apiVersion", RESTAPIVersion);
        jsonResponse.put("licenseCheck", licenseAlarm.getJSONRepresentation());

        if (licenseState.isValid() && allowAccess)
          { 
            switch (api)
              {
                case putUploadedFile:
                  guiManagerGeneral.processPutFile(jsonResponse, exchange);
                  break;

                case putUploadedFileWithVariables:
                  guiManagerGeneral.processPutUploadedFileWithVariables(jsonResponse, exchange);
                  break;

                case downloadReport:
                  guiManagerLoyaltyReporting.processDownloadReport(userID, jsonRoot, jsonResponse, exchange);
                  break;
                  
                case downloadExtractFile:
                  guiManagerBaseManagement.processDownloadExtract(jsonRoot, jsonResponse, exchange); 
                  break;
                  
                case launchAndDownloadExtract:
                  guiManagerBaseManagement.processLaunchAndDownloadExtract(jsonRoot,jsonResponse,exchange);
                  break;

              }
          }
        else
          {
            log.warn("Failed license check {} ", licenseState);
            jsonResponse = processFailedLicenseCheck(licenseState);
            exchange.sendResponseHeaders(200, 0);
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(exchange.getResponseBody()));
            writer.write(jsonResponse.toString());
            writer.close();
            exchange.close();
          }

      }
    catch (org.json.simple.parser.ParseException | IOException | RuntimeException e )
      {
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.error("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  send error response
        //

        HashMap<String,Object> response = new HashMap<String,Object>();
        response.put("responseCode", "systemError");
        response.put("responseMessage", e.getMessage());
        JSONObject jsonResponse = JSONUtilities.encodeObject(response);
        exchange.sendResponseHeaders(200, 0);
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(exchange.getResponseBody()));
        writer.write(jsonResponse.toString());
        writer.close();
        exchange.close();
      }
  }

  /*****************************************
  *
  *  getIncludeDynamicParameter(jsonRoot)
  *
  *****************************************/

  private boolean getIncludeDynamicParameter(JSONObject jsonRoot)
  {
    return JSONUtilities.decodeBoolean(jsonRoot, "includeDynamic", Boolean.FALSE);
  }

  /*****************************************
  *
  *  processFailedLicenseCheck
  *
  *****************************************/

  private JSONObject processFailedLicenseCheck(LicenseState licenseState)
  {
    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "failedLicenseCheck");
    response.put("responseMessage", licenseState.getOutcome().name());
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getSupportedRelationships
  *
  *****************************************/

  private JSONObject processGetSupportedRelationships(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve supportedRelationships
    *
    *****************************************/

    List<JSONObject> supportedRelationships = new ArrayList<JSONObject>();
    for (SupportedRelationship supportedRelationship : Deployment.getDeployment(tenantID).getSupportedRelationships().values())
      {
        JSONObject supportedRelationshipJSON = supportedRelationship.getJSONRepresentation();
        supportedRelationships.add(supportedRelationshipJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("supportedRelationships", JSONUtilities.encodeArray(supportedRelationships));
    return JSONUtilities.encodeObject(response);
  }


  /*****************************************
  *
  *  getCallingChannelProperties
  *
  *****************************************/

  private JSONObject processGetCallingChannelProperties(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve callingChannelProperties
    *
    *****************************************/

    List<JSONObject> callingChannelProperties = new ArrayList<JSONObject>();
    for (CallingChannelProperty callingChannelProperty : Deployment.getDeployment(tenantID).getCallingChannelProperties().values())
      {
        JSONObject callingChannelPropertyJSON = callingChannelProperty.getJSONRepresentation();
        callingChannelProperties.add(callingChannelPropertyJSON);
      }

    /*****************************************et
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("callingChannelProperties", JSONUtilities.encodeArray(callingChannelProperties));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getSupportedTargetingTypes
  *
  *****************************************/

  private JSONObject processGetSupportedTargetingTypes(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve events
    *
    *****************************************/

    List<JSONObject> targetingTypes = new ArrayList<JSONObject>();
    for (TargetingType targetingType : TargetingType.values())
      {
        if (targetingType != TargetingType.Unknown)
          {
            JSONObject json = new JSONObject();
            json.put("id", targetingType.getExternalRepresentation());
            json.put("display", targetingType.getDisplay());
            targetingTypes.add(json);
          }
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("targetingTypes", JSONUtilities.encodeArray(targetingTypes));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getProfileCriterionFields
  *
  *****************************************/

  private JSONObject processGetProfileCriterionFields(String userID, JSONObject jsonRoot, CriterionContext profileContext, int tenantID)
  {
    /*****************************************
    *
    *  retrieve profile criterion fields
    *
    *****************************************/

    Map<String,List<JSONObject>> currentGroups = new HashMap<>();
    List<JSONObject> profileCriterionFields = processCriterionFields(profileContext.getCriterionFields(tenantID), false, currentGroups, tenantID);

    List<JSONObject> groups = new ArrayList<>();
    for (String id : currentGroups.keySet())
      {
        List<JSONObject> group = currentGroups.get(id);
        HashMap<String,Object> groupJSON = new HashMap<String,Object>();
        groupJSON.put("id", id);
        groupJSON.put("value", JSONUtilities.encodeArray(group));
        groups.add(JSONUtilities.encodeObject(groupJSON));
      }
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("profileCriterionFields", JSONUtilities.encodeArray(profileCriterionFields));
    response.put("groups", JSONUtilities.encodeArray(groups));
    return JSONUtilities.encodeObject(response);
  } 

  /*****************************************
  *
  *  getProfileCriterionFieldIDs
  *
  *****************************************/

  private JSONObject processGetProfileCriterionFieldIDs(String userID, JSONObject jsonRoot, CriterionContext profileContext, int tenantID)
  {
    /*****************************************
    *
    *  retrieve profile criterion fields
    *
    *****************************************/

    List<JSONObject> profileCriterionFields = processCriterionFields(profileContext.getCriterionFields(tenantID), false, tenantID);

    /*****************************************
    *
    *  strip out everything but id/display
    *
    *****************************************/

    List<JSONObject> profileCriterionFieldIDs = new ArrayList<JSONObject>();
    for (JSONObject profileCriterionField : profileCriterionFields)
      {
        HashMap<String,Object> profileCriterionFieldID = new HashMap<String,Object>();
        profileCriterionFieldID.put("id", profileCriterionField.get("id"));
        profileCriterionFieldID.put("display", profileCriterionField.get("display"));
        profileCriterionFieldIDs.add(JSONUtilities.encodeObject(profileCriterionFieldID));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("profileCriterionFieldIDs", JSONUtilities.encodeArray(profileCriterionFieldIDs));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getProfileCriterionField
  *
  *****************************************/

  private JSONObject processGetProfileCriterionField(String userID, JSONObject jsonRoot, CriterionContext profileContext, int tenantID)
  {
    /*****************************************
    *
    *  retrieve field id (setting it to null if blank)
    *
    *****************************************/

    String id = JSONUtilities.decodeString(jsonRoot, "id", true);
    id = (id != null && id.trim().length() == 0) ? null : id;

    /*****************************************
    *
    *  retrieve field with id
    *
    *****************************************/

    JSONObject requestedProfileCriterionField = null;
    if (id != null)
      {
        //
        //  retrieve profile criterion fields
        //

        List<JSONObject> profileCriterionFields = processCriterionFields(profileContext.getCriterionFields(tenantID), false, tenantID);

        //
        //  find requested field
        //

        for (JSONObject profileCriterionField : profileCriterionFields)
          {
            if (Objects.equals(id, profileCriterionField.get("id")))
              {
                requestedProfileCriterionField = profileCriterionField;
                break;
              }
          }
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    if (requestedProfileCriterionField != null)
      {
        response.put("responseCode", "ok");
        response.put("profileCriterionField", requestedProfileCriterionField);
      }
    else if (id == null)
      {
        response.put("responseCode", "invalidRequest");
        response.put("responseMessage", "id argument not provided");
      }
    else
      {
        response.put("responseCode", "fieldNotFound");
        response.put("responseMessage", "could not find profile criterion field with id " + id);
      }
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getPresentationCriterionFields
  *
  *****************************************/

  private JSONObject processGetPresentationCriterionFields(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve presentation criterion fields
    *
    *****************************************/

    Map<String,List<JSONObject>> currentGroups = new HashMap<>();
    List<JSONObject> presentationCriterionFields = processCriterionFields(CriterionContext.Presentation(tenantID).getCriterionFields(tenantID), false, currentGroups, tenantID);
    
    List<JSONObject> groups = new ArrayList<>();
    for (String id : currentGroups.keySet())
      {
        List<JSONObject> group = currentGroups.get(id);
        HashMap<String,Object> groupJSON = new HashMap<String,Object>();
        groupJSON.put("id", id);
        groupJSON.put("value", JSONUtilities.encodeArray(group));
        groups.add(JSONUtilities.encodeObject(groupJSON));
      }
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("presentationCriterionFields", JSONUtilities.encodeArray(presentationCriterionFields));
    response.put("groups", JSONUtilities.encodeArray(groups));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetPresentationCriterionFieldIDs
  *
  *****************************************/

  private JSONObject processGetPresentationCriterionFieldIDs(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve presentation criterion fields
    *
    *****************************************/

    List<JSONObject> presentationCriterionFields = processCriterionFields(CriterionContext.Presentation(tenantID).getCriterionFields(tenantID), false, tenantID);

    /*****************************************
    *
    *  strip out everything but id/display
    *
    *****************************************/

    List<JSONObject> presentationCriterionFieldIDs = new ArrayList<JSONObject>();
    for (JSONObject presentationCriterionField : presentationCriterionFields)
      {
        HashMap<String,Object> presentationCriterionFieldID = new HashMap<String,Object>();
        presentationCriterionFieldID.put("id", presentationCriterionField.get("id"));
        presentationCriterionFieldID.put("display", presentationCriterionField.get("display"));
        presentationCriterionFieldIDs.add(JSONUtilities.encodeObject(presentationCriterionFieldID));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("presentationCriterionFieldIDs", JSONUtilities.encodeArray(presentationCriterionFieldIDs));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getPresentationCriterionField
  *
  *****************************************/

  private JSONObject processGetPresentationCriterionField(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve field id (setting it to null if blank)
    *
    *****************************************/

    String id = JSONUtilities.decodeString(jsonRoot, "id", true);
    id = (id != null && id.trim().length() == 0) ? null : id;

    /*****************************************
    *
    *  retrieve field with id
    *
    *****************************************/

    JSONObject requestedPresentationCriterionField = null;
    if (id != null)
      {
        //
        //  retrieve presentation criterion fields
        //

        List<JSONObject> presentationCriterionFields = processCriterionFields(CriterionContext.Presentation(tenantID).getCriterionFields(tenantID), false, tenantID);

        //
        //  find requested field
        //

        for (JSONObject presentationCriterionField : presentationCriterionFields)
          {
            if (Objects.equals(id, presentationCriterionField.get("id")))
              {
                requestedPresentationCriterionField = presentationCriterionField;
                break;
              }
          }
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    if (requestedPresentationCriterionField != null)
      {
        response.put("responseCode", "ok");
        response.put("presentationCriterionField", requestedPresentationCriterionField);
      }
    else if (id == null)
      {
        response.put("responseCode", "invalidRequest");
        response.put("responseMessage", "id argument not provided");
      }
    else
      {
        response.put("responseCode", "fieldNotFound");
        response.put("responseMessage", "could not find presentation criterion field with id " + id);
      }
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getJourneyCriterionFields
  *
  *****************************************/

  private JSONObject processGetJourneyCriterionFields(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /*****************************************
    *
    *  arguments
    *
    *****************************************/

    Map<String,CriterionField> journeyParameters = Journey.decodeJourneyParameters(JSONUtilities.decodeJSONArray(jsonRoot,"journeyParameters", false));
    Map<String,GUINode> contextVariableNodes = Journey.decodeNodes(JSONUtilities.decodeJSONArray(jsonRoot,"contextVariableNodes", false), journeyParameters, Collections.<String,CriterionField>emptyMap(), true, journeyService, subscriberMessageTemplateService, dynamicEventDeclarationsService, tenantID);
    NodeType journeyNodeType = Deployment.getDeployment(tenantID).getNodeTypes().get(JSONUtilities.decodeString(jsonRoot, "nodeTypeID", true));
    EvolutionEngineEventDeclaration journeyNodeEvent = (JSONUtilities.decodeString(jsonRoot, "eventName", false) != null) ? dynamicEventDeclarationsService.getStaticAndDynamicEvolutionEventDeclarations().get(JSONUtilities.decodeString(jsonRoot, "eventName", true)) : null;
    Journey selectedJourney = (JSONUtilities.decodeString(jsonRoot, "selectedJourneyID", false) != null) ? journeyService.getActiveJourney(JSONUtilities.decodeString(jsonRoot, "selectedJourneyID", true), SystemTime.getCurrentTime()) : null;
    boolean tagsOnly = JSONUtilities.decodeBoolean(jsonRoot, "tagsOnly", Boolean.FALSE);
    boolean includeComparableFields = JSONUtilities.decodeBoolean(jsonRoot, "includeComparableFields", Boolean.TRUE); 
    String nodeTypeParameterID = JSONUtilities.decodeString(jsonRoot, "nodeTypeParameterID", false);
    JSONArray targetFileVariables = JSONUtilities.decodeJSONArray(jsonRoot, "targetFileVariables", new JSONArray());

    /*****************************************
    *
    *  retrieve journey criterion fields
    *
    *****************************************/
    HashMap<String,Object> response = new HashMap<String,Object>();

    List<JSONObject> journeyCriterionFields = Collections.<JSONObject>emptyList();
    List<JSONObject> groups = new ArrayList<>();
    CriterionDataType expectedDataType = null;
    
    if (nodeTypeParameterID != null)
      {
        Map<String, CriterionField> parameters = journeyNodeType.getParameters();
        if (parameters != null)
          {
            CriterionField criterionField = parameters.get(nodeTypeParameterID);
            if (criterionField == null)
              {
                response.put("responseCode", "invalidRequest");
                response.put("responseMessage", "could not find " + nodeTypeParameterID + " in nodeType with id " + JSONUtilities.decodeString(jsonRoot, "nodeTypeID", true));
                return JSONUtilities.encodeObject(response);
              }
            expectedDataType = criterionField.getFieldDataType();
          }
      }
    
    if (journeyNodeType != null)
      {
        CriterionContext criterionContext = new CriterionContext(journeyParameters, Journey.processContextVariableNodes(contextVariableNodes, journeyParameters, expectedDataType, targetFileVariables, tenantID), journeyNodeType, journeyNodeEvent, selectedJourney, expectedDataType, tenantID);
        Map<String,List<JSONObject>> currentGroups = includeComparableFields ? new HashMap<>() : null;
        Map<String, CriterionField> unprocessedCriterionFields = criterionContext.getCriterionFields(tenantID);
        journeyCriterionFields = processCriterionFields(unprocessedCriterionFields, tagsOnly, currentGroups, expectedDataType, tenantID);
        
        //
        //  intersect and put only Evaluation week Day and Time (if schedule node)
        //
        
        if (journeyNodeType.getScheduleNode()) journeyCriterionFields = journeyCriterionFields.stream().filter(criteriaFieldJSON -> IsJourneyScheduleNodeCriteria(criteriaFieldJSON)).collect(Collectors.toList());
        if (includeComparableFields)
          {
            for (String id : currentGroups.keySet())
              {
                List<JSONObject> group = currentGroups.get(id);
                HashMap<String,Object> groupJSON = new HashMap<String,Object>();
                groupJSON.put("id", id);
                groupJSON.put("value", JSONUtilities.encodeArray(group));
                groups.add(JSONUtilities.encodeObject(groupJSON));
              }
          }
      }
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    if (journeyNodeType != null)
      {
        response.put("responseCode", "ok");
        response.put("journeyCriterionFields", JSONUtilities.encodeArray(journeyCriterionFields));
        response.put("groups", JSONUtilities.encodeArray(groups));
      }
    else
      {
        response.put("responseCode", "invalidRequest");
        response.put("responseMessage", "could not find nodeType with id " + JSONUtilities.decodeString(jsonRoot, "nodeTypeID", true));
      }
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getJourneyCriterionFieldIDs
  *
  *****************************************/

  private JSONObject processGetJourneyCriterionFieldIDs(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /*****************************************
    *
    *  arguments
    *
    *****************************************/

    Map<String,CriterionField> journeyParameters = Journey.decodeJourneyParameters(JSONUtilities.decodeJSONArray(jsonRoot,"journeyParameters", false));
    Map<String,GUINode> contextVariableNodes = Journey.decodeNodes(JSONUtilities.decodeJSONArray(jsonRoot,"contextVariableNodes", false), journeyParameters, Collections.<String,CriterionField>emptyMap(), false, journeyService, subscriberMessageTemplateService, dynamicEventDeclarationsService, tenantID);
    NodeType journeyNodeType = Deployment.getDeployment(tenantID).getNodeTypes().get(JSONUtilities.decodeString(jsonRoot, "nodeTypeID", true));
    EvolutionEngineEventDeclaration journeyNodeEvent = (JSONUtilities.decodeString(jsonRoot, "eventName", false) != null) ? dynamicEventDeclarationsService.getStaticAndDynamicEvolutionEventDeclarations().get(JSONUtilities.decodeString(jsonRoot, "eventName", true)) : null;
    Journey selectedJourney = (JSONUtilities.decodeString(jsonRoot, "selectedJourneyID", false) != null) ? journeyService.getActiveJourney(JSONUtilities.decodeString(jsonRoot, "selectedJourneyID", true), SystemTime.getCurrentTime()) : null;
    boolean tagsOnly = JSONUtilities.decodeBoolean(jsonRoot, "tagsOnly", Boolean.FALSE);
    JSONArray targetFileVariables = JSONUtilities.decodeJSONArray(jsonRoot, "targetFileVariables", new JSONArray());

    /*****************************************
    *
    *  retrieve journey criterion fields
    *
    *****************************************/

    List<JSONObject> journeyCriterionFields = Collections.<JSONObject>emptyList();
    if (journeyNodeType != null)
      {
        CriterionContext criterionContext = new CriterionContext(journeyParameters, Journey.processContextVariableNodes(contextVariableNodes, journeyParameters, targetFileVariables, tenantID), journeyNodeType, journeyNodeEvent, selectedJourney, tenantID);
        Map<String, CriterionField> unprocessedCriterionFields = criterionContext.getCriterionFields(tenantID);
        journeyCriterionFields = processCriterionFields(unprocessedCriterionFields, tagsOnly, tenantID);
        if (journeyNodeType.getScheduleNode()) journeyCriterionFields = journeyCriterionFields.stream().filter(criteriaFieldJSON -> IsJourneyScheduleNodeCriteria(criteriaFieldJSON)).collect(Collectors.toList());
      }

    /*****************************************
    *
    *  strip out everything but id/display
    *
    *****************************************/

    List<JSONObject> journeyCriterionFieldIDs = new ArrayList<JSONObject>();
    for (JSONObject journeyCriterionField : journeyCriterionFields)
      {
        HashMap<String,Object> journeyCriterionFieldID = new HashMap<String,Object>();
        journeyCriterionFieldID.put("id", journeyCriterionField.get("id"));
        journeyCriterionFieldID.put("display", journeyCriterionField.get("display"));
        journeyCriterionFieldIDs.add(JSONUtilities.encodeObject(journeyCriterionFieldID));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    if (journeyNodeType != null)
      {
        response.put("responseCode", "ok");
        response.put("journeyCriterionFieldIDs", JSONUtilities.encodeArray(journeyCriterionFieldIDs));
      }
    else
      {
        response.put("responseCode", "invalidRequest");
        response.put("responseMessage", "could not find nodeType with id " + JSONUtilities.decodeString(jsonRoot, "nodeTypeID", true));
      }
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getJourneyCriterionField
  *
  *****************************************/

  private JSONObject processGetJourneyCriterionField(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /*****************************************
    *
    *  retrieve field id (setting it to null if blank)
    *
    *****************************************/

    Map<String,CriterionField> journeyParameters = Journey.decodeJourneyParameters(JSONUtilities.decodeJSONArray(jsonRoot,"journeyParameters", false));
    Map<String,GUINode> contextVariableNodes = Journey.decodeNodes(JSONUtilities.decodeJSONArray(jsonRoot,"contextVariableNodes", false), journeyParameters, Collections.<String,CriterionField>emptyMap(), false, journeyService, subscriberMessageTemplateService, dynamicEventDeclarationsService, tenantID);
    NodeType journeyNodeType = Deployment.getDeployment(tenantID).getNodeTypes().get(JSONUtilities.decodeString(jsonRoot, "nodeTypeID", true));
    EvolutionEngineEventDeclaration journeyNodeEvent = (JSONUtilities.decodeString(jsonRoot, "eventName", false) != null) ? dynamicEventDeclarationsService.getStaticAndDynamicEvolutionEventDeclarations().get(JSONUtilities.decodeString(jsonRoot, "eventName", true)) : null;
    Journey selectedJourney = (JSONUtilities.decodeString(jsonRoot, "selectedJourneyID", false) != null) ? journeyService.getActiveJourney(JSONUtilities.decodeString(jsonRoot, "selectedJourneyID", true), SystemTime.getCurrentTime()) : null;
    String id = JSONUtilities.decodeString(jsonRoot, "id", true);
    id = (id != null && id.trim().length() == 0) ? null : id;
    JSONArray targetFileVariables = JSONUtilities.decodeJSONArray(jsonRoot, "targetFileVariables", new JSONArray());

    /*****************************************
    *
    *  retrieve field with id
    *
    *****************************************/

    JSONObject requestedJourneyCriterionField = null;
    if (id != null)
      {
        /*****************************************
        *
        *  retrieve journey criterion fields
        *
        *****************************************/

        List<JSONObject> journeyCriterionFields = Collections.<JSONObject>emptyList();
        if (journeyNodeType != null)
          {
            CriterionContext criterionContext = new CriterionContext(journeyParameters, Journey.processContextVariableNodes(contextVariableNodes, journeyParameters, targetFileVariables, tenantID), journeyNodeType, journeyNodeEvent, selectedJourney, tenantID);
            Map<String, CriterionField> unprocessedCriterionFields = criterionContext.getCriterionFields(tenantID);
            journeyCriterionFields = processCriterionFields(unprocessedCriterionFields, false, tenantID);
            if (journeyNodeType.getScheduleNode()) journeyCriterionFields = journeyCriterionFields.stream().filter(criteriaFieldJSON -> IsJourneyScheduleNodeCriteria(criteriaFieldJSON)).collect(Collectors.toList());
          }

        /*****************************************
        *
        *  find requested field
        *
        *****************************************/

        for (JSONObject journeyCriterionField : journeyCriterionFields)
          {
            if (Objects.equals(id, journeyCriterionField.get("id")))
              {
                requestedJourneyCriterionField = journeyCriterionField;
                break;
              }
          }
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    if (requestedJourneyCriterionField != null)
      {
        response.put("responseCode", "ok");
        response.put("journeyCriterionField", requestedJourneyCriterionField);
      }
    else if (journeyNodeType == null)
      {
        response.put("responseCode", "invalidRequest");
        response.put("responseMessage", "could not find nodeType with id " + JSONUtilities.decodeString(jsonRoot, "nodeTypeID", true));
      }
    else if (id == null)
      {
        response.put("responseCode", "invalidRequest");
        response.put("responseMessage", "id argument not provided");
      }
    else
      {
        response.put("responseCode", "fieldNotFound");
        response.put("responseMessage", "could not find journey criterion field with id " + id);
      }
    return JSONUtilities.encodeObject(response);
  }
  
  
  /*****************************************
  *
  *  getJourneyCriterionFields
  *
  *****************************************/

  private JSONObject processGetJourneyTriggerTargetingCriterionFields(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /*****************************************
    *
    *  arguments
    *
    *****************************************/

    EvolutionEngineEventDeclaration targetingEvent = (JSONUtilities.decodeString(jsonRoot, "eventName", false) != null) ? dynamicEventDeclarationsService.getStaticAndDynamicEvolutionEventDeclarations().get(JSONUtilities.decodeString(jsonRoot, "eventName", true)) : null;
    boolean tagsOnly = JSONUtilities.decodeBoolean(jsonRoot, "tagsOnly", Boolean.FALSE);
    boolean includeComparableFields = JSONUtilities.decodeBoolean(jsonRoot, "includeComparableFields", Boolean.TRUE); 
    
    /*****************************************
    *
    *  retrieve journey criterion fields
    *
    *****************************************/
    HashMap<String,Object> response = new HashMap<String,Object>();

    List<JSONObject> journeyCriterionFields = Collections.<JSONObject>emptyList();
    List<JSONObject> groups = new ArrayList<>();
    CriterionDataType expectedDataType = null;
    
    CriterionContext criterionContext = new CriterionContext(new HashMap<String,CriterionField>(), new HashMap<String,CriterionField>(), null, targetingEvent, null, expectedDataType, tenantID);
    Map<String,List<JSONObject>> currentGroups = includeComparableFields ? new HashMap<>() : null;
    Map<String, CriterionField> unprocessedCriterionFields = criterionContext.getCriterionFields(tenantID);
    journeyCriterionFields = processCriterionFields(unprocessedCriterionFields, tagsOnly, currentGroups, tenantID);
        
    //
    //  intersect and put only Evaluation week Day and Time (if schedule node)
    //
        
    if (includeComparableFields)
      {
        for (String id : currentGroups.keySet())
          {
            List<JSONObject> group = currentGroups.get(id);
            HashMap<String,Object> groupJSON = new HashMap<String,Object>();
            groupJSON.put("id", id);
            groupJSON.put("value", JSONUtilities.encodeArray(group));
            groups.add(JSONUtilities.encodeObject(groupJSON));
          }
      }
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", "ok");
    response.put("journeyCriterionFields", JSONUtilities.encodeArray(journeyCriterionFields));
    response.put("groups", JSONUtilities.encodeArray(groups));

    return JSONUtilities.encodeObject(response);
  }

  


  /*****************************************
  *
  *  getOfferProperties
  *
  *****************************************/

  private JSONObject processGetOfferProperties(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve offerProperties
    *
    *****************************************/

    List<JSONObject> offerProperties = new ArrayList<JSONObject>();
    for (OfferProperty offerProperty : Deployment.getDeployment(tenantID).getOfferProperties().values())
      {
        JSONObject offerPropertyJSON = offerProperty.getJSONRepresentation();
        offerProperties.add(offerPropertyJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("offerProperties", JSONUtilities.encodeArray(offerProperties));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getScoringEngines
  *
  *****************************************/

  private JSONObject processGetScoringEngines(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve scoringEngines
    *
    *****************************************/

    List<JSONObject> scoringEngines = new ArrayList<JSONObject>();
    for (ScoringEngine scoringEngine : Deployment.getScoringEngines().values())
      {
        JSONObject scoringEngineJSON = scoringEngine.getJSONRepresentation();
        scoringEngines.add(scoringEngineJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("scoringEngines", JSONUtilities.encodeArray(scoringEngines));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getOfferOptimizationAlgorithms
  *
  *****************************************/

  private JSONObject processGetOfferOptimizationAlgorithms(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve offerOptimizationAlgorithms
    *
    *****************************************/

    List<JSONObject> offerOptimizationAlgorithms = new ArrayList<JSONObject>();
    for (OfferOptimizationAlgorithm offerOptimizationAlgorithm : Deployment.getOfferOptimizationAlgorithms().values())
    {
      if(!offerOptimizationAlgorithm.getID().equals("matrix-algorithm"))
      {
        JSONObject offerOptimizationAlgorithmJSON = offerOptimizationAlgorithm.getJSONRepresentation();
        offerOptimizationAlgorithms.add(offerOptimizationAlgorithmJSON);
      }
    }
    
    // Add DNBOMatrix Algorithm for gui
    Date now = SystemTime.getCurrentTime();
    for (GUIManagedObject dnboMatrix : dnboMatrixService.getStoredDNBOMatrixes(includeArchived, tenantID))
    {
      JSONObject matrixObject = presentationStrategyService.generateResponseJSON(dnboMatrix, false, now);
      matrixObject.replace("id", "DNBO" + JSONUtilities.decodeString(matrixObject, "id", true));
      offerOptimizationAlgorithms.add(matrixObject);
    }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("offerOptimizationAlgorithms", JSONUtilities.encodeArray(offerOptimizationAlgorithms));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetScoringTypesList
  *
  *****************************************/

  private JSONObject processGetScoringTypesList(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve offerOptimizationAlgorithms
    *
    *****************************************/

    List<JSONObject> scoringTypes = new ArrayList<JSONObject>();
    for (ScoringType scoringType : Deployment.getDeployment(tenantID).getScoringTypes().values())
      {
        JSONObject scoringTypeJSON = scoringType.getJSONRepresentation();
        scoringTypes.add(scoringTypeJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("scoringTypes", JSONUtilities.encodeArray(scoringTypes));
    return JSONUtilities.encodeObject(response);
  }

  
  /*****************************************
  *
  *  processGetDNBOMatrixVariablesList
  *
  *****************************************/

  private JSONObject processGetDNBOMatrixVariablesList(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve dnboMatrixVariables
    *
    *****************************************/

    List<JSONObject> dnboMatrixVariables = new ArrayList<JSONObject>();
    for (DNBOMatrixVariable dnboMatrixVariable : Deployment.getDeployment(tenantID).getDNBOMatrixVariables().values())
      {
        JSONObject dnboMatrixVariableJSON = dnboMatrixVariable.getJSONRepresentation();
        dnboMatrixVariables.add(dnboMatrixVariableJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("dnboMatrixVariables", JSONUtilities.encodeArray(dnboMatrixVariables));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getNodeTypes
  *
  *****************************************/

  private JSONObject processGetNodeTypes(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /*****************************************
    *
    *  arguments
    *
    *****************************************/

    Map<String,CriterionField> journeyParameters = Journey.decodeJourneyParameters(JSONUtilities.decodeJSONArray(jsonRoot,"journeyParameters", false));
    Map<String,GUINode> contextVariableNodes = Journey.decodeNodes(JSONUtilities.decodeJSONArray(jsonRoot,"contextVariableNodes", false), journeyParameters, Collections.<String,CriterionField>emptyMap(), false, journeyService, subscriberMessageTemplateService, dynamicEventDeclarationsService, tenantID);
    JSONArray targetFileVariables = JSONUtilities.decodeJSONArray(jsonRoot, "targetFileVariables", new JSONArray());
    Map<String,CriterionField> contextVariables = Journey.processContextVariableNodes(contextVariableNodes, journeyParameters, targetFileVariables, tenantID);

    /*****************************************
    *
    *  retrieve nodeTypes
    *
    *****************************************/

    List<JSONObject> nodeTypes = processNodeTypes(Deployment.getDeployment(tenantID).getNodeTypes(), journeyParameters, contextVariables, tenantID);

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("nodeTypes", JSONUtilities.encodeArray(nodeTypes));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getJourneyToolbox
  *
  *****************************************/

  private JSONObject processGetJourneyToolbox(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve journeyToolboxSections
    *
    *****************************************/

    List<JSONObject> journeyToolboxSections = new ArrayList<JSONObject>();
    for (ToolboxSection journeyToolboxSection : Deployment.getDeployment(tenantID).getJourneyToolbox().values())
      {
        JSONObject journeyToolboxSectionJSON = journeyToolboxSection.getJSONRepresentation();
        journeyToolboxSections.add(journeyToolboxSectionJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("journeyToolbox", JSONUtilities.encodeArray(journeyToolboxSections));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetJourneyList
  *
  *****************************************/

  private JSONObject processGetJourneyList(String userID, JSONObject jsonRoot, GUIManagedObjectType objectType, boolean fullDetails, boolean externalOnly, boolean includeArchived, int tenantID)
  {
    /*****************************************
     *
     * retrieve and convert journeys
     *
     *****************************************/

    String parentId  = JSONUtilities.decodeString(jsonRoot, "parentId", false);
    Date now = SystemTime.getCurrentTime();
    List<JSONObject> journeys = new ArrayList<JSONObject>();
    Collection<GUIManagedObject> journeyObjects = new ArrayList<GUIManagedObject>();
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray journeyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < journeyIDs.size(); i++)
          {
            String journeyID = journeyIDs.get(i).toString();
            GUIManagedObject journey = journeyService.getStoredJourney(journeyID, includeArchived);
            if (journey != null && journey.getTenantID() == tenantID)
              {
                journeyObjects.add(journey);
              }

          }
      } 
    else
      {
        journeyObjects = journeyService.getStoredJourneys(includeArchived, tenantID);
      }
    
    //
    //  filter to present recurrent campaigns and normal campaigns
    //
    switch (objectType)
    {
      case Campaign:
      case BulkCampaign:
        if (parentId != null && !parentId.isEmpty())
          {
            journeyObjects = journeyObjects.stream().filter(journey -> journeyService.isAChildJourney(journey)).collect(Collectors.toList());
            journeyObjects = journeyObjects.stream().filter(journey -> parentId.equals(JSONUtilities.decodeString(journeyService.getJSONRepresentation(journey), "recurrenceId", true))).collect(Collectors.toList());
          }
        else
          {
            journeyObjects = journeyObjects.stream().filter(journey -> !journeyService.isAChildJourney(journey)).collect(Collectors.toList());
          }
        break;
    }

    boolean showDeliveriesCount = false;
    if(objectType == GUIManagedObjectType.BulkCampaign) {
      showDeliveriesCount = true; // Only for Bulk Campaigns for the moment
    }
    
    for (GUIManagedObject journey : journeyObjects)
      {
        if (journey.getGUIManagedObjectType().equals(objectType) && (!externalOnly || !journey.getInternalOnly()))
          {
            JSONObject journeyInfo = journeyService.generateResponseJSON(journey, fullDetails, now);
            long subscriberCount = 0;
            JSONObject deliveriesCount = new JSONObject();
            String journeyID = journey.getGUIManagedObjectID();
            String journeyDisplay = journey.getGUIManagedObjectDisplay();

            //
            // retrieve from Elasticsearch 
            //
            try
              {
                // SubscriberCount
                Long count = this.elasticsearch.getJourneySubscriberCount(journeyID);
                count = (count != null) ? count : 0;
                count = count-this.elasticsearch.getSpecialExitCount(journeyID);
                subscriberCount = (count != null) ? count : 0;
                
                // DeliveriesCount 
                if(showDeliveriesCount) {
                  Map<String, Long> messages = this.elasticsearch.getJourneyMessagesCount(journeyDisplay, journey.getTenantID());
                  Map<String, Long> bonuses = this.elasticsearch.getJourneyBonusesCount(journeyDisplay, journey.getTenantID());
                  
                  long messagesSuccess = 0;
                  long messagesFailure = 0;
                  for(String key: messages.keySet()) {
                    if(key.equals(RESTAPIGenericReturnCodes.SUCCESS.getGenericResponseMessage())) {
                      messagesSuccess += messages.get(key);
                    } else {
                      messagesFailure += messages.get(key);
                    }
                  }
                  JSONObject messagesCount = new JSONObject();
                  messagesCount.put("success", messagesSuccess);
                  messagesCount.put("failure", messagesFailure);
                  
                  long bonusesSuccess = 0;
                  long bonusesFailure = 0;
                  for(String key: bonuses.keySet()) {
                    if(key.equals(RESTAPIGenericReturnCodes.SUCCESS.getGenericResponseMessage())) {
                      bonusesSuccess += bonuses.get(key);
                    } else {
                      bonusesFailure += bonuses.get(key);
                    }
                  }
                  JSONObject bonusesCount = new JSONObject();
                  bonusesCount.put("success", bonusesSuccess);
                  bonusesCount.put("failure", bonusesFailure);

                  deliveriesCount.put("messages", messagesCount);
                  deliveriesCount.put("bonuses", bonusesCount);
                  
                }
              } 
            catch (ElasticsearchClientException e)
              {
                log.warn("Exception processing REST api: {}", e);
              }
             
            journeyInfo.put("subscriberCount", subscriberCount);
            if(showDeliveriesCount) {
              journeyInfo.put("deliveriesCount", deliveriesCount);
            }
            journeys.add(journeyInfo);
          }
      }
    
    if (!fullDetails && objectType == GUIManagedObjectType.Workflow && jsonRoot.containsKey("areaAvailability"))
      {
        List<JSONObject> workflowsWithAreaAvailability = new ArrayList<JSONObject>();
        JSONArray areaAvailability = JSONUtilities.decodeJSONArray(jsonRoot, "areaAvailability", false);
        for (JSONObject journey : journeys)
          {
            JSONArray journeyAreaAvailability = (JSONArray) journey.get("areaAvailability");
            if (journeyAreaAvailability == null || journeyAreaAvailability.isEmpty())
              {
                workflowsWithAreaAvailability.add(journey);
              }
            else
              {
                for (int i = 0; i < journeyAreaAvailability.size(); i++)
                  {
                    if (areaAvailability.contains(journeyAreaAvailability.get(i)))
                      {
                        workflowsWithAreaAvailability.add(journey);
                        break;
                      }
                  }
              }
          }
        /*****************************************
         *
         * response
         *
         *****************************************/

        HashMap<String, Object> response = new HashMap<String, Object>();        
        response.put("responseCode", "ok");
        response.put("workflows", JSONUtilities.encodeArray(workflowsWithAreaAvailability));
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
     *
     * response
     *
     *****************************************/

    HashMap<String, Object> response = new HashMap<String, Object>();
    response.put("responseCode", "ok");
    switch (objectType)
    {
      case Journey:
        response.put("journeys", JSONUtilities.encodeArray(journeys));
        break;

      case Campaign:
        response.put("campaigns", JSONUtilities.encodeArray(journeys));
        break;

      case Workflow:
        response.put("workflows", JSONUtilities.encodeArray(journeys));
        break;

      case BulkCampaign:
        response.put("bulkCampaigns", JSONUtilities.encodeArray(journeys));
        break;

      default:
        response.put("journeys", JSONUtilities.encodeArray(journeys));
        break;
    }
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetJourney
  *
  *****************************************/

  private JSONObject processGetJourney(String userID, JSONObject jsonRoot, GUIManagedObjectType objectType, boolean externalOnly, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String journeyID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate campaign
    *
    *****************************************/

    GUIManagedObject journey = journeyService.getStoredJourney(journeyID, includeArchived);
    journey = (journey != null && journey.getGUIManagedObjectType() == objectType && (! externalOnly || ! journey.getInternalOnly())) ? journey : null;
    JSONObject journeyJSON = journeyService.generateResponseJSON(journey, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    switch (objectType)
      {
        case Journey:
          response.put("responseCode", (journey != null) ? "ok" : "journeyNotFound");
          if (journey != null) response.put("journey", journeyJSON);
          break;

        case Campaign:
          response.put("responseCode", (journey != null) ? "ok" : "campaignNotFound");
          if (journey != null) response.put("campaign", journeyJSON);
          break;

        case Workflow:
          response.put("responseCode", (journey != null) ? "ok" : "workflowNotFound");
          if (journey != null) response.put("workflow", journeyJSON);
          break;

        case BulkCampaign:
          response.put("responseCode", (journey != null) ? "ok" : "bulkCampaignNotFound");
          if (journey != null) response.put("bulkCampaign", journeyJSON);
          break;

        default:
          response.put("responseCode", (journey != null) ? "ok" : "notFound");
          if (journey != null) response.put("journey", journeyJSON);
          break;
      }
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutJourney
  *
  *****************************************/

  private JSONObject processPutJourney(String userID, JSONObject jsonRoot, GUIManagedObjectType objectType, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();    
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    *  journeyID
    *
    *****************************************/

    String journeyID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (journeyID == null)
      {
        journeyID = journeyService.generateJourneyID();
        jsonRoot.put("id", journeyID);
      }
    
    //
    // recurrence
    //
    
    boolean recurrence = JSONUtilities.decodeBoolean(jsonRoot, "recurrence", Boolean.FALSE);
    String recurrenceID = JSONUtilities.decodeString(jsonRoot, "recurrenceId", false);
    if (recurrence && recurrenceID == null) jsonRoot.put("recurrenceId", journeyID);
    if (recurrence && JSONUtilities.decodeInteger(jsonRoot, "lastCreatedOccurrenceNumber", false) == null) jsonRoot.put("lastCreatedOccurrenceNumber", 1);
    
    //
    // initial approval
    //
    
    JourneyStatus approval = JourneyStatus.Pending;

    /*****************************************
    *
    *  existing journey
    *
    *****************************************/

    GUIManagedObject existingJourney = journeyService.getStoredJourney(journeyID);
    existingJourney = (existingJourney != null && existingJourney.getGUIManagedObjectType() == objectType) ? existingJourney : null;

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingJourney != null && existingJourney.getReadOnly())
      {
        response.put("id", existingJourney.getGUIManagedObjectID());
        response.put("accepted", existingJourney.getAccepted());
        response.put("valid", existingJourney.getAccepted());
        response.put("processing", journeyService.isActiveJourney(existingJourney, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process journey
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        //
        // change approval if existingJourney
        //
        
        if (existingJourney != null && existingJourney.getAccepted())
          {
            approval = ((Journey) existingJourney).getApproval();
          }
        
        /****************************************
        *
        *  instantiate journey
        *
        ****************************************/

        Journey journey = new Journey(jsonRoot, objectType, epoch, existingJourney, journeyService, catalogCharacteristicService, subscriberMessageTemplateService, dynamicEventDeclarationsService, journeyTemplateService, approval, tenantID);
        if(GUIManagedObjectType.Workflow.equals(objectType)) {
          
             journey.setApproval(JourneyStatus.StartedApproved);
        }
        
        //
        // Update targetCount
        //
        journey.setTargetCount(elasticsearch, uploadedFileService, tenantID);
        
        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            journeyService.putJourney(journey, journeyObjectiveService, catalogCharacteristicService, targetService, subscriberMessageTemplateService, 
                (existingJourney == null), userID);

            /*****************************************
             *
             * handle related deliverable
             *
             *****************************************/

            if (GUIManagedObjectType.Campaign.equals(objectType))
              {
                DeliveryManagerDeclaration deliveryManager = Deployment.getDeliveryManagers().get("journeyFulfillment");
                JSONObject deliveryManagerJSON = (deliveryManager != null) ? deliveryManager.getJSONRepresentation()
                    : null;
                String providerID = (deliveryManagerJSON != null) ? (String) deliveryManagerJSON.get("providerID")
                    : null;
                if (providerID != null)
                  {
                    if (journey.getTargetingType().equals(TargetingType.Manual))
                      {

                        //
                        // create deliverable -- only if campaign has "manual
                        // provisioning"
                        //

                        Map<String, Object> deliverableMap = new HashMap<String, Object>();
                        deliverableMap.put("id", CommodityDeliveryManager.JOURNEY_PREFIX + journey.getJourneyID());
                        deliverableMap.put("fulfillmentProviderID", providerID);
                        deliverableMap.put("externalAccountID", journey.getJourneyID());
                        deliverableMap.put("name", journey.getJourneyName());
                        deliverableMap.put("display", journey.getJourneyName());
                        deliverableMap.put("active", true);
                        deliverableMap.put("unitaryCost", 0);
                        deliverableMap.put("label", "campaign");
                        Deliverable deliverable = new Deliverable(JSONUtilities.encodeObject(deliverableMap), epoch,
                            null, tenantID);
                        deliverableService.putDeliverable(deliverable, true, userID);
                      }
                    else
                      {

                        //
                        // delete deliverable -- only if campaign does NOT have
                        // "manual provisioning"
                        //

                        // TODO SCH : may need to check that deliverable is not
                        // used in any offer

                        for (GUIManagedObject deliverableObject : deliverableService.getStoredDeliverables(tenantID))
                          {
                            Deliverable deliverable = (Deliverable) deliverableObject;
                            if (deliverable.getFulfillmentProviderID().equals(providerID)
                                && deliverable.getExternalAccountID().equals(journey.getJourneyID()))
                              {
                                deliverableService.removeDeliverable(deliverable.getDeliverableID(), userID, tenantID);
                              }
                          }

                      }
                  }
              }
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", journey.getJourneyID());
        response.put("accepted", journey.getAccepted());
        response.put("valid", journey.getAccepted());
        response.put("processing", journeyService.isActiveJourney(journey, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, objectType, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            journeyService.putJourney(incompleteObject, journeyObjectiveService, catalogCharacteristicService, targetService, subscriberMessageTemplateService, (existingJourney == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        switch (objectType) 
          {
            case Journey:
              response.put("responseCode", "journeyNotValid");
              break;

            case Campaign:
              response.put("responseCode", "campaignNotValid");
              break;

            case Workflow:
              response.put("responseCode", "workflowNotValid");
              break;
              
            case BulkCampaign:
              response.put("responseCode", "bulkCampaignNotValid");
              break;

            default:
              response.put("responseCode", "NotValid");
              break;
          }
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
   *
   * processRemoveJourney
   *
   *****************************************/

  private JSONObject processRemoveJourney(String userID, JSONObject jsonRoot, GUIManagedObjectType objectType, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    HashMap<String, Object> response = new HashMap<String, Object>();

    /*****************************************
     *
     * now
     *
     *****************************************/
    
    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    Date now = SystemTime.getCurrentTime();
    JSONArray journeyIDs = new JSONArray();
    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> journeys = new ArrayList<>();
    List<String> removedIDs = new ArrayList<>();

    /****************************************
     *
     * argument
     *
     ****************************************/
    //
    //remove single journey
    //
    if (jsonRoot.containsKey("id"))
      {
        String journeyID = JSONUtilities.decodeString(jsonRoot, "id", false);
        journeyIDs.add(journeyID);
        GUIManagedObject journey = journeyService.getStoredJourney(journeyID);
        if (journey != null && (force || !journey.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (journey != null)
          singleIDresponseCode = "failedReadOnly";
        else
          {
            switch (objectType)
              {
                case Journey:
                  singleIDresponseCode = "journeyNotFound";
                  break;

                case Campaign:
                  singleIDresponseCode = "campaignNotFound";
                  break;

                case Workflow:
                  singleIDresponseCode = "workflowNotFound";
                  break;

                case BulkCampaign:
                  singleIDresponseCode = "bulkCampaignNotFound";
                  break;

                default:
                  singleIDresponseCode = "notFound";
                  break;
              }
          }

      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        journeyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < journeyIDs.size(); i++)
      {
        String journeyID = journeyIDs.get(i).toString();
        GUIManagedObject journey = journeyService.getStoredJourney(journeyID);

        if (journey != null && (force || !journey.getReadOnly()))
          {
            journeys.add(journey);
            removedIDs.add(journeyID);
          }
      }
        
  
    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < journeys.size(); i++)
      {
        GUIManagedObject journey = journeys.get(i);
        journey = (journey != null && journey.getGUIManagedObjectType() == objectType) ? journey : null;
        //
        // remove journey
        //

        journeyService.removeJourney(journey.getGUIManagedObjectID(), userID, tenantID);

        //
        // remove related deliverable
        //

        if (GUIManagedObjectType.Campaign.equals(objectType))
          {
            //
            // TODO SCH : what if deliverable is used in an offer ?
            //

            DeliveryManagerDeclaration deliveryManager = Deployment.getDeliveryManagers().get("journeyFulfillment");
            JSONObject deliveryManagerJSON = (deliveryManager != null) ? deliveryManager.getJSONRepresentation() : null;
            String providerID = (deliveryManagerJSON != null) ? (String) deliveryManagerJSON.get("providerID") : null;
            if (providerID != null)
              {
                for (GUIManagedObject deliverableOgbject : deliverableService.getStoredDeliverables(tenantID))
                  {
                    Deliverable deliverable = (Deliverable) deliverableOgbject;
                    if (deliverable.getFulfillmentProviderID().equals(providerID)
                        && deliverable.getExternalAccountID().equals(journey.getGUIManagedObjectID()))
                      {
                        deliverableService.removeDeliverable(deliverable.getDeliverableID(), userID, tenantID);
                      }
                  }
              }
          }
      }

        /*****************************************
         *
         * responseCode
         *
         *****************************************/
        if (jsonRoot.containsKey("id"))
          {
            response.put("responseCode", singleIDresponseCode);
            return JSONUtilities.encodeObject(response);
          }
        else
          {
            response.put("responseCode", "ok");
          }

    /*****************************************
     *
     * response
     *
     *****************************************/

    response.put("removedJourneyIDS", JSONUtilities.encodeArray(removedIDs));
    return JSONUtilities.encodeObject(response);
    
  }
  


  /*****************************************
  *
  *  processUpdateJourney
  *
  *****************************************/

  private JSONObject processUpdateJourney(String userID, JSONObject jsonRoot, GUIManagedObjectType objectType, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    JSONArray journeyIDs = new JSONArray();
    List<GUIManagedObject> existingJourneys = new ArrayList();
    List<String> updatedIDs = new ArrayList();
    List<Object> exceptionList= new ArrayList();


    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    * update product
    *
    *****************************************/

  if (jsonRoot.containsKey("ids"))
     {
       journeyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false); // update for multiple product
     }
   else
     {
       response.put("responseCode", "invalidJourney");
       response.put("responseMessage", "Journey ID is empty");
       return JSONUtilities.encodeObject(response);
     }

   /*****************************************
   *
   * existing journeys
   *
   *****************************************/
  for (int i = 0; i < journeyIDs.size(); i++)
    {
      String journeyID = (journeyIDs.get(i)).toString();
      GUIManagedObject existingJourneyObject = journeyService.getStoredJourney(journeyID);
      if (existingJourneyObject != null)
        {
          existingJourneys.add(existingJourneyObject); //ignore the wrong journeyIDs
        }
    }

  if (existingJourneys == null || existingJourneys.isEmpty())
    {
      response.put("responseCode", "invalidjourneys");
      response.put("responseMessage", "journeys does not exist");
      return JSONUtilities.encodeObject(response);
    }

  for (GUIManagedObject existingJourneyToBeUpdated : existingJourneys)
    {
    //
    // recurrence
    //
    boolean recurrence = false;
    String recurrenceID = null;
    JSONObject JSONToBeUpdated = new JSONObject();
    Set<String> JsonRootkeySets = jsonRoot.keySet();
    JSONObject existingJourneyObject = existingJourneyToBeUpdated.getJSONRepresentation();
        if (jsonRoot.containsKey("recurrence"))
          {

            recurrence = JSONUtilities.decodeBoolean(jsonRoot, "recurrence", Boolean.FALSE);
          }
        else
          {
            recurrence = JSONUtilities.decodeBoolean(existingJourneyObject, "recurrence", Boolean.FALSE);
          }
        if (jsonRoot.containsKey("recurrenceId"))
          {
            recurrenceID = JSONUtilities.decodeString(jsonRoot, "recurrenceId", false);
          }
        else
          {
            recurrenceID = JSONUtilities.decodeString(existingJourneyObject, "recurrenceId", false);
          }
        if (recurrence && recurrenceID == null)
          jsonRoot.put("recurrenceId", existingJourneyToBeUpdated.getGUIManagedObjectID());
        if (recurrence && JSONUtilities.decodeInteger(jsonRoot, "lastCreatedOccurrenceNumber", false) == null)
          jsonRoot.put("lastCreatedOccurrenceNumber", 1);

        for (String JsonRootkey : JsonRootkeySets)
          {
            JSONToBeUpdated.put(JsonRootkey, jsonRoot.get(JsonRootkey));  // get the part of GUI object which need to be updated from jsonRoot
          }
        JSONToBeUpdated.put("id", existingJourneyToBeUpdated.getGUIManagedObjectID());
        for (Object keyObject : existingJourneyObject.keySet())
          {
            String key = keyObject.toString();
            if (key != null && (!(JsonRootkeySets.contains(key))))
              {
                JSONToBeUpdated.put(key, existingJourneyObject.get(key)); //get the other parts of the GUI objects from the existing journey JSON

              }
          }


    //
    // initial approval
    //

    JourneyStatus approval = JourneyStatus.Pending;

    /*****************************************
    *
    *  process journey
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
          {
            //
            // change approval if existingJourney
            //

            if (existingJourneyToBeUpdated != null && existingJourneyToBeUpdated.getAccepted())
              {
                approval = ((Journey) existingJourneyToBeUpdated).getApproval();
              }

            /****************************************
             *
             * instantiate journey
             *
             ****************************************/
            if (JSONToBeUpdated.containsKey("id"))
              {
                JSONToBeUpdated.remove("ids");
              }
            Journey journey = new Journey(JSONToBeUpdated, objectType, epoch, existingJourneyToBeUpdated,
                journeyService, catalogCharacteristicService, subscriberMessageTemplateService,
                dynamicEventDeclarationsService, journeyTemplateService, approval, tenantID);

            if (GUIManagedObjectType.Workflow.equals(objectType))
              {
                journey.setApproval(JourneyStatus.StartedApproved);
              }

            //
            // Update targetCount
            //
            journey.setTargetCount(elasticsearch, uploadedFileService, tenantID);

            /*****************************************
             *
             * store
             *
             *****************************************/
            if (!dryRun)
              {

                journeyService.putJourney(journey, journeyObjectiveService, catalogCharacteristicService, targetService,
                    subscriberMessageTemplateService, (existingJourneyToBeUpdated == null), userID);

                /*****************************************
                 *
                 * handle related deliverable
                 *
                 *****************************************/

                if (GUIManagedObjectType.Campaign.equals(objectType))
                  {
                    DeliveryManagerDeclaration deliveryManager = Deployment.getDeliveryManagers()
                        .get("journeyFulfillment");
                    JSONObject deliveryManagerJSON = (deliveryManager != null) ? deliveryManager.getJSONRepresentation()
                        : null;
                    String providerID = (deliveryManagerJSON != null) ? (String) deliveryManagerJSON.get("providerID")
                        : null;
                    if (providerID != null)
                      {
                        if (journey.getTargetingType().equals(TargetingType.Manual))
                          {

                            //
                            // create deliverable -- only if campaign has
                            // "manual
                            // provisioning"
                            //

                            Map<String, Object> deliverableMap = new HashMap<String, Object>();
                            deliverableMap.put("id", CommodityDeliveryManager.JOURNEY_PREFIX + journey.getJourneyID());
                            deliverableMap.put("fulfillmentProviderID", providerID);
                            deliverableMap.put("externalAccountID", journey.getJourneyID());
                            deliverableMap.put("name", journey.getJourneyName());
                            deliverableMap.put("display", journey.getJourneyName());
                            deliverableMap.put("active", true);
                            deliverableMap.put("unitaryCost", 0);
                            deliverableMap.put("label", "campaign");
                            Deliverable deliverable = new Deliverable(JSONUtilities.encodeObject(deliverableMap), epoch,
                                null, tenantID);
                            deliverableService.putDeliverable(deliverable, true, userID);
                          }
                        else
                          {

                            //
                            // delete deliverable -- only if campaign does NOT
                            // have
                            // "manual provisioning"
                            //

                            // TODO SCH : may need to check that deliverable is
                            // not
                            // used in any offer

                            for (GUIManagedObject deliverableObject : deliverableService.getStoredDeliverables(tenantID))
                              {
                                Deliverable deliverable = (Deliverable) deliverableObject;
                                if (deliverable.getFulfillmentProviderID().equals(providerID)
                                    && deliverable.getExternalAccountID().equals(journey.getJourneyID()))
                                  {
                                    deliverableService.removeDeliverable(deliverable.getDeliverableID(), userID, tenantID);
                                  }
                              }

                          }
                      }
                  }
              }

            /*****************************************
             *
             * response
             *
             *****************************************/

            if (jsonRoot.containsKey("ids"))
              {
                updatedIDs.add(journey.getJourneyID());
              }
          }
    catch (JSONUtilitiesException|GUIManagerException e)
          {
            //
            // incompleteObject
            //

            IncompleteObject incompleteObject = new IncompleteObject(JSONToBeUpdated, objectType, epoch, tenantID);

            //
            // store
            //
            if (!dryRun)
              {
                journeyService.putJourney(incompleteObject, journeyObjectiveService, catalogCharacteristicService,
                    targetService, subscriberMessageTemplateService, (existingJourneyToBeUpdated == null), userID);
              }
            //
            // log
            //

            StringWriter stackTraceWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stackTraceWriter, true));
            log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

            //
            // response
            //

            if (jsonRoot.containsKey("ids"))
              {
                HashMap<String, String> invalidProductsExceptions = new HashMap<String, String>();
                invalidProductsExceptions.put("id", incompleteObject.getGUIManagedObjectID());
                switch (objectType)
                  {
                    case Journey:
                      invalidProductsExceptions.put("responseCode", "journeyNotValid");
                      break;

                    case Campaign:
                      invalidProductsExceptions.put("responseCode", "campaignNotValid");
                      break;

                    case Workflow:
                      invalidProductsExceptions.put("responseCode", "workflowNotValid");
                      break;

                    default:
                      invalidProductsExceptions.put("responseCode", "NotValid");
                      break;
                  }
                invalidProductsExceptions.put("responseMessage", e.getMessage());
                invalidProductsExceptions.put("responseParameter",
                    (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
                exceptionList.add(invalidProductsExceptions); // get the exceptions for multiple journeys
                updatedIDs.add(incompleteObject.getGUIManagedObjectID());
              }
          }
    }
    if (jsonRoot.containsKey("ids"))
      {
        response.put("updatedIds", updatedIDs);
        response.put("exceptionIds", exceptionList);
        response.put("responseCode", "ok");
      }

  return JSONUtilities.encodeObject(response);
  }

  /*****************************************
   *
   * processSetStatusJourney
   *
   *****************************************/

  private JSONObject processSetStatusJourney(String userID, JSONObject jsonRoot, GUIManagedObjectType objectType, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray journeyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < journeyIDs.size(); i++)
      {

        String journeyID = journeyIDs.get(i).toString();
        GUIManagedObject existingElement = journeyService.getStoredJourney(journeyID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(journeyID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {

                /****************************************
                 *
                 * instantiate journey
                 *
                 ****************************************/

                Journey journey = new Journey(elementRoot, objectType, epoch, existingElement, journeyService,
                    catalogCharacteristicService, subscriberMessageTemplateService, dynamicEventDeclarationsService, journeyTemplateService, tenantID);

                journeyService.putJourney(journey, journeyObjectiveService, catalogCharacteristicService, targetService, subscriberMessageTemplateService,
                    (existingElement == null), userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, objectType, epoch, tenantID);

                //
                // store
                //
                journeyService.putJourney(incompleteObject, journeyObjectiveService, catalogCharacteristicService, targetService, subscriberMessageTemplateService, (existingElement == null), userID);
                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }

    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
   *
   * processSetActive
   *
   *****************************************/

  private JSONObject processSetActive(String userID, JSONObject jsonRoot, GUIManagedObjectType type, boolean active, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    HashMap<String, Object> response = new HashMap<String, Object>();

    /*****************************************
     *
     * now
     *
     *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<GUIManagedObject> journeys = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray elementIDs = new JSONArray();

    /****************************************
     *
     * argument
     *
     ****************************************/
    //
    // single element
    //
    if (jsonRoot.containsKey("id"))
      {
        String elementID = JSONUtilities.decodeString(jsonRoot, "id", false);
        elementIDs.add(elementID);

      }
    //
    // multiple element
    //

    if (jsonRoot.containsKey("ids"))
      {
        elementIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }

    String approvalStatusString = JSONUtilities.decodeString(jsonRoot, "status", false);
    JourneyStatus approval = JourneyStatus.fromExternalRepresentation(approvalStatusString);

    /*****************************************
     *
     * validate existing object (journey, campaign or bulk campaign) - exists -
     * valid - not read-only
     *
     *****************************************/
    for (int i = 0; i < elementIDs.size(); i++)
      {
        String elementID = elementIDs.get(i).toString();
        GUIManagedObject existingElement = journeyService.getStoredJourney(elementID);
        if (existingElement != null && !(existingElement.getReadOnly()) && existingElement.getAccepted()) {

          journeys.add(existingElement);
          validIDs.add(elementID);
        }
        String responseCode = null;
        if (jsonRoot.containsKey("id"))
          {
            if (existingElement == null)
              {
                switch (type)
                  {
                    case Journey:
                      responseCode = (responseCode == null && existingElement == null) ? "journeyNotFound"
                          : responseCode;
                      responseCode = (responseCode == null
                          && existingElement.getGUIManagedObjectType() != GUIManagedObjectType.Journey)
                              ? "journeyNotFound"
                              : responseCode;
                      responseCode = (responseCode == null && !existingElement.getAccepted()) ? "journeyNotValid"
                          : responseCode;
                      responseCode = (responseCode == null && existingElement.getReadOnly()) ? "failedReadOnly"
                          : responseCode;
                      break;

                    case Campaign:
                      responseCode = (responseCode == null && existingElement == null) ? "campaignNotFound"
                          : responseCode;
                      responseCode = (responseCode == null
                          && existingElement.getGUIManagedObjectType() != GUIManagedObjectType.Campaign)
                              ? "campaignNotFound"
                              : responseCode;
                      responseCode = (responseCode == null && !existingElement.getAccepted()) ? "campaignNotValid"
                          : responseCode;
                      responseCode = (responseCode == null && existingElement.getReadOnly()) ? "failedReadOnly"
                          : responseCode;
                      break;

                    case BulkCampaign:
                      responseCode = (responseCode == null && existingElement == null) ? "bulkCampaignNotFound"
                          : responseCode;
                      responseCode = (responseCode == null
                          && existingElement.getGUIManagedObjectType() != GUIManagedObjectType.BulkCampaign)
                              ? "bulkCampaignNotFound"
                              : responseCode;
                      responseCode = (responseCode == null && !existingElement.getAccepted()) ? "bulkCampaignNotValid"
                          : responseCode;
                      responseCode = (responseCode == null && existingElement.getReadOnly()) ? "failedReadOnly"
                          : responseCode;
                      break;

                    default:
                      throw new ServerRuntimeException("invalid guimanagedobject type");
                  }

                if (responseCode != null)
                  {
                    response.put("id", elementID);
                    if (existingElement != null)
                      response.put("accepted", existingElement.getAccepted());
                    if (existingElement != null)
                      response.put("valid", existingElement.getAccepted());
                    if (existingElement != null)
                      response.put("processing", journeyService.isActiveJourney(existingElement, now));
                    response.put("responseCode", responseCode);
                    return JSONUtilities.encodeObject(response);
                  }
              }
          }
      }

    /*****************************************
     *
     * process element (journey, campaign or bulk campaign)
     *
     *****************************************/
    for (GUIManagedObject journey : journeys)
      {
        GUIManagedObject existingJourneyElement = journey;
        JSONObject elementRoot = (JSONObject) existingJourneyElement.getJSONRepresentation().clone();
        long epoch = epochServer.getKey();
        try
          {

            switch (approval)
              {
                case Unknown:
                case StartedApproved:
                  elementRoot.put("active", active);
                  approval = JourneyStatus.StartedApproved;
                  break;

                case WaitingForApproval:
                case PendingNotApproved:
                  elementRoot.put("active", false);
                  break;

                default:
                  throw new ServerRuntimeException("invalid approvalStatus " + approval);
              }

            /****************************************
             *
             * instantiate element (journey, campaign or bulk campaign)
             *
             ****************************************/

            Journey element = new Journey(elementRoot, type, epoch, existingJourneyElement, journeyService,
                catalogCharacteristicService, subscriberMessageTemplateService, dynamicEventDeclarationsService, journeyTemplateService,
                approval, tenantID);

            /*****************************************
             *
             * store
             *
             *****************************************/

            journeyService.putJourney(element, journeyObjectiveService, catalogCharacteristicService, targetService, subscriberMessageTemplateService,
                (existingJourneyElement == null), userID);

            /*****************************************
             *
             * response
             *
             *****************************************/
            if (jsonRoot.containsKey("id"))
              {

                response.put("id", element.getJourneyID());
                response.put("accepted", element.getAccepted());
                response.put("valid", element.getAccepted());
                response.put("processing", journeyService.isActiveJourney(element, now));
                response.put("responseCode", "ok");
                return JSONUtilities.encodeObject(response);
              }
            else
              {
                response.put("responseCode", "ok");                
              }
          }
        catch (GUIManagerException e)
          {
            //
            // incompleteObject
            //

            IncompleteObject incompleteObject = new IncompleteObject(elementRoot, type, epoch, tenantID);

            //
            // store
            //

            journeyService.putJourney(incompleteObject, journeyObjectiveService, catalogCharacteristicService, targetService, subscriberMessageTemplateService, (existingJourneyElement == null), userID);

            //
            // log
            //

            StringWriter stackTraceWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stackTraceWriter, true));
            log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

            //
            // response
            //
            if (jsonRoot.containsKey("id"))
              {

                switch (type)
                  {
                    case Journey:
                      response.put("journeyID", incompleteObject.getGUIManagedObjectID());
                      response.put("responseCode", "journeyNotValid");
                      break;

                    case Campaign:
                      response.put("campaignID", incompleteObject.getGUIManagedObjectID());
                      response.put("responseCode", "campaignNotValid");
                      break;

                    case BulkCampaign:
                      response.put("bulkCampaignID", incompleteObject.getGUIManagedObjectID());
                      response.put("responseCode", "bulkCampaignNotValid");
                      break;
                  }
                response.put("responseMessage", e.getMessage());
                response.put("responseParameter",
                    (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
                return JSONUtilities.encodeObject(response);
              }

          }
      }
    response.put("validIDs", validIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getCampaignToolbox
  *
  *****************************************/

  private JSONObject processGetCampaignToolbox(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve campaignToolboxSections
    *
    *****************************************/

    List<JSONObject> campaignToolboxSections = new ArrayList<JSONObject>();
    for (ToolboxSection campaignToolboxSection : Deployment.getDeployment(tenantID).getCampaignToolbox().values())
      {
        JSONObject campaignToolboxSectionJSON = campaignToolboxSection.getJSONRepresentation();
        campaignToolboxSections.add(campaignToolboxSectionJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("campaignToolbox", JSONUtilities.encodeArray(campaignToolboxSections));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getWorkflowToolbox
  *
  *****************************************/

  private JSONObject processGetWorkflowToolbox(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve workflowToolboxSections
    *
    *****************************************/

    List<JSONObject> workflowToolboxSections = new ArrayList<JSONObject>();
    for (ToolboxSection workflowToolboxSection : Deployment.getDeployment(tenantID).getWorkflowToolbox().values())
      {
        JSONObject workflowToolboxSectionJSON = workflowToolboxSection.getJSONRepresentation();
        workflowToolboxSections.add(workflowToolboxSectionJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("workflowToolbox", JSONUtilities.encodeArray(workflowToolboxSections));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetLoyaltyWorkflowToolbox
  *
  *****************************************/

  private JSONObject processGetLoyaltyWorkflowToolbox(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve loyaltyWorkflowToolboxSections
    *
    *****************************************/

    List<JSONObject> loyaltyWorkflowToolboxSections = new ArrayList<JSONObject>();
    for (ToolboxSection loyaltyWorkflowToolboxSection : Deployment.getDeployment(tenantID).getLoyaltyWorkflowToolbox().values())
      {
        JSONObject workflowToolboxSectionJSON = loyaltyWorkflowToolboxSection.getJSONRepresentation();
        loyaltyWorkflowToolboxSections.add(workflowToolboxSectionJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("loyaltyWorkflowToolbox", JSONUtilities.encodeArray(loyaltyWorkflowToolboxSections));
    return JSONUtilities.encodeObject(response);
  }
  
  
   
  
  /*****************************************
  *
  *  processGetBulkCampaignCapacity
  *
  *****************************************/  

  private JSONObject processGetBulkCampaignCapacity(String userID, JSONObject jsonRoot, int tenantID)
  {
    HashMap<String,Object> response = new HashMap<String,Object>();
    
    //
    //  get journey template
    //
    String journeyTemplateID = JSONUtilities.decodeString(jsonRoot, "journeyTemplateID", false);
    if(journeyTemplateID == null || journeyTemplateID.isEmpty()){
      response.put("responseCode", "missingJourneyTemplate");
      return JSONUtilities.encodeObject(response);
    }
    
    Long maximumCapacity = Deployment.getDeployment(tenantID).getJourneyTemplateCapacities().get(journeyTemplateID);
    if(maximumCapacity == null){
      // @rl: templates added dynamically are not supported yet. This would need a refactoring of journey templates.
      response.put("responseCode", "journeyTemplateNotFound");
      return JSONUtilities.encodeObject(response);
    }
    
    //
    //  get start date
    //
    String bulkCampaignEffectiveStartDate = JSONUtilities.decodeString(jsonRoot, "effectiveStartDate", false);
    if(bulkCampaignEffectiveStartDate == null){
      response.put("responseCode", "startDateNotFound");
      return JSONUtilities.encodeObject(response);
    }
    Date targetDay;
    try {
      Date startDate = GUIManagedObject.parseDateField(bulkCampaignEffectiveStartDate);
      targetDay = RLMDateUtils.truncate(startDate, Calendar.DATE, Deployment.getDeployment(tenantID).getTimeZone());
    } catch (JSONUtilitiesException e) {
      response.put("responseCode", "invalidStartDate");
      return JSONUtilities.encodeObject(response);
    }
    
    
    //
    //  get planned capacity
    //
    long plannedCapacity = 0;
    for (GUIManagedObject journey : journeyService.getStoredJourneys(false, tenantID)) {
      if ( journey.getGUIManagedObjectType().equals(GUIManagedObjectType.BulkCampaign) && journey.getEffectiveStartDate() != null) {
        Date startDate = RLMDateUtils.truncate(journey.getEffectiveStartDate(), Calendar.DATE, Deployment.getDeployment(tenantID).getTimeZone());
        Object templateIDObj = journey.getJSONRepresentation().get("journeyTemplateID"); // only in JSON representation
        String templateID = (templateIDObj != null && templateIDObj instanceof String) ? (String) templateIDObj : null;
        
        // Check same effectiveStartDate and same template type !
        if(targetDay.equals(startDate) && journeyTemplateID.equals(templateID)) {
          Object targetCountObj = journey.getJSONRepresentation().get("targetCount");  // only in JSON representation
          long targetCount = (targetCountObj != null && targetCountObj instanceof Long) ? (long) targetCountObj : 0;
          plannedCapacity += targetCount;
        }
      }
    }
    
    /*****************************************
    *
    *  response
    *
    *****************************************/
    response.put("responseCode", "ok");
    response.put("plannedCapacity", plannedCapacity);
    response.put("topCapacity", maximumCapacity);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutBulkCampaign
  *
  *****************************************/  

  private JSONObject processPutBulkCampaign(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;

    /*****************************************
     *
     * dryRun
     *
     *****************************************/
    if (jsonRoot.containsKey("dryRun"))
      {
        dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
      }

    /*****************************************
    *
    *  retrieve campaign informations
    *
    *****************************************/

    //
    //  get journey template
    //
    
    String journeyTemplateID = journeyTemplateID = JSONUtilities.decodeString(jsonRoot, "journeyTemplateID", false);
    if(journeyTemplateID == null || journeyTemplateID.isEmpty()){
      response.put("responseCode", "missingJourneyTemplate");
      return JSONUtilities.encodeObject(response);
    }
    Journey journeyTemplate = journeyTemplateService.getActiveJourneyTemplate(journeyTemplateID, now);
    if(journeyTemplate == null){
      response.put("responseCode", "journeyTemplateNotFound");
      return JSONUtilities.encodeObject(response);
    }
    
    //
    //  get campaign parameters
    //
    
    String bulkCampaignID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (bulkCampaignID == null)
      {
        bulkCampaignID = journeyService.generateJourneyID();
        jsonRoot.put("id", bulkCampaignID);
      }
    String bulkCampaignName = JSONUtilities.decodeString(jsonRoot, "name", true);
    String bulkCampaignDisplay = JSONUtilities.decodeString(jsonRoot, "display", true);
    String bulkCampaignDescription = JSONUtilities.decodeString(jsonRoot, "description", false);
    String bulkCampaignEffectiveStartDate = JSONUtilities.decodeString(jsonRoot, "effectiveStartDate", true);
    String bulkCampaignEffectiveEndDate = JSONUtilities.decodeString(jsonRoot, "effectiveEndDate", true);
    JSONArray bulkCampaignTargetIDs = JSONUtilities.decodeJSONArray(jsonRoot, "targetID", true);
    JSONArray bulkCampaignBoundParameters = JSONUtilities.decodeJSONArray(jsonRoot, "boundParameters", true);
    boolean appendUCG = JSONUtilities.decodeBoolean(jsonRoot, "appendUCG", true);
    boolean appendInclusionLists = JSONUtilities.decodeBoolean(jsonRoot, "appendInclusionLists", true);
    boolean appendExclusionLists = JSONUtilities.decodeBoolean(jsonRoot, "appendExclusionLists", true);
    String userIdentifier = JSONUtilities.decodeString(jsonRoot, "userID", "");
    String userName = JSONUtilities.decodeString(jsonRoot, "userName", "");
    boolean active = JSONUtilities.decodeBoolean(jsonRoot, "active", Boolean.FALSE);
    JSONArray bulkCampaignJourneyObjectives = JSONUtilities.decodeJSONArray(jsonRoot, "journeyObjectives", true);
    JSONObject bulkCampaignStory = JSONUtilities.decodeJSONObject(jsonRoot, "story", true);
    JSONObject bulkCampaignInfo = JSONUtilities.decodeJSONObject(jsonRoot, "info", false);
    String targetingType = JSONUtilities.decodeString(jsonRoot, "targetingType", "criteria");
    JSONArray bulkCampaignTargetCriteria = JSONUtilities.decodeJSONArray(jsonRoot, "targetingCriteria", true);
    int priority = JSONUtilities.decodeInteger(jsonRoot, "priority", Integer.MAX_VALUE); // for legacy campaigns, very low priority


    //
    //  recurrent
    //
    
    boolean recurrence = JSONUtilities.decodeBoolean(jsonRoot, "recurrence", Boolean.FALSE);
    String recurrenceId = JSONUtilities.decodeString(jsonRoot, "recurrenceId", false);
    if (recurrence && recurrenceId == null) recurrenceId = bulkCampaignID;
    Integer occurrenceNumber = JSONUtilities.decodeInteger(jsonRoot, "occurrenceNumber", recurrence);
    JSONObject journeyScheduler = JSONUtilities.decodeJSONObject(jsonRoot, "scheduler", recurrence);
    Integer lastCreatedOccurrenceNumber = JSONUtilities.decodeInteger(jsonRoot, "lastCreatedOccurrenceNumber", false);
    if (recurrence && lastCreatedOccurrenceNumber == null) lastCreatedOccurrenceNumber = 1;
    boolean recurrenceActive = JSONUtilities.decodeBoolean(jsonRoot, "recurrenceActive", Boolean.FALSE);
    String targetingFileVariableID = JSONUtilities.decodeString(jsonRoot, "targetingFileVariableID", false);
    JSONArray targetFileVariablesJSON = JSONUtilities.decodeJSONArray(jsonRoot, "targetFileVariables", false);

    /*****************************************
    *
    *  existing journey
    *
    *****************************************/

    GUIManagedObject existingBulkCampaign = journeyService.getStoredJourney(bulkCampaignID);
    existingBulkCampaign = (existingBulkCampaign != null && existingBulkCampaign.getGUIManagedObjectType() == GUIManagedObjectType.BulkCampaign) ? existingBulkCampaign : null;

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingBulkCampaign != null && existingBulkCampaign.getReadOnly())
      {
        response.put("id", existingBulkCampaign.getGUIManagedObjectID());
        response.put("accepted", existingBulkCampaign.getAccepted());
        response.put("valid", existingBulkCampaign.getAccepted());
        response.put("processing", journeyService.isActiveJourney(existingBulkCampaign, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process journey
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        //
        // initial approval
        //
        
        JourneyStatus approval = JourneyStatus.Pending;
        
        if (existingBulkCampaign != null && existingBulkCampaign.getAccepted())
          {
            approval = ((Journey) existingBulkCampaign).getApproval();
          }
        
        /*****************************************
        *
        *  templateJSONRepresentation
        *
        *****************************************/

        JSONObject templateJSONRepresentation = journeyTemplate.getJSONRepresentation();

        /*****************************************
        *
        *  generate JSON representation of the bulk campaign
        *
        *****************************************/

        Map<String,Object> campaignJSONRepresentation = new HashMap<String,Object>(templateJSONRepresentation);

        //
        //  override with bulkCampaign attributes
        //

        campaignJSONRepresentation.put("journeyTemplateID", journeyTemplateID);
        campaignJSONRepresentation.put("id", bulkCampaignID);
        campaignJSONRepresentation.put("name", bulkCampaignName);
        campaignJSONRepresentation.put("display", bulkCampaignDisplay);
        campaignJSONRepresentation.put("description", bulkCampaignDescription);
        campaignJSONRepresentation.put("effectiveStartDate", bulkCampaignEffectiveStartDate);
        campaignJSONRepresentation.put("effectiveEndDate", bulkCampaignEffectiveEndDate);
        campaignJSONRepresentation.put("targetingType", targetingType);
        campaignJSONRepresentation.put("targetID", bulkCampaignTargetIDs);
        campaignJSONRepresentation.put("boundParameters", bulkCampaignBoundParameters);
        campaignJSONRepresentation.put("appendUCG", appendUCG);
        campaignJSONRepresentation.put("appendInclusionLists", appendInclusionLists);
        campaignJSONRepresentation.put("appendExclusionLists", appendExclusionLists);
        campaignJSONRepresentation.put("userID", userIdentifier);
        campaignJSONRepresentation.put("userName", userName);
        campaignJSONRepresentation.put("active", active);
        campaignJSONRepresentation.put("journeyObjectives", bulkCampaignJourneyObjectives); 
        campaignJSONRepresentation.put("story", bulkCampaignStory);
        if (bulkCampaignInfo != null)
          {
            campaignJSONRepresentation.put("info", bulkCampaignInfo);
          }
        
        campaignJSONRepresentation.put("targetingCriteria", bulkCampaignTargetCriteria);
        
        campaignJSONRepresentation.put("recurrence", recurrence);
        campaignJSONRepresentation.put("recurrenceId", recurrenceId);
        campaignJSONRepresentation.put("occurrenceNumber", occurrenceNumber);
        if (journeyScheduler != null)campaignJSONRepresentation.put("scheduler", JSONUtilities.encodeObject(journeyScheduler));
        campaignJSONRepresentation.put("lastCreatedOccurrenceNumber", lastCreatedOccurrenceNumber);
        campaignJSONRepresentation.put("recurrenceActive", recurrenceActive);
        campaignJSONRepresentation.put("priority", priority);
        campaignJSONRepresentation.put("targetingFileVariableID", targetingFileVariableID);
        campaignJSONRepresentation.put("targetFileVariables", targetFileVariablesJSON);

        //
        //  campaignJSON
        //

        JSONObject campaignJSON = JSONUtilities.encodeObject(campaignJSONRepresentation);

        /****************************************
        *
        *  instantiate bulk campaign
        *
        ****************************************/

        Journey bulkCampaign = new Journey(campaignJSON, GUIManagedObjectType.BulkCampaign, epoch, existingBulkCampaign, journeyService, catalogCharacteristicService, subscriberMessageTemplateService, dynamicEventDeclarationsService, journeyTemplateService, approval, tenantID);

        //
        // Update targetCount
        //
        bulkCampaign.setTargetCount(elasticsearch, uploadedFileService, tenantID);
        
        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            journeyService.putJourney(bulkCampaign, journeyObjectiveService, catalogCharacteristicService, targetService, subscriberMessageTemplateService, (existingBulkCampaign == null), userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", bulkCampaign.getJourneyID());
        response.put("accepted", bulkCampaign.getAccepted());
        response.put("valid", bulkCampaign.getAccepted());
        response.put("processing", journeyService.isActiveJourney(bulkCampaign, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, GUIManagedObjectType.BulkCampaign, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            journeyService.putJourney(incompleteObject, journeyObjectiveService, catalogCharacteristicService, targetService, subscriberMessageTemplateService, (existingBulkCampaign == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "bulkCampaignNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }


  /*****************************************
  *
  *  processUpdateBulkCampaign
  *
  *****************************************/

  private JSONObject processUpdateBulkCampaign(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    JSONArray BulkCampaignIDs = new JSONArray();
    List<GUIManagedObject> existingbulkCampaigns = new ArrayList();
    List<String> updatedIDs = new ArrayList();
    List<Object> exceptionList= new ArrayList();

    /*****************************************
     *
     * dryRun
     *
     *****************************************/
    if (jsonRoot.containsKey("dryRun"))
      {
        dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
      }

    /*****************************************
    *
    * update product
    *
    *****************************************/

   if (jsonRoot.containsKey("ids"))
     {
       BulkCampaignIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false); // update for multiple product
     }
   else
     {
       response.put("responseCode", "invalidBulkCampaign");
       response.put("responseMessage", "bulkCampaign ID is empty");
       return JSONUtilities.encodeObject(response);
     }

   /*****************************************
    *
    * existing bulkCampaign
    *
    *****************************************/
   for (int i = 0; i < BulkCampaignIDs.size(); i++)
     {
       String bulkCampaignID = (BulkCampaignIDs.get(i)).toString();
       GUIManagedObject existingBulkCampaignObject = journeyService.getStoredJourney(bulkCampaignID);
       if (existingBulkCampaignObject != null)
         {
           existingbulkCampaigns.add(existingBulkCampaignObject); //ignore the wrong productIDs
         }
     }

   if (existingbulkCampaigns == null || existingbulkCampaigns.isEmpty())
     {
       response.put("responseCode", "invalidBulkCampaigns");
       response.put("responseMessage", "bulkCampaigns does not exist");
       return JSONUtilities.encodeObject(response);
     }

    /*****************************************
    *
    *  retrieve campaign informations
    *
    *****************************************/
   for (GUIManagedObject existingBulkCampaignToBeUpdated : existingbulkCampaigns)
      {

        JSONObject JSONToBeUpdated = new JSONObject();
        Set<String> JsonRootkeySets = jsonRoot.keySet();
        JSONObject existingBulkCampaignObject = existingBulkCampaignToBeUpdated.getJSONRepresentation();
        String journeyTemplateID = null;
        //
        // get journey template
        //
        if (jsonRoot.containsKey("journeyTemplateID"))
          {
            journeyTemplateID = journeyTemplateID = JSONUtilities.decodeString(jsonRoot, "journeyTemplateID", false);
          }
        else
          {
            journeyTemplateID = journeyTemplateID = JSONUtilities.decodeString(existingBulkCampaignObject,
                "journeyTemplateID", false);
          }
        if (journeyTemplateID == null || journeyTemplateID.isEmpty())
          {
            //response.put("responseCode", "missingJourneyTemplate");
            HashMap<String, String> errorResponseDisplay = new HashMap<String, String>();
            errorResponseDisplay.put("id", existingBulkCampaignToBeUpdated.getGUIManagedObjectID());
            errorResponseDisplay.put("responseCode",
                "missingJourneyTemplate");
            exceptionList.add(errorResponseDisplay);
            continue;
          }
        Journey journeyTemplate = journeyTemplateService.getActiveJourneyTemplate(journeyTemplateID, now);
        if (journeyTemplate == null)
          {
            //response.put("responseCode", "journeyTemplateNotFound");
            HashMap<String, String> errorResponseDisplay = new HashMap<String, String>();
            errorResponseDisplay.put("id", existingBulkCampaignToBeUpdated.getGUIManagedObjectID());
            errorResponseDisplay.put("responseCode",
                "journeyTemplateNotFound");
            exceptionList.add(errorResponseDisplay);
            continue;
          }

        //
        // get campaign parameters
        //

        String bulkCampaignID = existingBulkCampaignToBeUpdated.getGUIManagedObjectID();
        String bulkCampaignName = null;
        String bulkCampaignDisplay = null;
        String bulkCampaignDescription = null;
        String bulkCampaignEffectiveStartDate = null;
        String bulkCampaignEffectiveEndDate = null;
        JSONArray bulkCampaignTargetIDs = new JSONArray();
        JSONArray bulkCampaignBoundParameters = new JSONArray();
        boolean appendUCG = false;
        boolean appendInclusionLists = false;
        boolean appendExclusionLists = false;
        String userIdentifier = null;
        String userName = null;
        boolean active = false;
        JSONArray bulkCampaignJourneyObjectives = new JSONArray();
        JSONObject bulkCampaignStory = new JSONObject();
        JSONObject bulkCampaignInfo = new JSONObject();
        JSONArray bulkCampaignTargetCriteria = new JSONArray();
        int bulkCampaignPriority = Integer.MAX_VALUE;
        String targetingType = null;
        String targetingFileVariableID = null;
        JSONArray targetFileVariablesJSON = new JSONArray();
        JSONObject campaignJSON = new JSONObject();

        if (jsonRoot.containsKey("name"))
          {
            bulkCampaignName = JSONUtilities.decodeString(jsonRoot, "name", false);
          }
        else
          {
            bulkCampaignName = JSONUtilities.decodeString(existingBulkCampaignObject, "name", true);
          }
        if (jsonRoot.containsKey("display"))
          {
            bulkCampaignDisplay = JSONUtilities.decodeString(jsonRoot, "display", false);
          }
        else
          {
            bulkCampaignDisplay = JSONUtilities.decodeString(existingBulkCampaignObject, "display", true);
          }
        if (jsonRoot.containsKey("description"))
          {
            bulkCampaignDescription = JSONUtilities.decodeString(jsonRoot, "description", false);
          }
        else
          {
            bulkCampaignDescription = JSONUtilities.decodeString(existingBulkCampaignObject, "description", false);
          }
        if (jsonRoot.containsKey("effectiveStartDate"))
          {
            bulkCampaignEffectiveStartDate = JSONUtilities.decodeString(jsonRoot, "effectiveStartDate", false);
          }
        else
          {
            bulkCampaignEffectiveStartDate = JSONUtilities.decodeString(existingBulkCampaignObject,
                "effectiveStartDate", true);
          }
        if (jsonRoot.containsKey("effectiveEndDate"))
          {
            bulkCampaignEffectiveEndDate = JSONUtilities.decodeString(jsonRoot, "effectiveEndDate", false);
          }
        else
          {
            bulkCampaignEffectiveEndDate = JSONUtilities.decodeString(existingBulkCampaignObject, "effectiveEndDate",
                true);
          }

        if (jsonRoot.containsKey("targetID"))
          {
            bulkCampaignTargetIDs = JSONUtilities.decodeJSONArray(jsonRoot, "targetID", false);
          }
        else
          {
            bulkCampaignTargetIDs = JSONUtilities.decodeJSONArray(existingBulkCampaignObject, "targetID", true);
          }
        if (jsonRoot.containsKey("boundParameters"))
          {
            bulkCampaignBoundParameters = JSONUtilities.decodeJSONArray(jsonRoot, "boundParameters", false);
          }
        else
          {
            bulkCampaignBoundParameters = JSONUtilities.decodeJSONArray(existingBulkCampaignObject, "boundParameters", true);
          }
        if (jsonRoot.containsKey("appendUCG"))
          {
            appendUCG = JSONUtilities.decodeBoolean(jsonRoot, "appendUCG", false);
          }
        else
          {
            appendUCG = JSONUtilities.decodeBoolean(existingBulkCampaignObject, "appendUCG", true);
          }
        if (jsonRoot.containsKey("appendInclusionLists"))
          {
            appendInclusionLists = JSONUtilities.decodeBoolean(jsonRoot, "appendInclusionLists", false);
          }
        else
          {
            appendInclusionLists = JSONUtilities.decodeBoolean(existingBulkCampaignObject, "appendInclusionLists",
                true);
          }
        if (jsonRoot.containsKey("appendExclusionLists"))
          {
            appendExclusionLists = JSONUtilities.decodeBoolean(jsonRoot, "appendExclusionLists", false);
          }
        else
          {
            appendExclusionLists = JSONUtilities.decodeBoolean(existingBulkCampaignObject, "appendExclusionLists",
                true);
          }
        if (jsonRoot.containsKey("userID"))
          {
            userIdentifier = JSONUtilities.decodeString(jsonRoot, "userID", false);
          }
        else
          {
            userIdentifier = JSONUtilities.decodeString(existingBulkCampaignObject, "userID", "");
          }
        if (jsonRoot.containsKey("userName"))
          {
            userName = JSONUtilities.decodeString(jsonRoot, "userName", false);
          }
        else
          {
            userName = JSONUtilities.decodeString(existingBulkCampaignObject, "userName", "");
          }
        if (jsonRoot.containsKey("active"))
          {
            active = JSONUtilities.decodeBoolean(jsonRoot, "active", false);
          }
        else
          {
            active = JSONUtilities.decodeBoolean(existingBulkCampaignObject, "active", Boolean.FALSE);
          }
        if (jsonRoot.containsKey("journeyObjectives"))
          {
            bulkCampaignJourneyObjectives = JSONUtilities.decodeJSONArray(jsonRoot, "journeyObjectives", false);
          }
        else
          {
            bulkCampaignJourneyObjectives = JSONUtilities.decodeJSONArray(existingBulkCampaignObject,
                "journeyObjectives", true);
          }
        if (jsonRoot.containsKey("story"))
          {
            bulkCampaignStory = JSONUtilities.decodeJSONObject(jsonRoot, "story", false);
          }
        else
          {
            bulkCampaignStory = JSONUtilities.decodeJSONObject(existingBulkCampaignObject, "story", true);
          }
        if (jsonRoot.containsKey("info"))
          {
            bulkCampaignInfo = JSONUtilities.decodeJSONObject(jsonRoot, "info", false);
          }
        else
          {
            bulkCampaignInfo = JSONUtilities.decodeJSONObject(existingBulkCampaignObject, "info", false);
          }
        if (jsonRoot.containsKey("targetingCriteria"))
          {
            bulkCampaignTargetCriteria = JSONUtilities.decodeJSONArray(jsonRoot, "targetingCriteria", false);
          }
        else
          {
            bulkCampaignTargetCriteria = JSONUtilities.decodeJSONArray(existingBulkCampaignObject, "targetingCriteria",
                true);
          }
        if (jsonRoot.containsKey("targetingType"))
          {
            targetingType = JSONUtilities.decodeString(jsonRoot, "targetingType", false);
          }
        else
          {
            targetingType = JSONUtilities.decodeString(existingBulkCampaignObject, "targetingType", "criteria");
          }
        if (jsonRoot.containsKey("priority"))
          {
            bulkCampaignPriority = JSONUtilities.decodeInteger(jsonRoot, "priority", false);
          }
        else
          {
            bulkCampaignPriority = JSONUtilities.decodeInteger(existingBulkCampaignObject, "priority", Integer.MAX_VALUE);
          }

        //
        // recurrent
        //
        boolean recurrence = false;
        String recurrenceId = null;
        if (jsonRoot.containsKey("recurrence"))
          {
            recurrence = JSONUtilities.decodeBoolean(jsonRoot, "recurrence", false);
          }
        else
          {
            recurrence = JSONUtilities.decodeBoolean(existingBulkCampaignObject, "recurrence", Boolean.FALSE);
          }
        if (jsonRoot.containsKey("recurrenceId"))
          {
            recurrenceId = JSONUtilities.decodeString(jsonRoot, "recurrenceId", false);
          }
        else
          {
            recurrenceId = JSONUtilities.decodeString(existingBulkCampaignObject, "recurrenceId", false);
          }

        if (recurrence && recurrenceId == null)
          recurrenceId = bulkCampaignID;
        Integer occurrenceNumber ;
        if (jsonRoot.containsKey("occurrenceNumber"))
          {
            occurrenceNumber = JSONUtilities.decodeInteger(jsonRoot, "occurrenceNumber", false);

          }
        else
          {
            occurrenceNumber = JSONUtilities.decodeInteger(existingBulkCampaignObject, "occurrenceNumber", recurrence);
          }

        JSONObject journeyScheduler = new JSONObject();
        if (jsonRoot.containsKey("scheduler"))
          {
            journeyScheduler = JSONUtilities.decodeJSONObject(jsonRoot, "scheduler", false);

          }
        else
          {
            journeyScheduler = JSONUtilities.decodeJSONObject(existingBulkCampaignObject, "scheduler", recurrence);
          }
        Integer lastCreatedOccurrenceNumber;
        if (jsonRoot.containsKey("lastCreatedOccurrenceNumber"))
          {
            lastCreatedOccurrenceNumber = JSONUtilities.decodeInteger(jsonRoot, "lastCreatedOccurrenceNumber", false);

          }
        else
          {
            lastCreatedOccurrenceNumber = JSONUtilities.decodeInteger(existingBulkCampaignObject,
                "lastCreatedOccurrenceNumber", false);
          }
        if (jsonRoot.containsKey("targetingFileVariableID"))
          {
            targetingFileVariableID = JSONUtilities.decodeString(jsonRoot, "targetingFileVariableID", false);

          }
        else
          {
            targetingFileVariableID = JSONUtilities.decodeString(existingBulkCampaignObject,
                "targetingFileVariableID", false);
          }
        if (jsonRoot.containsKey("targetFileVariables"))
          {
            targetFileVariablesJSON = JSONUtilities.decodeJSONArray(jsonRoot, "targetFileVariables", false);
          }
        else
          {
            targetFileVariablesJSON = JSONUtilities.decodeJSONArray(existingBulkCampaignObject,
                "targetFileVariables", false);
          }

        if (recurrence && lastCreatedOccurrenceNumber == null)
          lastCreatedOccurrenceNumber = 1;

        /*****************************************
         *
         * existing journey
         *
         *****************************************/
        existingBulkCampaignToBeUpdated = (existingBulkCampaignToBeUpdated != null
            && existingBulkCampaignToBeUpdated.getGUIManagedObjectType() == GUIManagedObjectType.BulkCampaign)
                ? existingBulkCampaignToBeUpdated
                : null;

        /*****************************************
         *
         * process journey
         *
         *****************************************/

        long epoch = epochServer.getKey();
        try
          {
            //
            // initial approval
            //

            JourneyStatus approval = JourneyStatus.Pending;

            if (existingBulkCampaignToBeUpdated != null && existingBulkCampaignToBeUpdated.getAccepted())
              {
                approval = ((Journey) existingBulkCampaignToBeUpdated).getApproval();
              }

            /*****************************************
             *
             * templateJSONRepresentation
             *
             *****************************************/

            JSONObject templateJSONRepresentation = journeyTemplate.getJSONRepresentation();

            /*****************************************
             *
             * generate JSON representation of the bulk campaign
             *
             *****************************************/

            Map<String, Object> campaignJSONRepresentation = new HashMap<String, Object>(templateJSONRepresentation);

            //
            // override with bulkCampaign attributes
            //

            campaignJSONRepresentation.put("journeyTemplateID", journeyTemplateID);
            campaignJSONRepresentation.put("id", bulkCampaignID);
            campaignJSONRepresentation.put("name", bulkCampaignName);
            campaignJSONRepresentation.put("display", bulkCampaignDisplay);
            campaignJSONRepresentation.put("description", bulkCampaignDescription);
            campaignJSONRepresentation.put("effectiveStartDate", bulkCampaignEffectiveStartDate);
            campaignJSONRepresentation.put("effectiveEndDate", bulkCampaignEffectiveEndDate);
            campaignJSONRepresentation.put("targetingType", targetingType);
            campaignJSONRepresentation.put("targetID", bulkCampaignTargetIDs);
            campaignJSONRepresentation.put("boundParameters", bulkCampaignBoundParameters);
            campaignJSONRepresentation.put("appendUCG", appendUCG);
            campaignJSONRepresentation.put("appendInclusionLists", appendInclusionLists);
            campaignJSONRepresentation.put("appendExclusionLists", appendExclusionLists);
            campaignJSONRepresentation.put("userID", userIdentifier);
            campaignJSONRepresentation.put("userName", userName);
            campaignJSONRepresentation.put("active", active);
            campaignJSONRepresentation.put("journeyObjectives", bulkCampaignJourneyObjectives);
            campaignJSONRepresentation.put("story", bulkCampaignStory);
            campaignJSONRepresentation.put("priority", bulkCampaignPriority);

            if (bulkCampaignInfo != null)
              {
                campaignJSONRepresentation.put("info", bulkCampaignInfo);
              }

            campaignJSONRepresentation.put("targetingCriteria", bulkCampaignTargetCriteria);

            campaignJSONRepresentation.put("recurrence", recurrence);
            campaignJSONRepresentation.put("recurrenceId", recurrenceId);
            campaignJSONRepresentation.put("occurrenceNumber", occurrenceNumber);
            if (journeyScheduler != null)
              campaignJSONRepresentation.put("scheduler", JSONUtilities.encodeObject(journeyScheduler));
            campaignJSONRepresentation.put("lastCreatedOccurrenceNumber", lastCreatedOccurrenceNumber);

            campaignJSONRepresentation.put("targetingFileVariableID", targetingFileVariableID);
            campaignJSONRepresentation.put("targetFileVariables", targetFileVariablesJSON);


            //
            // campaignJSON
            //

            campaignJSON = JSONUtilities.encodeObject(campaignJSONRepresentation);

            /****************************************
             *
             * instantiate bulk campaign
             *
             ****************************************/

            Journey bulkCampaign = new Journey(campaignJSON, GUIManagedObjectType.BulkCampaign, epoch,
                existingBulkCampaignToBeUpdated, journeyService, catalogCharacteristicService,
                subscriberMessageTemplateService, dynamicEventDeclarationsService, journeyTemplateService, approval, tenantID);

            //
            // Update targetCount
            //
            bulkCampaign.setTargetCount(elasticsearch, uploadedFileService, tenantID);

            /*****************************************
             *
             * store
             *
             *****************************************/
            if (!dryRun)
              {

                journeyService.putJourney(bulkCampaign, journeyObjectiveService, catalogCharacteristicService,
                    targetService, subscriberMessageTemplateService, (existingBulkCampaignToBeUpdated == null), userID);
              }
            /*****************************************
             *
             * response
             *
             *****************************************/

            if (jsonRoot.containsKey("ids"))
              {
                updatedIDs.add(bulkCampaign.getJourneyID());
              }
          }
        catch (JSONUtilitiesException | GUIManagerException e)
          {
            //
            // incompleteObject
            //

            IncompleteObject incompleteObject = new IncompleteObject(campaignJSON, GUIManagedObjectType.BulkCampaign,
                epoch, tenantID);

            //
            // store
            //
            if (!dryRun)
              {
                journeyService.putJourney(incompleteObject, journeyObjectiveService, catalogCharacteristicService,
                    targetService, subscriberMessageTemplateService, (existingBulkCampaignToBeUpdated == null), userID);
              }
            //
            // log
            //

            StringWriter stackTraceWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stackTraceWriter, true));
            log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

            //
            // response
            //

            if (jsonRoot.containsKey("ids"))
              {
                HashMap<String, String> invalidProductsExceptions = new HashMap<String, String>();
                invalidProductsExceptions.put("id", incompleteObject.getGUIManagedObjectID());
                invalidProductsExceptions.put("responseCode", "bulkCampaignNotValid");
                invalidProductsExceptions.put("responseMessage", e.getMessage());
                invalidProductsExceptions.put("responseParameter",
                    (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);

                exceptionList.add(invalidProductsExceptions); // get the
                                                              // exceptions for
                                                              // multiple
                                                              // products
                updatedIDs.add(incompleteObject.getGUIManagedObjectID());

              }
          }
      }
    if (jsonRoot.containsKey("ids"))
      {
        response.put("updatedIds", updatedIDs);
        response.put("exceptionIds", exceptionList);
        response.put("responseCode", "ok");

      }

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetJourneyTemplateList
  *
  *****************************************/

  private JSONObject processGetJourneyTemplateList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert journeyTemplates
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> journeyTemplates = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> journeyTemplateObjects = new ArrayList<GUIManagedObject>();
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray journeyTemplateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < journeyTemplateIDs.size(); i++)
          {
            String journeyTemplateID = journeyTemplateIDs.get(i).toString();
            GUIManagedObject journeyTemplate = journeyTemplateService.getStoredJourneyTemplate(journeyTemplateID, includeArchived);                
            if (journeyTemplate != null && journeyTemplate.getTenantID() == tenantID)
              {
                journeyTemplateObjects.add(journeyTemplate);
              }            
          }
      }
    else
      {
        journeyTemplateObjects = journeyTemplateService.getStoredJourneyTemplates(includeArchived, tenantID);
      }
    for (GUIManagedObject journeyTemplate : journeyTemplateObjects)
      {
        switch (journeyTemplate.getGUIManagedObjectType())
          {
            case JourneyTemplate:
              journeyTemplates.add(resolveJourneyParameters(journeyTemplateService.generateResponseJSON(journeyTemplate, fullDetails, now), now, tenantID));
              break;
          }
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("journeyTemplates", JSONUtilities.encodeArray(journeyTemplates));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetJourneyTemplate
  *
  *****************************************/

  private JSONObject processGetJourneyTemplate(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String journeyTemplateID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate journeyTemplate
    *
    *****************************************/

    GUIManagedObject journeyTemplate = journeyTemplateService.getStoredJourneyTemplate(journeyTemplateID, includeArchived);
    journeyTemplate = (journeyTemplate != null && journeyTemplate.getGUIManagedObjectType() == GUIManagedObjectType.JourneyTemplate) ? journeyTemplate : null;
    JSONObject journeyTemplateJSON = resolveJourneyParameters(journeyTemplateService.generateResponseJSON(journeyTemplate, true, now), now, tenantID);

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (journeyTemplate != null) ? "ok" : "journeyTemplateNotFound");
    if (journeyTemplate != null) response.put("journeyTemplate", journeyTemplateJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutJourneyTemplate
  *
  *****************************************/

  private JSONObject processPutJourneyTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    Boolean dryRun = false;

    /*****************************************
     *
     * dryRun
     *
     *****************************************/
    if (jsonRoot.containsKey("dryRun"))
      {
        dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
      }

    /*****************************************
    *
    *  journeyTemplateID
    *
    *****************************************/

    String journeyTemplateID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (journeyTemplateID == null)
      {
        journeyTemplateID = journeyTemplateService.generateJourneyTemplateID();
        jsonRoot.put("id", journeyTemplateID);
      }

    /*****************************************
    *
    *  existing journeyTemplate
    *
    *****************************************/

    GUIManagedObject existingJourneyTemplate = journeyTemplateService.getStoredJourneyTemplate(journeyTemplateID);
    existingJourneyTemplate = (existingJourneyTemplate != null && existingJourneyTemplate.getGUIManagedObjectType() == GUIManagedObjectType.Journey) ? existingJourneyTemplate : null;

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingJourneyTemplate != null && existingJourneyTemplate.getReadOnly())
      {
        response.put("id", existingJourneyTemplate.getGUIManagedObjectID());
        response.put("accepted", existingJourneyTemplate.getAccepted());
        response.put("valid", existingJourneyTemplate.getAccepted());
        response.put("processing", journeyTemplateService.isActiveJourneyTemplate(existingJourneyTemplate, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process journeyTemplate
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate journeyTemplate
        *
        ****************************************/

        Journey journeyTemplate = new Journey(jsonRoot, GUIManagedObjectType.JourneyTemplate, epoch, existingJourneyTemplate, journeyService, catalogCharacteristicService, subscriberMessageTemplateService, dynamicEventDeclarationsService, journeyTemplateService, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            journeyTemplateService.putJourneyTemplate(journeyTemplate, journeyObjectiveService,
                catalogCharacteristicService, targetService, (existingJourneyTemplate == null), userID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", journeyTemplate.getJourneyID());
        response.put("accepted", journeyTemplate.getAccepted());
        response.put("valid", journeyTemplate.getAccepted());
        response.put("processing", journeyTemplateService.isActiveJourneyTemplate(journeyTemplate, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, GUIManagedObjectType.JourneyTemplate, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            journeyTemplateService.putJourneyTemplate(incompleteObject, journeyObjectiveService,
                catalogCharacteristicService, targetService, (existingJourneyTemplate == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("journeyTemplateID", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "journeyTemplateNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveJourneyTemplate
  *
  *****************************************/

  private JSONObject processRemoveJourneyTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    JSONArray journeyTemplateIDs = new JSONArray();
    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> journeyTemplates = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/
    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single journeyTemplate
    //
    if (jsonRoot.containsKey("id"))
      {
        String journeyTemplateID = JSONUtilities.decodeString(jsonRoot, "id", false);
        journeyTemplateIDs.add(journeyTemplateID);
        GUIManagedObject journeyTemplate = journeyService.getStoredJourney(journeyTemplateID);

        if (journeyTemplate != null && (force || !journeyTemplate.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (journeyTemplate != null)
          singleIDresponseCode = "failedReadOnly";
        else
          {
            singleIDresponseCode = "journeyTemplateNotFound";

          }
      }
    //
    // multiple deletion journeyTemplate
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        journeyTemplateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }    
       
    for (int i = 0; i < journeyTemplateIDs.size(); i++)
      {
        String journeyTemplateID = journeyTemplateIDs.get(i).toString();
        GUIManagedObject journeyTemplate = journeyService.getStoredJourney(journeyTemplateID);

        if (journeyTemplate != null && (force || !journeyTemplate.getReadOnly()))
          {
            journeyTemplates.add(journeyTemplate);
            validIDs.add(journeyTemplateID);
          }
      }

    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < journeyTemplates.size(); i++)
      {
        GUIManagedObject journeyTemplate = journeyTemplates.get(i);
        journeyTemplate = (journeyTemplate != null
            && journeyTemplate.getGUIManagedObjectType() == GUIManagedObjectType.JourneyTemplate) ? journeyTemplate
                : null;
        journeyTemplateService.removeJourneyTemplate(journeyTemplate.getGUIManagedObjectID(), userID, tenantID);
      }

        /*****************************************
         *
         * responseCode
         *
         *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedTemplateJourneyIDS", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }  
  
  /*****************************************
   *
   * processSetStatusJourneyTemplate
   *
   *****************************************/

  private JSONObject processSetStatusJourneyTemplate(String userID, JSONObject jsonRoot, int tenantID)
   {
    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray journeyTemplateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < journeyTemplateIDs.size(); i++)
      {

        String journeyTemplateID = journeyTemplateIDs.get(i).toString();
        GUIManagedObject existingElement = journeyTemplateService.getStoredJourneyTemplate(journeyTemplateID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(journeyTemplateID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate journeyTemplate
                 *
                 ****************************************/

                Journey journeyTemplate = new Journey(elementRoot, GUIManagedObjectType.JourneyTemplate, epoch,
                    existingElement, journeyService, catalogCharacteristicService, subscriberMessageTemplateService,
                    dynamicEventDeclarationsService, journeyTemplateService, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/

                journeyTemplateService.putJourneyTemplate(journeyTemplate, journeyObjectiveService,
                    catalogCharacteristicService, targetService, (existingElement == null), userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot,
                    GUIManagedObjectType.JourneyTemplate, epoch, tenantID);

                //
                // store
                //

                journeyTemplateService.putJourneyTemplate(incompleteObject, journeyObjectiveService,
                    catalogCharacteristicService, targetService, (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetJourneyNodeCount
  *
  *****************************************/

  private JSONObject processGetJourneyNodeCount(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/
    
    String journeyID = null;

    // 
    // We support "campaignID" as an entry for "journeyID" but both can not be filled at the same time
    //
    
    String campaignID = JSONUtilities.decodeString(jsonRoot, "campaignID", false);
    if (campaignID != null && campaignID != "")
      {
        journeyID = campaignID;
        Object previousValue = jsonRoot.put("journeyID", campaignID);
        if (previousValue != null) 
          {
            response.put("responseCode", RESTAPIGenericReturnCodes.MALFORMED_REQUEST.getGenericResponseMessage() + "-{both fields campaignID and journeyID must not be filled at the same time}");
            return JSONUtilities.encodeObject(response);
          }
      }
    else
      {
        journeyID = JSONUtilities.decodeString(jsonRoot, "journeyID", true);
      }
    
    /*****************************************
    *
    *  retrieve corresponding Journey 
    *
    *****************************************/
    
    Map<String,Object> result = new HashMap<String,Object>();

    //
    // only return KPIs if the journey still exist.
    //

    GUIManagedObject journey = journeyService.getStoredJourney(journeyID);
    if (journey instanceof Journey) 
      {
        Set<String> nodeIDs = ((Journey) journey).getJourneyNodes().keySet();
        
        //
        //  retrieve from Elasticsearch 
        //
         try {
          Map<String, Long> esMap = this.elasticsearch.getJourneyNodeCount(journeyID);
          for (String key : nodeIDs) {
        	  Long count = esMap.get(key);
              if(key.trim().equalsIgnoreCase(((Journey) journey).getEndNodeID().trim()) && esMap.get(key)!=null)
            	  count=esMap.get(key)-elasticsearch.getSpecialExitCount(journeyID);
              result.put(key, (count != null)? count : 0);
          }
        }
        catch (ElasticsearchClientException e) {
          // Log
          log.warn("Exception processing REST api: {}", e);
          
          // Response
          response.put("responseCode", RESTAPIGenericReturnCodes.SYSTEM_ERROR.getGenericResponseCode());
          response.put("responseMessage", e.getMessage());
          return JSONUtilities.encodeObject(response);
        }
      }
    else
      {
        response.put("responseCode", RESTAPIGenericReturnCodes.CAMPAIGN_NOT_FOUND.getGenericResponseMessage() + "-{could not find any journey (campaign) with the specified journeyID (campaignID)}");
        return JSONUtilities.encodeObject(response);
      }
    
    /*****************************************
    *
    *  response
    *
    *****************************************/
    
    response.put("responseCode", "ok");
    response.put("journeyNodeCount", JSONUtilities.encodeObject(result));
    return JSONUtilities.encodeObject(response);
  }  


  /*****************************************
  *
  *  processGetOfferList
  *
  *****************************************/

  private JSONObject processGetOfferList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert offers
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> offers = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> offerObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray offerIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < offerIDs.size(); i++)
          {
            String offerID = offerIDs.get(i).toString();
            GUIManagedObject offer = offerService.getStoredOfferWithCurrentStocks(offerID, includeArchived);
            if (offer != null && offer.getTenantID() == tenantID)
              {
                offerObjects.add(offer);
              }
          }
      }
    else
      {
        offerObjects = offerService.getStoredOffersWithCurrentStocks(includeArchived, tenantID);
      }
    for (GUIManagedObject offer : offerObjects)
      {        
        JSONObject offerJSON = offerService.generateResponseJSON(offer, fullDetails, now);
        if (!fullDetails)
          {
            if (offer.getJSONRepresentation().get("simpleOffer") != null)
              {
                offerJSON.put("simpleOffer", offer.getJSONRepresentation().get("simpleOffer"));
              }
            else
              {
                offerJSON.put("simpleOffer", "");
              }
          }
        offers.add(offerJSON);
      }
    
    if (!fullDetails)
      {
        for (JSONObject offer : offers)
          {
            if (offer.get("offerObjectives") != null)
              {
                JSONArray offerObjectives = (JSONArray) offer.get("offerObjectives");
                JSONArray offerObjectivesWithDispaly = new JSONArray();
                for (int i = 0; i < offerObjectives.size(); i++)
                  {
                    JSONObject offerObjective = (JSONObject) ((JSONObject) offerObjectives.get(i)).clone();
                    String offerObjectiveID = offerObjective.get("offerObjectiveID").toString();
                    if (offerObjectiveID != null)
                      {
                        GUIManagedObject offerObjectiveObject = offerObjectiveService.getStoredOfferObjective(offerObjectiveID);
                        if (offerObjectiveObject != null)
                          {
                            String offerObjectiveDisplay = ((OfferObjective) offerObjectiveObject).getDisplay();
                            offerObjective.put("offerObjectiveDisplay", offerObjectiveDisplay);
                            offerObjectivesWithDispaly.add(offerObjective);
                          }
                      }
                    offer.put("offerObjectives", offerObjectivesWithDispaly);
                  }
              }

          }
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("offers", JSONUtilities.encodeArray(offers));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetOffer
  *
  *****************************************/

  private JSONObject processGetOffer(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String offerID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate offer
    *
    *****************************************/

    GUIManagedObject offer = offerService.getStoredOfferWithCurrentStocks(offerID, includeArchived);
    JSONObject offerJSON = offerService.generateResponseJSON(offer, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (offer != null) ? "ok" : "offerNotFound");
    if (offer != null) response.put("offer", offerJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutOffer
  *
  *****************************************/

  private JSONObject processPutOffer(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  offerID
    *
    *****************************************/

    String offerID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (offerID == null)
      {
        offerID = offerService.generateOfferID();
        jsonRoot.put("id", offerID);
      }

    /*****************************************
    *
    *  existing offer
    *
    *****************************************/

    GUIManagedObject existingOffer = offerService.getStoredOffer(offerID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingOffer != null && existingOffer.getReadOnly())
      {
        response.put("id", existingOffer.getGUIManagedObjectID());
        response.put("accepted", existingOffer.getAccepted());
        response.put("valid", existingOffer.getAccepted());
        response.put("processing", offerService.isActiveOffer(existingOffer, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process offer
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate offer
        *
        ****************************************/
        if (existingOffer == null) {
        jsonRoot.put("simpleOffer", false); // offer not a simpleOffer
        }
        
        if (existingOffer != null) {
            if (existingOffer instanceof Offer)
              {
                if (((Offer) existingOffer).getSimpleOffer() == true)
                  {
                    String display = ((Offer) existingOffer).getGUIManagedObjectDisplay();
                    Set<OfferProduct> offerProducts = ((Offer) existingOffer).getOfferProducts();
                    Set<OfferVoucher> offerVouchers = ((Offer) existingOffer).getOfferVouchers();
                    String jsonRootDisplay = JSONUtilities.decodeString(jsonRoot, "display", false);
                    if (!(jsonRootDisplay.equals(display)))
                      {
                        response.put("responseCode", "offerNotValid");
                        response.put("responseMessage", "The display cannot be changed for the existing simpleOffer");
                        return JSONUtilities.encodeObject(response);
                      }
                    else if (offerProducts != null && !(offerProducts).isEmpty())
                      {
                        OfferProduct offerProduct = offerProducts.stream().findFirst().get(); // simple offer can have only one product
                                                                                              
                        OfferProduct jsonRootOfferProduct = null;
                        JSONArray jsonRootOfferProducts = JSONUtilities.decodeJSONArray(jsonRoot, "products", false);
                        JSONObject jsonRootofferProduct = new JSONObject();
                        if (jsonRootOfferProducts != null)
                          {
                            jsonRootofferProduct = (JSONObject) jsonRootOfferProducts.get(0); // simple offer can have only one product
                                                                                              
                          }
                        if (jsonRootOfferProducts == null || (jsonRootOfferProducts != null
                            && (!(offerProduct.getProductID().equals(jsonRootofferProduct.get("productID").toString()))
                                || (offerProduct.getQuantity() != ((Number) jsonRootofferProduct.get("quantity"))
                                    .intValue()))))
                          {
                            response.put("responseCode", "offerNotValid");
                            response.put("responseMessage",
                                "The product cannot be changed for the existing simpleOffer");
                            return JSONUtilities.encodeObject(response);
                          }
                      }
                    else if (offerVouchers != null && !(offerVouchers).isEmpty())
                      {
                        OfferVoucher offerVoucher = offerVouchers.stream().findFirst().get(); // simple offer can have only one voucher
                                                                                             
                        JSONArray jsonRootOfferVouchers = JSONUtilities.decodeJSONArray(jsonRoot, "vouchers", false);
                        JSONObject jsonRootofferVoucher = new JSONObject();
                        if (jsonRootOfferVouchers != null)
                          {
                            jsonRootofferVoucher = (JSONObject) jsonRootOfferVouchers.get(0); //simple offer can have only one vouche
                          }
                        if (jsonRootOfferVouchers == null || (jsonRootOfferVouchers != null
                            && (!(offerVoucher.getVoucherID().equals(jsonRootofferVoucher.get("voucherID").toString()))
                                || (offerVoucher.getQuantity() != ((Number) jsonRootofferVoucher.get("quantity"))
                                    .intValue()))))
                          {
                            response.put("responseCode", "offerNotValid");
                            response.put("responseMessage",
                                "The voucher cannot be changed for the existing simpleOffer");
                            return JSONUtilities.encodeObject(response);
                          }
                      }
                    else
                      {
                        jsonRoot.put("simpleOffer", true);
                      }

                  }
                else
                  {
                    jsonRoot.put("simpleOffer", false);
                  }

              }
          
        
        }
        Offer offer = new Offer(jsonRoot, epoch, existingOffer, catalogCharacteristicService, tenantID);

        // if stock update, and no more stock, need to warn it
        String responseMessage = null;
        if(existingOffer instanceof Offer && !Objects.equals(((Offer) existingOffer).getStock(),offer.getStock()) && StockMonitor.getRemainingStock(offer)==0) responseMessage = "no remaining stock";

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            offerService.putOffer(offer, callingChannelService, salesChannelService, productService, voucherService,
                (existingOffer == null), userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", offer.getOfferID());
        response.put("accepted", offer.getAccepted());
        response.put("valid", offer.getAccepted());
        response.put("processing", offerService.isActiveOffer(offer, now));
        response.put("responseCode", "ok");
		if(responseMessage!=null) response.put("responseMessage",responseMessage);
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            offerService.putOffer(incompleteObject, callingChannelService, salesChannelService, productService,
                voucherService, (existingOffer == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "offerNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveOffer
  *
  *****************************************/

  private JSONObject processRemoveOffer(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> offers = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray offerIDs = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single offer
    //
    if (jsonRoot.containsKey("id"))
      {
        String offerID = JSONUtilities.decodeString(jsonRoot, "id", false);
        offerIDs.add(offerID);
        GUIManagedObject offer = offerService.getStoredOffer(offerID);
        if (offer != null && (force || !offer.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (offer != null)
          singleIDresponseCode = "failedReadOnly";
        else
          {
            singleIDresponseCode = "offerNotFound";

          }
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        offerIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
    
    for (int i = 0; i < offerIDs.size(); i++)
      {
        String offerID = offerIDs.get(i).toString();
        GUIManagedObject offer = offerService.getStoredOffer(offerID);

        if (offer != null && (force || !offer.getReadOnly()))
          {

            offers.add(offer);
            validIDs.add(offerID);
          }
      }
        

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < offers.size(); i++)
      {
        GUIManagedObject offer = offers.get(i);

        offerService.removeOffer(offer.getGUIManagedObjectID(), userID, tenantID);
      }

    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/

    response.put("removedOfferIDs", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }
  

  /*****************************************
  *
  *  processUpdateOffer
  *
  *****************************************/

  private JSONObject processUpdateOffer(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    Boolean dryRun = false;
    JSONArray offerIDs = new JSONArray();
    List<GUIManagedObject> existingOffers = new ArrayList();
    List<String> updatedIDs = new ArrayList();
    List<Object> exceptionList= new ArrayList();

    /*****************************************
     *
     * dryRun
     *
     *****************************************/
    if (jsonRoot.containsKey("dryRun"))
      {
        dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
      }

    /*****************************************
     *
     * update product
     *
     *****************************************/

    if (jsonRoot.containsKey("ids"))
      {
        offerIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false); // update for multiple offer
      }
    else
      {
        response.put("responseCode", "invalidOffer");
        response.put("responseMessage", "offer ID is empty");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
     *
     * existing offers
     *
     *****************************************/
    for (int i = 0; i < offerIDs.size(); i++)
      {
        String offerID = (offerIDs.get(i)).toString();
        GUIManagedObject existingOfferObject = offerService.getStoredOffer(offerID);
        if (existingOfferObject != null)
          {
            existingOffers.add(existingOfferObject); //ignore the wrong offerIDs
          }
      }

    if (existingOffers == null || existingOffers.isEmpty())
      {
        response.put("responseCode", "invalidOffers");
        response.put("responseMessage", "offers does not exist");
        return JSONUtilities.encodeObject(response);
      }

    for (GUIManagedObject existingOfferToBeUpdated : existingOffers)
      {
        JSONObject JSONToBeUpdated = new JSONObject();
        Set<String> JsonRootkeySets = jsonRoot.keySet();
        if (existingOfferToBeUpdated instanceof Offer)
          {
            if (((Offer) existingOfferToBeUpdated).getSimpleOffer() == true)
              {
                if (jsonRoot.containsKey("display"))
                  {
                    HashMap<String, String> errorResponseDisplay = new HashMap<String, String>();
                    errorResponseDisplay.put("id", existingOfferToBeUpdated.getGUIManagedObjectID());
                    errorResponseDisplay.put("responseCode", "Invalid display");
                    errorResponseDisplay.put("responseMessage",
                        "The display cannot be changed for the existing simple offer");
                    exceptionList.add(errorResponseDisplay);
                    continue;

                  }
                if (jsonRoot.containsKey("simpleOffer"))
                  {
                    HashMap<String, String> errorResponseSimpleOffer = new HashMap<String, String>();
                    boolean simpleOffer = JSONUtilities.decodeBoolean(jsonRoot, "simpleOffer", false);
                    if (!simpleOffer)
                      {
                        errorResponseSimpleOffer.put("id", existingOfferToBeUpdated.getGUIManagedObjectID());
                        errorResponseSimpleOffer.put("responseCode", "Invalid Offer");
                        errorResponseSimpleOffer.put("responseMessage",
                            "The simple Offer cannot be changed for the existing simple offer");
                        exceptionList.add(errorResponseSimpleOffer);
                        continue;
                      }
                  }
                if (jsonRoot.containsKey("products"))
                  {
                    HashMap<String, String> errorResponseProduct = new HashMap<String, String>();
                    errorResponseProduct.put("id", existingOfferToBeUpdated.getGUIManagedObjectID());
                    errorResponseProduct.put("responseCode", "Invalid Offer product");
                    errorResponseProduct.put("responseMessage",
                        "The products cannot be changed for the existing simple offer");
                    exceptionList.add(errorResponseProduct);
                    continue;
                  }
                if (jsonRoot.containsKey("vouchers"))
                  {
                    HashMap<String, String> errorResponseVoucher = new HashMap<String, String>();
                    errorResponseVoucher.put("id", existingOfferToBeUpdated.getGUIManagedObjectID());
                    errorResponseVoucher.put("responseCode", "Invalid Offer voucher");
                    errorResponseVoucher.put("responseMessage",
                        "The vouchers cannot be changed for the existing simple offer");
                    exceptionList.add(errorResponseVoucher);
                    continue;

                  }
              }
          }
        JSONObject existingOfferObject = existingOfferToBeUpdated.getJSONRepresentation();
        for (String JsonRootkey : JsonRootkeySets)
          {
            JSONToBeUpdated.put(JsonRootkey, jsonRoot.get(JsonRootkey));  // get the part of GUI object which need to be updated from jsonRoot
          }
        JSONToBeUpdated.put("id", existingOfferToBeUpdated.getGUIManagedObjectID());
        for (Object keyObject : existingOfferObject.keySet())
          {
            String key = keyObject.toString();
            if (key != null && ((!(JsonRootkeySets.contains(key)))))
              {
                JSONToBeUpdated.put(key, existingOfferObject.get(key));
              }

          }

        /*****************************************
         *
         * process offer
         *
         *****************************************/

        long epoch = epochServer.getKey();
        try
          {
            /****************************************
            *
            *  instantiate offer
            *
            ****************************************/
            if (JSONToBeUpdated.containsKey("id"))
              {
                JSONToBeUpdated.remove("ids");
              }
            Offer offer = new Offer(JSONToBeUpdated, epoch, existingOfferToBeUpdated, catalogCharacteristicService, tenantID);

            /*****************************************
            *
            *  store
            *
            *****************************************/
            if (!dryRun)
              {

                offerService.putOffer(offer, callingChannelService, salesChannelService, productService, voucherService,
                    (existingOfferToBeUpdated == null), userID);
              }

            /*****************************************
             *
             * response
             *
             *****************************************/

            if (jsonRoot.containsKey("ids")) {
              updatedIDs.add(offer.getOfferID());
            }
          }

        catch (JSONUtilitiesException | GUIManagerException e)
          {
            //
            // incompleteObject
            //

            //
            //  incompleteObject
            //

            IncompleteObject incompleteObject = new IncompleteObject(JSONToBeUpdated, epoch, tenantID);

            //
            //  store
            //
            if (!dryRun)
              {
                offerService.putOffer(incompleteObject, callingChannelService, salesChannelService, productService,
                    voucherService, (existingOfferToBeUpdated == null), userID);
              }
            //
            //  log
            //

            StringWriter stackTraceWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stackTraceWriter, true));
            log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

            // response
            //

            if (jsonRoot.containsKey("ids"))
              {
                updatedIDs.add(incompleteObject.getGUIManagedObjectID());
                HashMap<String, String> invalidOfferExceptions = new HashMap<String, String>();
                invalidOfferExceptions.put("id", incompleteObject.getGUIManagedObjectID());
                invalidOfferExceptions.put("responseCode", "OfferNotValid");
                invalidOfferExceptions.put("responseMessage", e.getMessage());
                invalidOfferExceptions.put("responseParameter",
                    (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);

                exceptionList.add(invalidOfferExceptions); //get the exceptions for multiple offers

              }

          }
      }
    if (jsonRoot.containsKey("ids")) {
      response.put("updatedIds", updatedIDs);
      response.put("exceptionIds", exceptionList);
      response.put("responseCode", "ok");

    }

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
   *
   * processSetStatusOffer
   *
   *****************************************/

  private JSONObject processSetStatusOffer(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray offerIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < offerIDs.size(); i++)
      {

        String offerID = offerIDs.get(i).toString();
        GUIManagedObject existingElement = offerService.getStoredOffer(offerID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(offerID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);

            try
              {
                /****************************************
                 *
                 * instantiate offer
                 *
                 ****************************************/

                Offer offer = new Offer(elementRoot, epoch, existingElement, catalogCharacteristicService, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/

                offerService.putOffer(offer, callingChannelService, salesChannelService, productService, voucherService,
                    (existingElement == null), userID);
              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                offerService.putOffer(incompleteObject, callingChannelService, salesChannelService, productService,
                    voucherService, (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }


  /*****************************************
  *
  *  processGetPresentationStrategyList
  *
  *****************************************/

  private JSONObject processGetPresentationStrategyList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert presentationStrategies
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> presentationStrategies = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> presentationStrategieObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray presentationStrategieIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < presentationStrategieIDs.size(); i++)
          {
            String presentationStrategieID = presentationStrategieIDs.get(i).toString();
            GUIManagedObject presentationStrategie = presentationStrategyService.getStoredPresentationStrategy(presentationStrategieID, includeArchived);
            if (presentationStrategie != null && presentationStrategie.getTenantID() == tenantID)
              {
                presentationStrategieObjects.add(presentationStrategie);
              }
          }
      }
    else
      {
        presentationStrategieObjects = presentationStrategyService.getStoredPresentationStrategies(includeArchived, tenantID);
      }
    for (GUIManagedObject presentationStrategy : presentationStrategieObjects)
      {
        presentationStrategies.add(presentationStrategyService.generateResponseJSON(presentationStrategy, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("presentationStrategies", JSONUtilities.encodeArray(presentationStrategies));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetPresentationStrategy
  *
  *****************************************/

  private JSONObject processGetPresentationStrategy(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String presentationStrategyID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate presentation strategy
    *
    *****************************************/

    GUIManagedObject presentationStrategy = presentationStrategyService.getStoredPresentationStrategy(presentationStrategyID, includeArchived);
    JSONObject presentationStrategyJSON = presentationStrategyService.generateResponseJSON(presentationStrategy, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (presentationStrategy != null) ? "ok" : "presentationStrategyNotFound");
    if (presentationStrategy != null) response.put("presentationStrategy", presentationStrategyJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutPresentationStrategy
  *
  *****************************************/

  private JSONObject processPutPresentationStrategy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  presentationStrategyID
    *
    *****************************************/

    String presentationStrategyID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (presentationStrategyID == null)
      {
        presentationStrategyID = presentationStrategyService.generatePresentationStrategyID();
        jsonRoot.put("id", presentationStrategyID);
      }

    /*****************************************
    *
    *  existing presentationStrategy
    *
    *****************************************/

    GUIManagedObject existingPresentationStrategy = presentationStrategyService.getStoredPresentationStrategy(presentationStrategyID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingPresentationStrategy != null && existingPresentationStrategy.getReadOnly())
      {
        response.put("id", existingPresentationStrategy.getGUIManagedObjectID());
        response.put("accepted", existingPresentationStrategy.getAccepted());
        response.put("valid", existingPresentationStrategy.getAccepted());
        response.put("processing", presentationStrategyService.isActivePresentationStrategy(existingPresentationStrategy, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process presentationStrategy
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate presentationStrategy
        *
        ****************************************/

        PresentationStrategy presentationStrategy = new PresentationStrategy(jsonRoot, epoch, existingPresentationStrategy, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            presentationStrategyService.putPresentationStrategy(presentationStrategy, scoringStrategyService,
                (existingPresentationStrategy == null), userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", presentationStrategy.getPresentationStrategyID());
        response.put("accepted", presentationStrategy.getAccepted());
        response.put("valid", presentationStrategy.getAccepted());
        response.put("processing", presentationStrategyService.isActivePresentationStrategy(presentationStrategy, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            presentationStrategyService.putPresentationStrategy(incompleteObject, scoringStrategyService,
                (existingPresentationStrategy == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "presentationStrategyNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemovePresentationStrategy
  *
  *****************************************/

  private JSONObject processRemovePresentationStrategy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> presentationStrategies = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray presentationStrategyIDs = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single presentationStrategy
    //
    if (jsonRoot.containsKey("id"))
      {
        String presentationStrategyID = JSONUtilities.decodeString(jsonRoot, "id", false);
        presentationStrategyIDs.add(presentationStrategyID);
        GUIManagedObject presentationStrategy = presentationStrategyService
            .getStoredPresentationStrategy(presentationStrategyID);
        if (presentationStrategy != null && (force || !presentationStrategy.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (presentationStrategy != null)
          singleIDresponseCode = "failedReadOnly";
        else
          singleIDresponseCode = "presentationStrategyNotFound";

      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        presentationStrategyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < presentationStrategyIDs.size(); i++)
      {
        String presentationStrategyID = presentationStrategyIDs.get(i).toString();
        GUIManagedObject presentationStrategy = presentationStrategyService
            .getStoredPresentationStrategy(presentationStrategyID);

        if (presentationStrategy != null && (force || !presentationStrategy.getReadOnly()))
          {

            presentationStrategies.add(presentationStrategy);
            validIDs.add(presentationStrategyID);
          }
      }
        

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < presentationStrategies.size(); i++)
      {
        GUIManagedObject presentationStrategy = presentationStrategies.get(i);
        presentationStrategyService.removePresentationStrategy(presentationStrategy.getGUIManagedObjectID(), userID, tenantID);
      }
    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    response.put("removedPresentationStrategyIDs", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusPresentationStrategy
   *
   *****************************************/

  private JSONObject processSetStatusPresentationStrategy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray presentationStrategyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < presentationStrategyIDs.size(); i++)
      {
        String presentationStrategyID = presentationStrategyIDs.get(i).toString();
        GUIManagedObject existingElement = presentationStrategyService
            .getStoredPresentationStrategy(presentationStrategyID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(presentationStrategyID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);

            try
              {
                /****************************************
                 *
                 * instantiate presentationStrategy
                 *
                 ****************************************/

                PresentationStrategy presentationStrategy = new PresentationStrategy(elementRoot, epoch,
                    existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/

                presentationStrategyService.putPresentationStrategy(presentationStrategy, scoringStrategyService,
                    (existingElement == null), userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                presentationStrategyService.putPresentationStrategy(incompleteObject, scoringStrategyService,
                    (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  
  /*****************************************
  *
  *  processGetDNBOMatrixList
  *
  *****************************************/

  private JSONObject processGetDNBOMatrixList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert DNBOMatrixList
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> dnboMatrixes = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> dnboMatrixeObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray dnboMatrixeIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < dnboMatrixeIDs.size(); i++)
          {
            String dnboMatrixeID = dnboMatrixeIDs.get(i).toString();
            GUIManagedObject dnboMatrixe = dnboMatrixService.getStoredDNBOMatrix(dnboMatrixeID, includeArchived);
            if (dnboMatrixe != null && dnboMatrixe.getTenantID() == tenantID)
              {
                dnboMatrixeObjects.add(dnboMatrixe);
              }
          }
      }
    else
      {
        dnboMatrixeObjects = dnboMatrixService.getStoredDNBOMatrixes(includeArchived, tenantID);
      }
    for (GUIManagedObject dnboMatrix : dnboMatrixeObjects)
      {
        dnboMatrixes.add(presentationStrategyService.generateResponseJSON(dnboMatrix, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("dnboMatrixes", JSONUtilities.encodeArray(dnboMatrixes));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetDNBOMatrix
  *
  *****************************************/

  private JSONObject processGetDNBOMatrix(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String dnboMatrixID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate DNBOMatrix
    *
    *****************************************/

    GUIManagedObject dnboMatrix = dnboMatrixService.getStoredDNBOMatrix(dnboMatrixID, includeArchived);
    JSONObject dnboMatrixJSON = dnboMatrixService.generateResponseJSON(dnboMatrix, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (dnboMatrix != null) ? "ok" : "dnboMatrixNotFound");
    if (dnboMatrix != null) response.put("dnboMatrix", dnboMatrixJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutDNBOMatrix
  *
  *****************************************/

  private JSONObject processPutDNBOMatrix(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  dnboMatrixID
    *
    *****************************************/

    String dnboMatrixID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (dnboMatrixID == null)
      {
        dnboMatrixID = dnboMatrixService.generateDNBOMatrixID();
        jsonRoot.put("id", dnboMatrixID);
      }

    /*****************************************
    *
    *  existing dnboMatrix
    *
    *****************************************/

    GUIManagedObject existingDNBOMatrix = dnboMatrixService.getStoredDNBOMatrix(dnboMatrixID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingDNBOMatrix != null && existingDNBOMatrix.getReadOnly())
      {
        response.put("id", existingDNBOMatrix.getGUIManagedObjectID());
        response.put("accepted", existingDNBOMatrix.getAccepted());
        response.put("valid", existingDNBOMatrix.getAccepted());
        response.put("processing", dnboMatrixService.isActiveDNBOMatrix(existingDNBOMatrix, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process dnboMatrix
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate DNBOMatrix
        *
        ****************************************/

        DNBOMatrix dnboMatrix = new DNBOMatrix(jsonRoot, epoch, existingDNBOMatrix, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {
            dnboMatrixService.putDNBOMatrix(dnboMatrix, (existingDNBOMatrix == null), userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", dnboMatrix.getGUIManagedObjectID());
        response.put("accepted", dnboMatrix.getAccepted());
        response.put("valid", dnboMatrix.getAccepted());
        response.put("processing", dnboMatrixService.isActiveDNBOMatrix(dnboMatrix, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            dnboMatrixService.putDNBOMatrix(incompleteObject, (existingDNBOMatrix == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "dnboMatrixNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveDNBOMatrix
  *
  *****************************************/

  private JSONObject processRemoveDNBOMatrix(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> dnboMatrixs = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray dnboMatrixIDs = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single dnboMatrix
    //
    if (jsonRoot.containsKey("id"))
      {
        String dnboMatrixID = JSONUtilities.decodeString(jsonRoot, "id", false);
        dnboMatrixIDs.add(dnboMatrixID);
        GUIManagedObject dnboMatrix = dnboMatrixService.getStoredDNBOMatrix(dnboMatrixID);
        if (dnboMatrix != null && (force || !dnboMatrix.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (dnboMatrix != null)
          singleIDresponseCode = "failedReadOnly";
        else

          singleIDresponseCode = "dnboMatrixNotFound";

      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        dnboMatrixIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
    

    for (int i = 0; i < dnboMatrixIDs.size(); i++)
      {
        String dnboMatrixID = dnboMatrixIDs.get(i).toString();
        GUIManagedObject dnboMatrix = dnboMatrixService.getStoredDNBOMatrix(dnboMatrixID);

        if (dnboMatrix != null && (force || !dnboMatrix.getReadOnly()))
          {
            dnboMatrixs.add(dnboMatrix);
            validIDs.add(dnboMatrixID);
          }
      }
        
  

    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < dnboMatrixs.size(); i++)
      {
        GUIManagedObject dnboMatrix = dnboMatrixs.get(i);
        dnboMatrixService.removeDNBOMatrix(dnboMatrix.getGUIManagedObjectID(), userID, tenantID);
      }
                   

        /*****************************************
         *
         * responseCode
         *
         *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    response.put("removeddnboMatrixIDS", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusDNBOMatrix
   *
   *****************************************/

  private JSONObject processSetStatusDNBOMatrix(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray DNBOMatrixIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < DNBOMatrixIDs.size(); i++)
      {

        String dnboMatrixID = DNBOMatrixIDs.get(i).toString();
        GUIManagedObject existingElement = dnboMatrixService.getStoredDNBOMatrix(dnboMatrixID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(dnboMatrixID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate DNBOMatrix
                 *
                 ****************************************/

                DNBOMatrix dnboMatrix = new DNBOMatrix(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                dnboMatrixService.putDNBOMatrix(dnboMatrix, (existingElement == null), userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //
                dnboMatrixService.putDNBOMatrix(incompleteObject, (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }


  /*****************************************
  *
  *  processGetScoringStrategyList
  *
  *****************************************/

  private JSONObject processGetScoringStrategyList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert scoringStrategies
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> scoringStrategies = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> scoringStrategyObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray scoringStrategyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < scoringStrategyIDs.size(); i++)
          {
            String scoringStrategyID = scoringStrategyIDs.get(i).toString();
            GUIManagedObject scoringStrategy = scoringStrategyService.getStoredScoringStrategy(scoringStrategyID, includeArchived);
            if (scoringStrategy != null && scoringStrategy.getTenantID() == tenantID)
              {
                scoringStrategyObjects.add(scoringStrategy);
              }
          }
      }
    else
      {
        scoringStrategyObjects = scoringStrategyService.getStoredScoringStrategies(includeArchived, tenantID);
      }
    for (GUIManagedObject scoringStrategy : scoringStrategyObjects)
      {
        scoringStrategies.add(scoringStrategyService.generateResponseJSON(scoringStrategy, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("scoringStrategies", JSONUtilities.encodeArray(scoringStrategies));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetScoringStrategy
  *
  *****************************************/

  private JSONObject processGetScoringStrategy(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String scoringStrategyID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject scoringStrategy = scoringStrategyService.getStoredScoringStrategy(scoringStrategyID, includeArchived);
    JSONObject scoringStrategyJSON = scoringStrategyService.generateResponseJSON(scoringStrategy, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (scoringStrategy != null) ? "ok" : "scoringStrategyNotFound");
    if (scoringStrategy != null) response.put("scoringStrategy", scoringStrategyJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutScoringStrategy
  *
  *****************************************/

  private JSONObject processPutScoringStrategy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    *  scoringStrategyID
    *
    *****************************************/

    String scoringStrategyID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (scoringStrategyID == null)
      {
        scoringStrategyID = scoringStrategyService.generateScoringStrategyID();
        jsonRoot.put("id", scoringStrategyID);
      }

    /*****************************************
    *
    *  existing scoringStrategy
    *
    *****************************************/

    GUIManagedObject existingScoringStrategy = scoringStrategyService.getStoredScoringStrategy(scoringStrategyID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingScoringStrategy != null && existingScoringStrategy.getReadOnly())
      {
        response.put("id", existingScoringStrategy.getGUIManagedObjectID());
        response.put("accepted", existingScoringStrategy.getAccepted());
        response.put("valid", existingScoringStrategy.getAccepted());
        response.put("processing", scoringStrategyService.isActiveScoringStrategy(existingScoringStrategy, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process scoringStrategy
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate scoringStrategy
        *
        ****************************************/

        ScoringStrategy scoringStrategy = new ScoringStrategy(jsonRoot, epoch, existingScoringStrategy, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {
            scoringStrategyService.putScoringStrategy(scoringStrategy, (existingScoringStrategy == null), userID);

            /*****************************************
             *
             * revalidatePresentationStrategies
             *
             *****************************************/

            revalidatePresentationStrategies(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", scoringStrategy.getScoringStrategyID());
        response.put("accepted", scoringStrategy.getAccepted());
        response.put("valid", scoringStrategy.getAccepted());
        response.put("processing", scoringStrategyService.isActiveScoringStrategy(scoringStrategy, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            scoringStrategyService.putScoringStrategy(incompleteObject, (existingScoringStrategy == null), userID);
          }
        //
        //  revalidatePresentationStrategies
        //

        revalidatePresentationStrategies(now, tenantID);

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "scoringStrategyNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveScoringStrategy
  *
  *****************************************/

  private JSONObject processRemoveScoringStrategy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> scoringStrategies = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray scoringStrategyIDs = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single scoring strategy
    //
    if (jsonRoot.containsKey("id"))
      {
        String scoringStrategyID = JSONUtilities.decodeString(jsonRoot, "id", false);
        scoringStrategyIDs.add(scoringStrategyID);
        GUIManagedObject scoringStrategy = scoringStrategyService.getStoredScoringStrategy(scoringStrategyID);
        if (scoringStrategy != null && (force || !scoringStrategy.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (scoringStrategy != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "scoringStrategyNotFound";

      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        scoringStrategyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < scoringStrategyIDs.size(); i++)
      {
        String scoringStrategyID = scoringStrategyIDs.get(i).toString();
        GUIManagedObject scoringStrategy = scoringStrategyService.getStoredScoringStrategy(scoringStrategyID);
        if (scoringStrategy != null && (force || !scoringStrategy.getReadOnly()))
          {
            scoringStrategies.add(scoringStrategy);
            validIDs.add(scoringStrategyID);
          }

      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < scoringStrategies.size(); i++)
      {

        GUIManagedObject scoringStrategy = scoringStrategies.get(i);
        scoringStrategyService.removeScoringStrategy(scoringStrategy.getGUIManagedObjectID(), userID, tenantID);

        /*****************************************
         *
         * revalidatePresentationStrategies
         *
         *****************************************/

        revalidatePresentationStrategies(now, tenantID);
      }

    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {

        response.put("responseCode", "ok");
      }
    response.put("removedScoringStrategyIDS", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusScoringStrategy
   *
   *****************************************/

  private JSONObject processSetStatusScoringStrategy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/
    HashMap<String, Object> response = new HashMap<String, Object>();
    Date now = SystemTime.getCurrentTime();
    JSONArray scoringStrategyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < scoringStrategyIDs.size(); i++)
      {

        String scoringStrategyID = scoringStrategyIDs.get(i).toString();
        GUIManagedObject existingElement = scoringStrategyService.getStoredScoringStrategy(scoringStrategyID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(scoringStrategyID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);

            try
              {
                /****************************************
                 *
                 * instantiate scoringStrategy
                 *
                 ****************************************/

                ScoringStrategy scoringStrategy = new ScoringStrategy(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                scoringStrategyService.putScoringStrategy(scoringStrategy, (existingElement == null), userID);

                /*****************************************
                 *
                 * revalidatePresentationStrategies
                 *
                 *****************************************/

                revalidatePresentationStrategies(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                scoringStrategyService.putScoringStrategy(incompleteObject, (existingElement == null), userID);

                //
                // revalidatePresentationStrategies
                //

                revalidatePresentationStrategies(now, tenantID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }


  /*****************************************
  *
  *  processGetCallingChannelList
  *
  *****************************************/

  private JSONObject processGetCallingChannelList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert callingChannels
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> callingChannels = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> callingChannelObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray callingChannelIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < callingChannelIDs.size(); i++)
          {
            String callingChannelID = callingChannelIDs.get(i).toString();
            GUIManagedObject callingChannel = callingChannelService.getStoredCallingChannel(callingChannelID, includeArchived);
            if (callingChannel != null && callingChannel.getTenantID() == tenantID)
              {
                callingChannelObjects.add(callingChannel);
              }
          }
      }
    else
      {
        callingChannelObjects = callingChannelService.getStoredCallingChannels(includeArchived, tenantID);
      }
    for (GUIManagedObject callingChannel : callingChannelObjects)
      {
        callingChannels.add(callingChannelService.generateResponseJSON(callingChannel, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("callingChannels", JSONUtilities.encodeArray(callingChannels));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetCallingChannel
  *
  *****************************************/

  private JSONObject processGetCallingChannel(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String callingChannelID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject callingChannel = callingChannelService.getStoredCallingChannel(callingChannelID, includeArchived);
    JSONObject callingChannelJSON = callingChannelService.generateResponseJSON(callingChannel, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (callingChannel != null) ? "ok" : "callingChannelNotFound");
    if (callingChannel != null) response.put("callingChannel", callingChannelJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutCallingChannel
  *
  *****************************************/

  private JSONObject processPutCallingChannel(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    *  callingChannelID
    *
    *****************************************/

    String callingChannelID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (callingChannelID == null)
      {
        callingChannelID = callingChannelService.generateCallingChannelID();
        jsonRoot.put("id", callingChannelID);
      }

    /*****************************************
    *
    *  existing callingChannel
    *
    *****************************************/

    GUIManagedObject existingCallingChannel = callingChannelService.getStoredCallingChannel(callingChannelID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingCallingChannel != null && existingCallingChannel.getReadOnly())
      {
        response.put("id", existingCallingChannel.getGUIManagedObjectID());
        response.put("accepted", existingCallingChannel.getAccepted());
        response.put("valid", existingCallingChannel.getAccepted());
        response.put("processing", callingChannelService.isActiveCallingChannel(existingCallingChannel, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process callingChannel
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate callingChannel
        *
        ****************************************/

        CallingChannel callingChannel = new CallingChannel(jsonRoot, epoch, existingCallingChannel, tenantID);

        /*****************************************
         *
         * store
         *
         *****************************************/
        if (!dryRun)
          {
            callingChannelService.putCallingChannel(callingChannel, (existingCallingChannel == null), userID);

            /*****************************************
             *
             * revalidateOffers
             *
             *****************************************/

            revalidateSalesChannels(now, tenantID);
            revalidateOffers(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", callingChannel.getCallingChannelID());
        response.put("accepted", callingChannel.getAccepted());
        response.put("valid", callingChannel.getAccepted());
        response.put("processing", callingChannelService.isActiveCallingChannel(callingChannel, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {

            callingChannelService.putCallingChannel(incompleteObject, (existingCallingChannel == null), userID);

            //
            // revalidateOffers
            //

            revalidateSalesChannels(now, tenantID);
            revalidateOffers(now, tenantID);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "callingChannelNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveCallingChannel
  *
  *****************************************/

  private JSONObject processRemoveCallingChannel(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> callingChannels = new ArrayList<>();
    JSONArray callingChannelIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single callingChannel
    //
    if (jsonRoot.containsKey("id"))
      {
        String callingChannelID = JSONUtilities.decodeString(jsonRoot, "id", false);
        callingChannelIDs.add(callingChannelID);
        GUIManagedObject callingChannel = callingChannelService.getStoredCallingChannel(callingChannelID);

        if (callingChannel != null && (force || !callingChannel.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (callingChannel != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "callingChannelNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        callingChannelIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
    
    for (int i = 0; i < callingChannelIDs.size(); i++)
      {
        String callingChannelID = callingChannelIDs.get(i).toString();
        GUIManagedObject callingChannel = callingChannelService.getStoredCallingChannel(callingChannelID);

        if (callingChannel != null && (force || !callingChannel.getReadOnly()))
          {
            callingChannels.add(callingChannel);
            validIDs.add(callingChannelID);
          }
      }
        
  
    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < callingChannels.size(); i++)
      {
        GUIManagedObject callingChannel = callingChannels.get(i);
        callingChannelService.removeCallingChannel(callingChannel.getGUIManagedObjectID(), userID, tenantID);

        /*****************************************
         *
         * revalidateOffers
         *
         *****************************************/

        revalidateSalesChannels(now, tenantID);
        revalidateOffers(now, tenantID);
      }

    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedcallingChannelIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusCallingChannel
   *
   *****************************************/

  private JSONObject processSetStatusCallingChannel(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray callingChannelIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < callingChannelIDs.size(); i++)
      {

        String callingChannelID = callingChannelIDs.get(i).toString();
        GUIManagedObject existingElement = callingChannelService.getStoredCallingChannel(callingChannelID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(callingChannelID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate callingChannel
                 *
                 ****************************************/

                CallingChannel callingChannel = new CallingChannel(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                callingChannelService.putCallingChannel(callingChannel, (existingElement == null), userID);

                /*****************************************
                 *
                 * revalidateOffers
                 *
                 *****************************************/

                revalidateSalesChannels(now, tenantID);
                revalidateOffers(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                callingChannelService.putCallingChannel(incompleteObject, (existingElement == null), userID);

                //
                // revalidateOffers
                //

                revalidateSalesChannels(now, tenantID);
                revalidateOffers(now, tenantID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }
              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }
  
  /*********************************************
  *
  *  processGetCriterionFieldAvailableValuesList
  *
  *********************************************/

  private JSONObject processGetCriterionFieldAvailableValuesList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert CriterionFieldAvailableValues
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> criterionFieldAvailableValuesList = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> criterionFieldAvailableValueObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray criterionFieldAvailableValueIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < criterionFieldAvailableValueIDs.size(); i++)
          {
            String criterionFieldAvailableValueID = criterionFieldAvailableValueIDs.get(i).toString();
            GUIManagedObject criterionFieldAvailableValue = criterionFieldAvailableValuesService
                .getStoredCriterionFieldAvailableValues(criterionFieldAvailableValueID, includeArchived);
            if (criterionFieldAvailableValue != null && criterionFieldAvailableValue.getTenantID() == tenantID)
              {
                criterionFieldAvailableValueObjects.add(criterionFieldAvailableValue);

              }
          }
      }
    else
      {
        criterionFieldAvailableValueObjects = criterionFieldAvailableValuesService.getStoredCriterionFieldAvailableValuesList(includeArchived, tenantID);
      }
    for (GUIManagedObject criterionFieldAvailableValues : criterionFieldAvailableValueObjects)
      {
        criterionFieldAvailableValuesList.add(criterionFieldAvailableValuesService.generateResponseJSON(criterionFieldAvailableValues, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("criterionFieldAvailableValues", JSONUtilities.encodeArray(criterionFieldAvailableValuesList));
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processRemoveCriterionFieldAvailableValues
  *
  *****************************************/

  private JSONObject processRemoveCriterionFieldAvailableValues(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> criterionFieldsAvailableValues = new ArrayList<>();
    JSONArray criterionFieldsAvailableValueIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/
    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single criterion field
    //
    if (jsonRoot.containsKey("id"))
      {
        String criterionFieldsAvailableValueID = JSONUtilities.decodeString(jsonRoot, "id", false);
        criterionFieldsAvailableValueIDs.add(criterionFieldsAvailableValueID);
        GUIManagedObject criterionFieldsAvailableValue = criterionFieldAvailableValuesService
            .getStoredCriterionFieldAvailableValues(criterionFieldsAvailableValueID);

        if (criterionFieldsAvailableValue != null && (force || !criterionFieldsAvailableValue.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (criterionFieldsAvailableValue != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "criterionFieldAvailableValueNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        criterionFieldsAvailableValueIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
       

    for (int i = 0; i < criterionFieldsAvailableValueIDs.size(); i++)
      {
        String criterionFieldsAvailableValueID = criterionFieldsAvailableValueIDs.get(i).toString();
        GUIManagedObject criterionFieldsAvailableValue = criterionFieldAvailableValuesService.getStoredCriterionFieldAvailableValues(criterionFieldsAvailableValueID);
        
        if (criterionFieldsAvailableValue != null && (force || !criterionFieldsAvailableValue.getReadOnly())) 
          {
            criterionFieldsAvailableValues.add(criterionFieldsAvailableValue);
            validIDs.add(criterionFieldsAvailableValueID);
          }        
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < criterionFieldsAvailableValues.size(); i++)
      {

        GUIManagedObject criterionFieldAvailableValues = criterionFieldsAvailableValues.get(i);
        criterionFieldAvailableValuesService.removeCriterionFieldAvailableValues(criterionFieldAvailableValues.getGUIManagedObjectID(), userID, tenantID);
      }
    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }
    response.put("removedcriterionFieldAvailableValueIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processPutCriterionFieldAvailableValues
  *
  *****************************************/

  private JSONObject processPutCriterionFieldAvailableValues(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    *  CriterionFieldAvailableValuesID
    *
    *****************************************/

    String criterionFieldAvailableValuesID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (criterionFieldAvailableValuesID == null)
      {
        criterionFieldAvailableValuesID = communicationChannelBlackoutService.generateCommunicationChannelBlackoutID();
        jsonRoot.put("id", criterionFieldAvailableValuesID);
      }

    /*****************************************
    *
    *  existing CriterionFieldAvailableValues
    *
    *****************************************/

    GUIManagedObject existingCriterionFieldAvailableValues = criterionFieldAvailableValuesService.getStoredCriterionFieldAvailableValues(criterionFieldAvailableValuesID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingCriterionFieldAvailableValues != null && existingCriterionFieldAvailableValues.getReadOnly())
      {
        response.put("id", existingCriterionFieldAvailableValues.getGUIManagedObjectID());
        response.put("accepted", existingCriterionFieldAvailableValues.getAccepted());
        response.put("valid", existingCriterionFieldAvailableValues.getAccepted());
        response.put("processing", criterionFieldAvailableValuesService.isActiveCriterionFieldAvailableValues(existingCriterionFieldAvailableValues, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process CriterionFieldAvailableValues
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate CriterionFieldAvailableValues
        *
        ****************************************/

        CriterionFieldAvailableValues criterionFieldAvailableValues = new CriterionFieldAvailableValues(jsonRoot, epoch, existingCriterionFieldAvailableValues, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            criterionFieldAvailableValuesService.putCriterionFieldAvailableValues(criterionFieldAvailableValues,
                (existingCriterionFieldAvailableValues == null), userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", criterionFieldAvailableValues.getGUIManagedObjectID());
        response.put("accepted", criterionFieldAvailableValues.getAccepted());
        response.put("valid", criterionFieldAvailableValues.getAccepted());
        response.put("processing", criterionFieldAvailableValuesService.isActiveCriterionFieldAvailableValues(criterionFieldAvailableValues, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            criterionFieldAvailableValuesService.putCriterionFieldAvailableValues(incompleteObject,
                (existingCriterionFieldAvailableValues == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "criterionFieldAvailableValuesNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }
  
  /*****************************************
  *
  *  processGetCriterionFieldAvailableValues
  *
  *****************************************/

  private JSONObject processGetCriterionFieldAvailableValues(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String criterionFieldAvailableValuesID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject criterionFieldAvailableValues = salesChannelService.getStoredSalesChannel(criterionFieldAvailableValuesID, includeArchived);
    JSONObject criterionFieldAvailableValuesJSON = criterionFieldAvailableValuesService.generateResponseJSON(criterionFieldAvailableValues, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (criterionFieldAvailableValues != null) ? "ok" : "criterionFieldAvailableValuesNotFound");
    if (criterionFieldAvailableValues != null) response.put("criterionFieldAvailableValues", criterionFieldAvailableValuesJSON);
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusCriterionFieldAvailableValues
   *
   *****************************************/

  private JSONObject processSetStatusCriterionFieldAvailableValues(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/
    HashMap<String, Object> response = new HashMap<String, Object>();
    Date now = SystemTime.getCurrentTime();
    JSONArray criterionFieldIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < criterionFieldIDs.size(); i++)
      {

        String criterionFieldID = criterionFieldIDs.get(i).toString();
        GUIManagedObject existingElement = criterionFieldAvailableValuesService
            .getStoredCriterionFieldAvailableValues(criterionFieldID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(criterionFieldID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate CriterionFieldAvailableValues
                 *
                 ****************************************/

                CriterionFieldAvailableValues criterionFieldAvailableValues = new CriterionFieldAvailableValues(
                    elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/

                criterionFieldAvailableValuesService.putCriterionFieldAvailableValues(criterionFieldAvailableValues,
                    (existingElement == null), userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                criterionFieldAvailableValuesService.putCriterionFieldAvailableValues(incompleteObject,
                    (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }

    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }
  

  /*****************************************
  *
  *  processGetSalesChannelList
  *
  *****************************************/

  private JSONObject processGetSalesChannelList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert salesChannels
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> salesChannels = new ArrayList<JSONObject>(); 
    HashMap<String,Object> response = new HashMap<String,Object>();
    Collection <GUIManagedObject> salesChannelObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray salesChannelIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < salesChannelIDs.size(); i++)
          {
            String salesChannelID = salesChannelIDs.get(i).toString();
            GUIManagedObject salesChannel = salesChannelService.getStoredSalesChannel(salesChannelID, includeArchived);
            if (salesChannel != null && salesChannel.getTenantID() == tenantID)
              {
                salesChannelObjects.add(salesChannel);
              }
          }
      }
    else
      {
        salesChannelObjects = salesChannelService.getStoredSalesChannels(includeArchived, tenantID);
      }
    
    for (GUIManagedObject salesChannel : salesChannelObjects)
      {       
        JSONObject salesChannelJSON = salesChannelService.generateResponseJSON(salesChannel, fullDetails, now);       
        
        
        /*****************************************
        *
        *  To display resellers in the summary list
        *
        *****************************************/
        
        if (!fullDetails) {
          if (salesChannel.getJSONRepresentation().get("resellerIDs")!= null) {
           salesChannelJSON.put("resellerIDs", salesChannel.getJSONRepresentation().get("resellerIDs"));
          }
          else {
            salesChannelJSON.put("resellerIDs", new ArrayList<>());
          } 
          
        }
        
        salesChannels.add(salesChannelJSON);
        
      }    
    
    

    /*****************************************
    *
    *  response
    *
    *****************************************/
    
    
    response.put("responseCode", "ok" );
    response.put("salesChannels", JSONUtilities.encodeArray(salesChannels));    
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetSalesChannel
  *
  *****************************************/

  private JSONObject processGetSalesChannel(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String salesChannelID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject salesChannel = salesChannelService.getStoredSalesChannel(salesChannelID, includeArchived);
    JSONObject salesChannelJSON = salesChannelService.generateResponseJSON(salesChannel, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (salesChannel != null) ? "ok" : "salesChannelNotFound");
    if (salesChannel != null) response.put("salesChannel", salesChannelJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutSalesChannel
  *
  *****************************************/

  private JSONObject processPutSalesChannel(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    *  salesChannelID
    *
    *****************************************/

    String salesChannelID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (salesChannelID == null)
      {
        salesChannelID = salesChannelService.generateSalesChannelID();
        jsonRoot.put("id", salesChannelID);
      }

    /*****************************************
    *
    *  existing salesChannel
    *
    *****************************************/

    GUIManagedObject existingSalesChannel = salesChannelService.getStoredSalesChannel(salesChannelID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingSalesChannel != null && existingSalesChannel.getReadOnly())
      {
        response.put("id", existingSalesChannel.getGUIManagedObjectID());
        response.put("accepted", existingSalesChannel.getAccepted());
        response.put("valid", existingSalesChannel.getAccepted());
        response.put("processing", salesChannelService.isActiveSalesChannel(existingSalesChannel, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process salesChannel
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate salesChannel
        *
        ****************************************/

        SalesChannel salesChannel = new SalesChannel(jsonRoot, epoch, existingSalesChannel, tenantID);
        
        /*****************************************
         *
         * store
         *
         *****************************************/
        if (!dryRun)
          {
            salesChannelService.putSalesChannel(salesChannel, callingChannelService, resellerService,
                (existingSalesChannel == null), userID);

            /*****************************************
             *
             * revalidateOffers
             *
             *****************************************/

            revalidateOffers(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", salesChannel.getSalesChannelID());
        response.put("accepted", salesChannel.getAccepted());
        response.put("valid", salesChannel.getAccepted());
        response.put("processing", salesChannelService.isActiveSalesChannel(salesChannel, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {

            salesChannelService.putSalesChannel(incompleteObject, callingChannelService, resellerService,
                (existingSalesChannel == null), userID);

            //
            // revalidateOffers
            //

            revalidateOffers(now, tenantID);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "salesChannelNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveSalesChannel
  *
  *****************************************/

  private JSONObject processRemoveSalesChannel(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> salesChannels = new ArrayList<>();
    JSONArray salesChannelIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single salesChannel
    //
    if (jsonRoot.containsKey("id"))
      {
        String salesChannelID = JSONUtilities.decodeString(jsonRoot, "id", false);
        salesChannelIDs.add(salesChannelID);
        GUIManagedObject salesChannel = salesChannelService.getStoredSalesChannel(salesChannelID);
        if (salesChannel != null && (force || !salesChannel.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (salesChannel != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "salesChannelNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        salesChannelIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
  
    for (int i = 0; i < salesChannelIDs.size(); i++)
      {
        String salesChannelID = salesChannelIDs.get(i).toString();
        GUIManagedObject salesChannel = salesChannelService.getStoredSalesChannel(salesChannelID);
        if (salesChannel != null && (force || !salesChannel.getReadOnly()))
          {
            salesChannels.add(salesChannel);
            validIDs.add(salesChannelID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < salesChannels.size(); i++)
      {

        GUIManagedObject salesChannel = salesChannels.get(i);
        salesChannelService.removeSalesChannel(salesChannel.getGUIManagedObjectID(), userID, tenantID);

        /*****************************************
         *
         * revalidateOffers
         *
         *****************************************/

        revalidateOffers(now, tenantID);
      }
    
    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedsalesChannelIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processSetStatusSalesChannel
  *
  *****************************************/

  private JSONObject processSetStatusSalesChannel(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray salesChannelIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < salesChannelIDs.size(); i++)
      {

        String salesChannelID = salesChannelIDs.get(i).toString();
        GUIManagedObject existingElement = salesChannelService.getStoredSalesChannel(salesChannelID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(salesChannelID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate salesChannel
                 *
                 ****************************************/

                SalesChannel salesChannel = new SalesChannel(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                salesChannelService.putSalesChannel(salesChannel, callingChannelService, resellerService,
                    (existingElement == null), userID);

                /*****************************************
                 *
                 * revalidateOffers
                 *
                 *****************************************/

                revalidateOffers(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //
                salesChannelService.putSalesChannel(incompleteObject, callingChannelService, resellerService,
                    (existingElement == null), userID);

                //
                // revalidateOffers
                //

                revalidateOffers(now, tenantID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetSupplierList
  *
  *****************************************/

  private JSONObject processGetSupplierList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert suppliers
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> suppliers = new ArrayList<JSONObject>();    
    Collection <GUIManagedObject> supplierObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray supplierIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < supplierIDs.size(); i++)
          {
            String supplierID = supplierIDs.get(i).toString();
            GUIManagedObject supplier = supplierService.getStoredSupplier(supplierID, includeArchived);
            if (supplier != null && supplier.getTenantID() == tenantID)
              {
                supplierObjects.add(supplier);
              }
          }
      }
    else
      {
        supplierObjects = supplierService.getStoredSuppliers(includeArchived, tenantID);
      }
    for (GUIManagedObject supplier : supplierObjects)
      {
        suppliers.add(supplierService.generateResponseJSON(supplier, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("suppliers", JSONUtilities.encodeArray(suppliers));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetSupplier
  *
  *****************************************/

  private JSONObject processGetSupplier(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String supplierID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject supplier = supplierService.getStoredSupplier(supplierID, includeArchived);
    JSONObject supplierJSON = supplierService.generateResponseJSON(supplier, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (supplier != null) ? "ok" : "supplierNotFound");
    if (supplier != null) response.put("supplier", supplierJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutSupplier
  *
  *****************************************/

  private JSONObject processPutSupplier(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    *  supplierID
    *
    *****************************************/

    String supplierID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (supplierID == null)
      {
        supplierID = supplierService.generateSupplierID();
        jsonRoot.put("id", supplierID);
      }

    /*****************************************
    *
    *  existing supplier
    *
    *****************************************/

    GUIManagedObject existingSupplier = supplierService.getStoredSupplier(supplierID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingSupplier != null && existingSupplier.getReadOnly())
      {
        response.put("id", existingSupplier.getGUIManagedObjectID());
        response.put("accepted", existingSupplier.getAccepted());
        response.put("valid", existingSupplier.getAccepted());
        response.put("processing", supplierService.isActiveSupplier(existingSupplier, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process supplier
    *
    *****************************************/

    processPartnerAlternateID(jsonRoot, tenantID);
    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate supplier
        *
        ****************************************/

        Supplier supplier = new Supplier(jsonRoot, epoch, existingSupplier, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {
            supplierService.putSupplier(supplier, (existingSupplier == null), userID, supplierService);

            /*****************************************
             *
             * revalidateProducts
             *
             *****************************************/

            revalidateProducts(now, tenantID);
            revalidateVouchers(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", supplier.getSupplierID());
        response.put("accepted", supplier.getAccepted());
        response.put("valid", supplier.getAccepted());
        response.put("processing", supplierService.isActiveSupplier(supplier, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            supplierService.putSupplier(incompleteObject, (existingSupplier == null), userID, supplierService);

        //
        //  revalidateProducts
        //

            revalidateProducts(now, tenantID);
            revalidateVouchers(now, tenantID);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "supplierNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  private void processPartnerAlternateID(JSONObject jsonRoot, int tenantID)
  {
    // find out the subscriberID, so that we can do the processing in EvolutionEngine
    String alternateID = JSONUtilities.decodeString(jsonRoot, "alternateID", false);
    String alternateIDValue = JSONUtilities.decodeString(jsonRoot, "alternateIDValue", false);
    if (alternateID != null && alternateIDValue != null)
      {
        try
        {
          String customerID = subscriberIDService.getSubscriberID(alternateID, alternateIDValue);
          jsonRoot.put("customerIDfromAlternateID", customerID);
        }
        catch (SubscriberIDServiceException e)
        {
          log.error("SubscriberIDServiceException can not resolve subscriberID for {} = {} error is {}", alternateID, alternateIDValue, e.getMessage());
        }
      }
  }

  /*****************************************
   *
   * processRemoveSupplier
   *
   *****************************************/

  private JSONObject processRemoveSupplier(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONObject dependencyRequest = new JSONObject();

    /*****************************************
     *
     * now
     *
     *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> suppliers = new ArrayList<>();
    JSONArray supplierIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
     *
     * argument
     *
     ****************************************/
    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);

    //
    // remove single supplier
    //
    if (jsonRoot.containsKey("id"))
      {
        String supplierID = JSONUtilities.decodeString(jsonRoot, "id", false);
        supplierIDs.add(supplierID);
        GUIManagedObject supplier = supplierService.getStoredSupplier(supplierID);
        if (supplier != null && (force || !supplier.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (supplier != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "supplierNotFound";
      }
    //
    // multiple deletion
    //

    if (jsonRoot.containsKey("ids"))
      {
        supplierIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }

    for (int i = 0; i < supplierIDs.size(); i++)
      {
        String supplierID = supplierIDs.get(i).toString();
        GUIManagedObject supplier = supplierService.getStoredSupplier(supplierID);

        if (supplier != null && (force || !supplier.getReadOnly()))
          {
            dependencyRequest.put("apiVersion", 1);
            dependencyRequest.put("objectType", "supplier");
            dependencyRequest.put("id", supplier.getGUIManagedObjectID());

            JSONObject dependenciesObject = guiManagerGeneral.processGetDependencies(userID, dependencyRequest, tenantID);
            JSONArray dependencies = JSONUtilities.decodeJSONArray(dependenciesObject, "dependencies", new JSONArray());
            boolean parentDependency = false;
            if (dependencies.size() != 0)
              {
                for (int j = 0; j < dependencies.size(); j++)
                  {
                    JSONObject dependent = (JSONObject) dependencies.get(j);
                    String ojectType = JSONUtilities.decodeString(dependent, "objectType", false);
                    if (("supplier".equals(ojectType)) || ("product".equals("ojectType")))
                      {
                        parentDependency = true;
                        break;
                      }
                  }
              }
            if (!parentDependency) {
            suppliers.add(supplier);
            validIDs.add(supplierID);
            }
            else
              {
                if (jsonRoot.containsKey("id")) {
                response.put("responseCode", RESTAPIGenericReturnCodes.DEPENDENCY_RESTRICTION.getGenericResponseCode());
                response.put("responseMessage",
                    RESTAPIGenericReturnCodes.DEPENDENCY_RESTRICTION.getGenericResponseMessage());
                return JSONUtilities.encodeObject(response);
                }
              }
          }
      }

    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (GUIManagedObject supplier :suppliers)
      {
        if (supplier != null && (force || !supplier.getReadOnly()))
          {
                supplierService.removeSupplier(supplier.getGUIManagedObjectID(), userID, tenantID);
              
            

          }

        /*****************************************
         *
         * revalidateProducts
         *
         *****************************************/

        revalidateProducts(now, tenantID);

        /*****************************************
         *
         * revalidateVouchers
         *
         *****************************************/

        revalidateVouchers(now, tenantID);
      }

    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedSupplierIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusSupplier
   *
   *****************************************/

  private JSONObject processSetStatusSupplier(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray supplierIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < supplierIDs.size(); i++)
      {

        String supplierID = supplierIDs.get(i).toString();
        GUIManagedObject existingElement = supplierService.getStoredSupplier(supplierID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(supplierID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate supplier
                 *
                 ****************************************/

                Supplier supplier = new Supplier(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/

                supplierService.putSupplier(supplier, (existingElement == null), userID, supplierService);

                /*****************************************
                 *
                 * revalidateProducts
                 *
                 *****************************************/

                revalidateProducts(now, tenantID);
                revalidateVouchers(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //
                supplierService.putSupplier(incompleteObject, (existingElement == null), userID, supplierService);

                //
                // revalidateProducts
                //

                revalidateProducts(now, tenantID);
                revalidateVouchers(now, tenantID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetProductList
  *
  *****************************************/

  private JSONObject processGetProductList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert products
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> products = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> productsObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray productIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < productIDs.size(); i++)
          {
            String productID = productIDs.get(i).toString();
            GUIManagedObject product = productService.getStoredProductWithCurrentStocks(productID, includeArchived);
            if (product != null && product.getTenantID() == tenantID)
              {
                productsObjects.add(product);
              }
          }
      }
    else
      {
        productsObjects = productService.getStoredProductsWithCurrentStocks(includeArchived, tenantID);
      }
    for (GUIManagedObject product : productsObjects)
      {
        JSONObject productJSON = productService.generateResponseJSON(product, fullDetails, now);
        if (!fullDetails)
          {
            if (product.getJSONRepresentation().get("simpleOffer") != null)
              {
                productJSON.put("simpleOffer", product.getJSONRepresentation().get("simpleOffer"));
              }
            else
              {
                productJSON.put("simpleOffer", "");
              }
          }
        products.add(productJSON);
        
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("products", JSONUtilities.encodeArray(products));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetProduct
  *
  *****************************************/

  private JSONObject processGetProduct(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String productID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject product = productService.getStoredProductWithCurrentStocks(productID, includeArchived);
    JSONObject productJSON = productService.generateResponseJSON(product, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (product != null) ? "ok" : "productNotFound");
    if (product != null) response.put("product", productJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutProduct
  *
  *****************************************/

  private JSONObject processPutProduct(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  productID
    *
    *****************************************/

    String productID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (productID == null)
      {
        productID = productService.generateProductID();
        jsonRoot.put("id", productID);
      }

    /*****************************************
    *
    *  existing product
    *
    *****************************************/

    GUIManagedObject existingProduct = productService.getStoredProduct(productID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingProduct != null && existingProduct.getReadOnly())
      {
        response.put("id", existingProduct.getGUIManagedObjectID());
        response.put("accepted", existingProduct.getAccepted());
        response.put("valid", existingProduct.getAccepted());
        response.put("processing", productService.isActiveProduct(existingProduct, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    * check if product is created by simpleOffer
    *
    *****************************************/
    if (existingProduct == null)
      {
        jsonRoot.put("simpleOffer", false); // offer not a simpleOffer
      }

    if (existingProduct != null)
      {
        if (existingProduct instanceof Product)
          {
            if (((Product) existingProduct).getSimpleOffer() == true)
              {
                String display = ((Product) existingProduct).getGUIManagedObjectDisplay();
                String jsonRootDisplay = JSONUtilities.decodeString(jsonRoot, "display", false);
                if (!(jsonRootDisplay.equals(display)))
                  {
                    response.put("responseCode", "productNotValid");
                    response.put("responseMessage", "The display cannot be changed for the existing product");
                    return JSONUtilities.encodeObject(response);
                  }
                else
                  {
                    jsonRoot.put("simpleOffer", true);
                  }

              }
            else
              {
                jsonRoot.put("simpleOffer", false);
              }
          }
      }
    
    

    /*****************************************
    *
    *  process product
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate product
        *
        ****************************************/

        Product product = new Product(jsonRoot, epoch, existingProduct, deliverableService, catalogCharacteristicService, tenantID);

		// if stock update, and no more stock, need to warn it
		String responseMessage = null;
		if(existingProduct instanceof Product && !Objects.equals(((Product) existingProduct).getStock(),product.getStock()) && StockMonitor.getRemainingStock(product)==0) responseMessage = "no remaining stock";


        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            productService.putProduct(product, supplierService, productTypeService, deliverableService,
                (existingProduct == null), userID);

            /*****************************************
             *
             * revalidateOffers
             *
             *****************************************/

            revalidateOffers(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", product.getProductID());
        response.put("accepted", product.getAccepted());
        response.put("valid", product.getAccepted());
        response.put("processing", productService.isActiveProduct(product, now));
        response.put("responseCode", "ok");
		if(responseMessage!=null) response.put("responseMessage",responseMessage);
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {

            productService.putProduct(incompleteObject, supplierService, productTypeService, deliverableService,
                (existingProduct == null), userID);

            //
            // revalidateOffers
            //

            revalidateOffers(now, tenantID);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "productNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveProduct
  *
  *****************************************/

  private JSONObject processRemoveProduct(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> products = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray productIDs = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single product
    //
    if (jsonRoot.containsKey("id"))
      {
        String productID = JSONUtilities.decodeString(jsonRoot, "id", false);
        productIDs.add(productID);
        GUIManagedObject product = productService.getStoredProduct(productID);
        if (product != null && (force || !product.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (product != null)
          singleIDresponseCode = "failedReadOnly";
        else
          {
            singleIDresponseCode = "productNotFound";

          }

      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        productIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < productIDs.size(); i++)
      {
        String productID = productIDs.get(i).toString();
        GUIManagedObject product = productService.getStoredProduct(productID);
        if (product != null && (force || !product.getReadOnly())) 
          {
            products.add(product);
            validIDs.add(productID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < products.size(); i++)
      {

        GUIManagedObject product = products.get(i);
        productService.removeProduct(product.getGUIManagedObjectID(), userID, tenantID);

        /*****************************************
         *
         * revalidateOffers
         *
         *****************************************/

        revalidateOffers(now, tenantID);
      }

    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedProductIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  

  /*****************************************
  *
  *  processUpdateProduct
  *
  *****************************************/

  private JSONObject processUpdateProduct(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    Boolean dryRun = false;
    JSONArray productIDs = new JSONArray();
    List<GUIManagedObject> existingProducts = new ArrayList();
    List<String> updatedIDs = new ArrayList();
    List<Object> exceptionList= new ArrayList();

    /*****************************************
     *
     * dryRun
     *
     *****************************************/
    if (jsonRoot.containsKey("dryRun"))
      {
        dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
      }

    /*****************************************
     *
     * update product
     *
     *****************************************/

   if (jsonRoot.containsKey("ids"))
      {
        productIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false); // update for multiple product
      }
    else
      {
        response.put("responseCode", "invalidProduct");
        response.put("responseMessage", "product ID is empty");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
     *
     * existing products
     *
     *****************************************/
    for (int i = 0; i < productIDs.size(); i++)
      {
        String productID = (productIDs.get(i)).toString();
        GUIManagedObject existingProductObject = productService.getStoredProduct(productID);
        if (existingProductObject != null)
          {
            existingProducts.add(existingProductObject); //ignore the wrong productIDs
          }
      }

    if (existingProducts == null || existingProducts.isEmpty())
      {
        response.put("responseCode", "invalidProducts");
        response.put("responseMessage", "products does not exist");
        return JSONUtilities.encodeObject(response);
      }

    for (GUIManagedObject existingProductToBeUpdated : existingProducts)
      {
        JSONObject JSONToBeUpdated = new JSONObject();
        Set<String> JsonRootkeySets = jsonRoot.keySet();
        JSONObject existingProductObject = existingProductToBeUpdated.getJSONRepresentation();
        if (existingProductToBeUpdated instanceof Product)
          {
            if (((Product) existingProductToBeUpdated).getSimpleOffer() == true)
              {
                if (jsonRoot.containsKey("display"))
                  {
                    HashMap<String, String> errorResponseDisplay = new HashMap<String, String>();
                    errorResponseDisplay.put("id", existingProductToBeUpdated.getGUIManagedObjectID());
                    errorResponseDisplay.put("responseCode", "Invalid display");
                    errorResponseDisplay.put("responseMessage",
                        "The display cannot be changed for the existing simple offer product");
                    exceptionList.add(errorResponseDisplay);
                    continue;
                  }
                if (jsonRoot.containsKey("simpleOffer"))
                  {
                    boolean simpleOffer = JSONUtilities.decodeBoolean(jsonRoot, "simpleOffer", false);
                    if (!simpleOffer)
                      {
                        HashMap<String, String> errorResponseSimpleOffer = new HashMap<String, String>();
                        errorResponseSimpleOffer.put("id", existingProductToBeUpdated.getGUIManagedObjectID());
                        errorResponseSimpleOffer.put("responseCode", "Invalid product");
                        errorResponseSimpleOffer.put("responseMessage",
                            "The simple Offer cannot be changed for the existing simple offer product");
                        exceptionList.add(errorResponseSimpleOffer);
                        continue;
                      }
                  }
              }
          }
        for (String JsonRootkey : JsonRootkeySets)
          {
            JSONToBeUpdated.put(JsonRootkey, jsonRoot.get(JsonRootkey));  // get the part of GUI object which need to be updated from jsonRoot
          }
        JSONToBeUpdated.put("id", existingProductToBeUpdated.getGUIManagedObjectID());
        for (Object keyObject : existingProductObject.keySet())
          {
            String key = keyObject.toString();
           if (key != null && (!(JsonRootkeySets.contains(key))))
              {
                JSONToBeUpdated.put(key, existingProductObject.get(key)); //get the other parts of the GUI objects from the existing product JSON

              }
          }
        /*****************************************
         *
         * process product
         *
         *****************************************/

        long epoch = epochServer.getKey();
        try
          {
            /****************************************
             *
             * instantiate product
             *
             ****************************************/
            if (JSONToBeUpdated.containsKey("id"))
              {
                JSONToBeUpdated.remove("ids");
              }
            Product product = new Product(JSONToBeUpdated, epoch, existingProductToBeUpdated, deliverableService,
                catalogCharacteristicService, tenantID);

            /*****************************************
             *
             * store
             *
             *****************************************/
            if (!dryRun)
              {

                productService.putProduct(product, supplierService, productTypeService, deliverableService,
                    (existingProductToBeUpdated == null), userID);

                /*****************************************
                 *
                 * revalidateOffers
                 *
                 *****************************************/

                revalidateOffers(now, tenantID);
              }

            /*****************************************
             *
             * response
             *
             *****************************************/
           if (jsonRoot.containsKey("ids")) {
              updatedIDs.add(product.getProductID());
            }
          }

        catch (JSONUtilitiesException | GUIManagerException e)
          {
            //
            // incompleteObject
            //

            IncompleteObject incompleteObject = new IncompleteObject(JSONToBeUpdated, epoch, tenantID);

            //
            // store
            //
            if (!dryRun)
              {

                productService.putProduct(incompleteObject, supplierService, productTypeService, deliverableService,
                    (existingProductToBeUpdated == null), userID);

                //
                // revalidateOffers
                //

                revalidateOffers(now, tenantID);
              }

            //
            // log
            //

            StringWriter stackTraceWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stackTraceWriter, true));
            log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

            //
            // response
            //
            if (jsonRoot.containsKey("ids"))
              {
                HashMap<String, String> invalidProductsExceptions = new HashMap<String, String>();
                invalidProductsExceptions.put("id", incompleteObject.getGUIManagedObjectID());
                invalidProductsExceptions.put("responseCode", "productNotValid");
                invalidProductsExceptions.put("responseMessage", e.getMessage());
                invalidProductsExceptions.put("responseParameter",
                    (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);

                exceptionList.add(invalidProductsExceptions); //get the exceptions for multiple products
                updatedIDs.add(incompleteObject.getGUIManagedObjectID());

              }

          }
      }
    if (jsonRoot.containsKey("ids")) {
      response.put("updatedIds", updatedIDs);
      response.put("exceptionIds", exceptionList);
      response.put("responseCode", "ok");

    }

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
   *
   * processSetStatusProduct
   *
   *****************************************/

  private JSONObject processSetStatusProduct(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray productIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < productIDs.size(); i++)
      {

        String productID = productIDs.get(i).toString();
        GUIManagedObject existingElement = productService.getStoredProduct(productID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(productID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);

            try
              {
                /****************************************
                 *
                 * instantiate product
                 *
                 ****************************************/

                Product product = new Product(elementRoot, epoch, existingElement, deliverableService,
                    catalogCharacteristicService, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                productService.putProduct(product, supplierService, productTypeService, deliverableService,
                    (existingElement == null), userID);

                /*****************************************
                 *
                 * revalidateOffers
                 *
                 *****************************************/

                revalidateOffers(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                productService.putProduct(incompleteObject, supplierService, productTypeService, deliverableService,
                    (existingElement == null), userID);

                //
                // revalidateOffers
                //

                revalidateOffers(now, tenantID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }



  /*****************************************
  *
  *  processGetContactPolicyList
  *
  *****************************************/

  private JSONObject processGetContactPolicyList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert contactPolicies
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> contactPolicies = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> contactPolicyObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray contactPolicyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < contactPolicyIDs.size(); i++)
          {
            String contactPolicyID = contactPolicyIDs.get(i).toString();
            GUIManagedObject contactPolicy = contactPolicyService.getStoredContactPolicy(contactPolicyID, includeArchived);
            if (contactPolicy != null && contactPolicy.getTenantID() == tenantID)
              {
                contactPolicyObjects.add(contactPolicy);
              }
          }
      }
    else
      {
        contactPolicyObjects = contactPolicyService.getStoredContactPolicies(includeArchived, tenantID);
      }
    for (GUIManagedObject contactPolicy : contactPolicyObjects)
      {
        contactPolicies.add(contactPolicyService.generateResponseJSON(contactPolicy, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("contactPolicies", JSONUtilities.encodeArray(contactPolicies));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetContactPolicy
  *
  *****************************************/

  private JSONObject processGetContactPolicy(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String contactPolicyID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject contactPolicy = contactPolicyService.getStoredContactPolicy(contactPolicyID, includeArchived);
    JSONObject contactPolicyJSON = contactPolicyService.generateResponseJSON(contactPolicy, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (contactPolicy != null) ? "ok" : "contactPolicyNotFound");
    if (contactPolicy != null) response.put("contactPolicy", contactPolicyJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutContactPolicy
  *
  *****************************************/

  private JSONObject processPutContactPolicy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }
    

    /*****************************************
    *
    *  contactPolicyID
    *
    *****************************************/

    String contactPolicyID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (contactPolicyID == null)
      {
        contactPolicyID = contactPolicyService.generateContactPolicyID();
        jsonRoot.put("id", contactPolicyID);
      }

    /*****************************************
    *
    *  existing contactPolicy
    *
    *****************************************/

    GUIManagedObject existingContactPolicy = contactPolicyService.getStoredContactPolicy(contactPolicyID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingContactPolicy != null && existingContactPolicy.getReadOnly())
      {
        response.put("id", existingContactPolicy.getGUIManagedObjectID());
        response.put("accepted", existingContactPolicy.getAccepted());
        response.put("valid", existingContactPolicy.getAccepted());
        response.put("processing", contactPolicyService.isActiveContactPolicy(existingContactPolicy, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process contactPolicy
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate contactPolicy
        *
        ****************************************/

        ContactPolicy contactPolicy = new ContactPolicy(jsonRoot, epoch, existingContactPolicy, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            contactPolicyService.putContactPolicy(contactPolicy, (existingContactPolicy == null), userID);

            /*****************************************
             *
             * revalidate dependent objects
             *
             *****************************************/

            revalidateJourneyObjectives(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", contactPolicy.getContactPolicyID());
        response.put("accepted", contactPolicy.getAccepted());
        response.put("valid", contactPolicy.getAccepted());
        response.put("processing", contactPolicyService.isActiveContactPolicy(contactPolicy, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            contactPolicyService.putContactPolicy(incompleteObject, (existingContactPolicy == null), userID);

            //
            // revalidate dependent objects
            //

            revalidateJourneyObjectives(now, tenantID);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "contactPolicyNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveContactPolicy
  *
  *****************************************/

  private JSONObject processRemoveContactPolicy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> contactPolicies = new ArrayList<>();
    JSONArray contactPolicyIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single contactPolicy
    //
    if (jsonRoot.containsKey("id"))
      {
        String contactPolicyID = JSONUtilities.decodeString(jsonRoot, "id", false);
        contactPolicyIDs.add(contactPolicyID);
        GUIManagedObject contactPolicy = contactPolicyService.getStoredContactPolicy(contactPolicyID);
        if (contactPolicy != null && (force || !contactPolicy.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (contactPolicy != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "contactPolicyNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        contactPolicyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }    

    for (int i = 0; i < contactPolicyIDs.size(); i++)
      {
        String contactPolicyID = contactPolicyIDs.get(i).toString();
        GUIManagedObject contactPolicy = contactPolicyService.getStoredContactPolicy(contactPolicyID);
        if (contactPolicy != null && (force || !contactPolicy.getReadOnly()))
          {
            contactPolicies.add(contactPolicy);
            validIDs.add(contactPolicyID);
          }
      }
        
  
    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < contactPolicies.size(); i++)
      {

        GUIManagedObject contactPolicy = contactPolicies.get(i);
        contactPolicyService.removeContactPolicy(contactPolicy.getGUIManagedObjectID(), userID, tenantID);

        /*****************************************
         *
         * revalidate dependent objects
         *
         *****************************************/

        revalidateJourneyObjectives(now, tenantID);
      }

        /*****************************************
         *
         * responseCode
         *
         *****************************************/

        if (jsonRoot.containsKey("id"))
          {
            response.put("responseCode", singleIDresponseCode);
            return JSONUtilities.encodeObject(response);
          }

        else
          {
            response.put("responseCode", "ok");
          }      
    /*****************************************
    *
    *  response
    *
    *****************************************/
    response.put("removedContactPolicyIDS", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
   *
   * processSetStatusContactPolicy
   *
   *****************************************/

  private JSONObject processSetStatusContactPolicy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray contactPolicyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < contactPolicyIDs.size(); i++)
      {

        String contactPolicyID = contactPolicyIDs.get(i).toString();
        GUIManagedObject existingElement = contactPolicyService.getStoredContactPolicy(contactPolicyID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(contactPolicyID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate contactPolicy
                 *
                 ****************************************/

                ContactPolicy contactPolicy = new ContactPolicy(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                contactPolicyService.putContactPolicy(contactPolicy, (existingElement == null), userID);

                /*****************************************
                 *
                 * revalidate dependent objects
                 *
                 *****************************************/

                revalidateJourneyObjectives(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //
                contactPolicyService.putContactPolicy(incompleteObject, (existingElement == null), userID);

                //
                // revalidate dependent objects
                //

                revalidateJourneyObjectives(now, tenantID);
                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }
              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetJourneyObjectiveList
  *
  *****************************************/

  private JSONObject processGetJourneyObjectiveList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert journeyObjectives
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> journeyObjectives = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> journeyObjectiveObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray journeyObjectiveIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < journeyObjectiveIDs.size(); i++)
          {
            String journeyObjectiveID = journeyObjectiveIDs.get(i).toString();
            GUIManagedObject journeyObjective = journeyObjectiveService.getStoredJourneyObjective(journeyObjectiveID, includeArchived);
            if (journeyObjective != null && journeyObjective.getTenantID() == tenantID)
              {
                journeyObjectiveObjects.add(journeyObjective);
              }
          }
      }
    else
      {
        journeyObjectiveObjects = journeyObjectiveService.getStoredJourneyObjectives(includeArchived, tenantID);
      }
    for (GUIManagedObject journeyObjective : journeyObjectiveObjects)
      {
        journeyObjectives.add(journeyObjectiveService.generateResponseJSON(journeyObjective, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("journeyObjectives", JSONUtilities.encodeArray(journeyObjectives));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetJourneyObjective
  *
  *****************************************/

  private JSONObject processGetJourneyObjective(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String journeyObjectiveID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    GUIManagedObject journeyObjective = journeyObjectiveService.getStoredJourneyObjective(journeyObjectiveID, includeArchived);
    JSONObject journeyObjectiveJSON = journeyObjectiveService.generateResponseJSON(journeyObjective, true, now);

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (journeyObjective != null) ? "ok" : "journeyObjectiveNotFound");
    if (journeyObjective != null) response.put("journeyObjective", journeyObjectiveJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutJourneyObjective
  *
  *****************************************/

  private JSONObject processPutJourneyObjective(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    *  journeyObjectiveID
    *
    *****************************************/

    String journeyObjectiveID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (journeyObjectiveID == null)
      {
        journeyObjectiveID = journeyObjectiveService.generateJourneyObjectiveID();
        jsonRoot.put("id", journeyObjectiveID);
      }

    /*****************************************
    *
    *  existing journeyObjective
    *
    *****************************************/

    GUIManagedObject existingJourneyObjective = journeyObjectiveService.getStoredJourneyObjective(journeyObjectiveID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingJourneyObjective != null && existingJourneyObjective.getReadOnly())
      {
        response.put("id", existingJourneyObjective.getGUIManagedObjectID());
        response.put("accepted", existingJourneyObjective.getAccepted());
        response.put("valid", existingJourneyObjective.getAccepted());
        response.put("processing", journeyObjectiveService.isActiveJourneyObjective(existingJourneyObjective, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process journeyObjective
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate journeyObjective
        *
        ****************************************/

        JourneyObjective journeyObjective = new JourneyObjective(jsonRoot, epoch, existingJourneyObjective, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {
            journeyObjectiveService.putJourneyObjective(journeyObjective, journeyObjectiveService, contactPolicyService,
                catalogCharacteristicService, (existingJourneyObjective == null), userID);

            /*****************************************
             *
             * revalidate dependent objects
             *
             *****************************************/

            revalidateJourneys(now, tenantID);
            revalidateJourneyObjectives(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", journeyObjective.getJourneyObjectiveID());
        response.put("accepted", journeyObjective.getAccepted());
        response.put("valid", journeyObjective.getAccepted());
        response.put("processing", journeyObjectiveService.isActiveJourneyObjective(journeyObjective, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            journeyObjectiveService.putJourneyObjective(incompleteObject, journeyObjectiveService, contactPolicyService,
                catalogCharacteristicService, (existingJourneyObjective == null), userID);

            //
            // revalidate dependent objects
            //

            revalidateJourneys(now, tenantID);
            revalidateJourneyObjectives(now, tenantID);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "journeyObjectiveNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }
  

  /*****************************************
  *
  *  processSetStatusJourneyObjective
  *
  *****************************************/

  private JSONObject processSetStatusJourneyObjective(String userID, JSONObject jsonRoot, int tenantID)
  
  {
    /****************************************
     *
     * response
     *
     ****************************************/
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray journeyObjectiveIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    Date now = SystemTime.getCurrentTime();
    long epoch = epochServer.getKey();

    for (int i = 0; i < journeyObjectiveIDs.size(); i++)
      {

        String journeyObjectiveID = journeyObjectiveIDs.get(i).toString();
        GUIManagedObject existingElement = journeyObjectiveService.getStoredJourneyObjective(journeyObjectiveID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(journeyObjectiveID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate journeyObjective
                 *
                 ****************************************/

                JourneyObjective journeyObjective = new JourneyObjective(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/

                journeyObjectiveService.putJourneyObjective(journeyObjective, journeyObjectiveService,
                    contactPolicyService, catalogCharacteristicService, (existingElement == null), userID);

                /*****************************************
                 *
                 * revalidate dependent objects
                 *
                 *****************************************/

                revalidateJourneys(now, tenantID);
                revalidateJourneyObjectives(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

                //
                // store
                //

                journeyObjectiveService.putJourneyObjective(incompleteObject, journeyObjectiveService,
                    contactPolicyService, catalogCharacteristicService, (existingElement == null), userID);

                //
                // revalidate dependent objects
                //

                revalidateJourneys(now, tenantID);
                revalidateJourneyObjectives(now, tenantID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processRemoveJourneyObjective
  *
  *****************************************/

  private JSONObject processRemoveJourneyObjective(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> journeyObjectives = new ArrayList<>();
    JSONArray journeyObjectiveIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/
    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    
    //
    //remove single journeyObjective
    //
    if (jsonRoot.containsKey("id"))
      {
        String journeyObjectiveID = JSONUtilities.decodeString(jsonRoot, "id", false);
        journeyObjectiveIDs.add(journeyObjectiveID);
        GUIManagedObject journeyObjective = journeyObjectiveService.getStoredJourneyObjective(journeyObjectiveID);

        if (journeyObjective != null && (force || !journeyObjective.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (journeyObjective != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "journeyObjectiveNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        journeyObjectiveIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < journeyObjectiveIDs.size(); i++)
      {
        String journeyObjectiveID = journeyObjectiveIDs.get(i).toString();
        GUIManagedObject journeyObjective = journeyObjectiveService.getStoredJourneyObjective(journeyObjectiveID);
        
        if (journeyObjective != null && (force || !journeyObjective.getReadOnly()))
          {
            journeyObjectives.add(journeyObjective);
            validIDs.add(journeyObjectiveID);
          }
      }
        
  

    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < journeyObjectives.size(); i++)
      {

        GUIManagedObject journeyObjective = journeyObjectives.get(i);
        journeyObjectiveService.removeJourneyObjective(journeyObjective.getGUIManagedObjectID(), userID, tenantID);

        /*****************************************
         *
         * revalidate dependent objects
         *
         *****************************************/

        revalidateJourneys(now, tenantID);
        revalidateJourneyObjectives(now, tenantID);
      }

    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedJourneyObjectiveIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetOfferObjectiveList
  *
  *****************************************/

  private JSONObject processGetOfferObjectiveList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert offerObjectives
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> offerObjectives = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> offerObjectiveObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray offerObjectiveIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < offerObjectiveIDs.size(); i++)
          {
            String offerObjectiveID = offerObjectiveIDs.get(i).toString();
            GUIManagedObject offerObjective = offerObjectiveService.getStoredOfferObjective(offerObjectiveID, includeArchived);
            if (offerObjective != null && offerObjective.getTenantID() == tenantID)
              {
                offerObjectiveObjects.add(offerObjective);
              }
          }
      }
    else
      {
        offerObjectiveObjects = offerObjectiveService.getStoredOfferObjectives(includeArchived, tenantID);
      }
    for (GUIManagedObject offerObjective : offerObjectiveObjects)
      {
        offerObjectives.add(offerObjectiveService.generateResponseJSON(offerObjective, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("offerObjectives", JSONUtilities.encodeArray(offerObjectives));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetOfferObjective
  *
  *****************************************/

  private JSONObject processGetOfferObjective(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String offerObjectiveID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject offerObjective = offerObjectiveService.getStoredOfferObjective(offerObjectiveID, includeArchived);
    JSONObject offerObjectiveJSON = offerObjectiveService.generateResponseJSON(offerObjective, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (offerObjective != null) ? "ok" : "offerObjectiveNotFound");
    if (offerObjective != null) response.put("offerObjective", offerObjectiveJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutOfferObjective
  *
  *****************************************/

  private JSONObject processPutOfferObjective(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  offerObjectiveID
    *
    *****************************************/

    String offerObjectiveID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (offerObjectiveID == null)
      {
        offerObjectiveID = offerObjectiveService.generateOfferObjectiveID();
        jsonRoot.put("id", offerObjectiveID);
      }

    /*****************************************
    *
    *  existing offerObjective
    *
    *****************************************/

    GUIManagedObject existingOfferObjective = offerObjectiveService.getStoredOfferObjective(offerObjectiveID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingOfferObjective != null && existingOfferObjective.getReadOnly())
      {
        response.put("id", existingOfferObjective.getGUIManagedObjectID());
        response.put("accepted", existingOfferObjective.getAccepted());
        response.put("valid", existingOfferObjective.getAccepted());
        response.put("processing", offerObjectiveService.isActiveOfferObjective(existingOfferObjective, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process offerObjective
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate offerObjective
        *
        ****************************************/

        OfferObjective offerObjective = new OfferObjective(jsonRoot, epoch, existingOfferObjective, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            offerObjectiveService.putOfferObjective(offerObjective, (existingOfferObjective == null), userID);

            /*****************************************
             *
             * revalidate dependent objects
             *
             *****************************************/

            revalidateOffers(now, tenantID);
            revalidateScoringStrategies(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", offerObjective.getOfferObjectiveID());
        response.put("accepted", offerObjective.getAccepted());
        response.put("valid", offerObjective.getAccepted());
        response.put("processing", offerObjectiveService.isActiveOfferObjective(offerObjective, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            offerObjectiveService.putOfferObjective(incompleteObject, (existingOfferObjective == null), userID);

            //
            // revalidate dependent objects
            //

            revalidateOffers(now, tenantID);
            revalidateScoringStrategies(now, tenantID);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "offerObjectiveNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveOfferObjective
  *
  *****************************************/

  private JSONObject processRemoveOfferObjective(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> offerObjectives = new ArrayList<>();
    JSONArray offerObjectiveIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/
    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single offerObjective
    //
    if (jsonRoot.containsKey("id"))
      {
        String offerObjectiveID = JSONUtilities.decodeString(jsonRoot, "id", false);
        offerObjectiveIDs.add(offerObjectiveID);
        GUIManagedObject offerObjective = offerObjectiveService.getStoredOfferObjective(offerObjectiveID);
        if (offerObjective != null && (force || !offerObjective.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (offerObjective != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "offerObjectiveNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        offerObjectiveIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
       
    for (int i = 0; i < offerObjectiveIDs.size(); i++)
      {
        String offerObjectiveID = offerObjectiveIDs.get(i).toString();
        GUIManagedObject offerObjective = offerObjectiveService.getStoredOfferObjective(offerObjectiveID);
        if (offerObjective != null && (force || !offerObjective.getReadOnly()))
          {
            offerObjectives.add(offerObjective);
            validIDs.add(offerObjectiveID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < offerObjectives.size(); i++)
      {

        GUIManagedObject offerObjective = offerObjectives.get(i);
        
          offerObjectiveService.removeOfferObjective(offerObjective.getGUIManagedObjectID(), userID, tenantID);

        /*****************************************
         *
         * revalidate dependent objects
         *
         *****************************************/

        revalidateOffers(now, tenantID);
        revalidateScoringStrategies(now, tenantID);
      }

    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedOfferObjectiveIDS", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusOfferObjective
   *
   *****************************************/

  private JSONObject processSetStatusOfferObjective(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray offerObjectiveIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < offerObjectiveIDs.size(); i++)
      {

        String offerObjectiveID = offerObjectiveIDs.get(i).toString();
        GUIManagedObject existingElement = offerObjectiveService.getStoredOfferObjective(offerObjectiveID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(offerObjectiveID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate offerObjective
                 *
                 ****************************************/

                OfferObjective offerObjective = new OfferObjective(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                offerObjectiveService.putOfferObjective(offerObjective, (existingElement == null), userID);

                /*****************************************
                 *
                 * revalidate dependent objects
                 *
                 *****************************************/

                revalidateOffers(now, tenantID);
                revalidateScoringStrategies(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                offerObjectiveService.putOfferObjective(incompleteObject, (existingElement == null), userID);

                //
                // revalidate dependent objects
                //

                revalidateOffers(now, tenantID);
                revalidateScoringStrategies(now, tenantID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetProductTypeList
  *
  *****************************************/

  private JSONObject processGetProductTypeList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert productTypes
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> productTypes = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> productTypeObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray productTypeIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < productTypeIDs.size(); i++)
          {
            String productTypeID = productTypeIDs.get(i).toString();
            GUIManagedObject productType = productTypeService.getStoredProductType(productTypeID, includeArchived);
            if (productType != null && productType.getTenantID() == tenantID)
              {
                productTypeObjects.add(productType);
              }
          }
      }
    else
      {
        productTypeObjects = productTypeService.getStoredProductTypes(includeArchived, tenantID);
      }
    for (GUIManagedObject productType : productTypeObjects)
      {
        productTypes.add(productTypeService.generateResponseJSON(productType, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("productTypes", JSONUtilities.encodeArray(productTypes));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetProductType
  *
  *****************************************/

  private JSONObject processGetProductType(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String productTypeID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate product type
    *
    *****************************************/

    GUIManagedObject productType = productTypeService.getStoredProductType(productTypeID, includeArchived);
    JSONObject productTypeJSON = productTypeService.generateResponseJSON(productType, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (productType != null) ? "ok" : "productTypeNotFound");
    if (productType != null) response.put("productType", productTypeJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutProductType
  *
  *****************************************/

  private JSONObject processPutProductType(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    *  productTypeID
    *
    *****************************************/

    String productTypeID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (productTypeID == null)
      {
        productTypeID = productTypeService.generateProductTypeID();
        jsonRoot.put("id", productTypeID);
      }

    /*****************************************
    *
    *  existing productType
    *
    *****************************************/

    GUIManagedObject existingProductType = productTypeService.getStoredProductType(productTypeID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingProductType != null && existingProductType.getReadOnly())
      {
        response.put("id", existingProductType.getGUIManagedObjectID());
        response.put("accepted", existingProductType.getAccepted());
        response.put("valid", existingProductType.getAccepted());
        response.put("processing", productTypeService.isActiveProductType(existingProductType, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process productType
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate productType
        *
        ****************************************/

        ProductType productType = new ProductType(jsonRoot, epoch, existingProductType, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            productTypeService.putProductType(productType, (existingProductType == null), userID);

            /*****************************************
             *
             * revalidateProducts
             *
             *****************************************/

            revalidateProducts(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", productType.getID());
        response.put("accepted", productType.getAccepted());
        response.put("valid", productType.getAccepted());
        response.put("processing", productTypeService.isActiveProductType(productType, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            productTypeService.putProductType(incompleteObject, (existingProductType == null), userID);

            //
            // revalidateProducts
            //

            revalidateProducts(now, tenantID);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "productTypeNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveProductType
  *
  *****************************************/

  private JSONObject processRemoveProductType(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> productTypes = new ArrayList<>();
    JSONArray productTypeIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single productType
    //
    if (jsonRoot.containsKey("id"))
      {
        String productTypeID = JSONUtilities.decodeString(jsonRoot, "id", false);
        productTypeIDs.add(productTypeID);
        GUIManagedObject productType = productTypeService.getStoredProductType(productTypeID);

        if (productType != null && (force || !productType.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (productType != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "productTypeNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        productTypeIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < productTypeIDs.size(); i++)
      {
        String productTypeID = productTypeIDs.get(i).toString();
        GUIManagedObject productType = productTypeService.getStoredProductType(productTypeID);
        
        if (productType != null && (force || !productType.getReadOnly()))
          {
            productTypes.add(productType);
            validIDs.add(productTypeID);
          }
      }
        
  
    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < productTypes.size(); i++)
      {

        GUIManagedObject productType = productTypes.get(i);
        productTypeService.removeProductType(productType.getGUIManagedObjectID(), userID, tenantID);

        /*****************************************
         *
         * revalidateProducts
         *
         *****************************************/

        revalidateProducts(now, tenantID);
      }

    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedProductTypeIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
   *
   * processSetStatusProductType
   *
   *****************************************/

  private JSONObject processSetStatusProductType(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray productTypeIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < productTypeIDs.size(); i++)
      {

        String productTypeID = productTypeIDs.get(i).toString();
        GUIManagedObject existingElement = productTypeService.getStoredProductType(productTypeID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(productTypeID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate productType
                 *
                 ****************************************/

                ProductType productType = new ProductType(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                productTypeService.putProductType(productType, (existingElement == null), userID);

                /*****************************************
                 *
                 * revalidateProducts
                 *
                 *****************************************/

                revalidateProducts(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                productTypeService.putProductType(incompleteObject, (existingElement == null), userID);

                //
                // revalidateProducts
                //

                revalidateProducts(now, tenantID);
                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }
              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }
 

  /*****************************************
  *
  *  processGetDeliverableList
  *
  *****************************************/

  private JSONObject processGetDeliverableList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert deliverables
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> deliverables = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> deliverableObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray deliverableIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < deliverableIDs.size(); i++)
          {
            String deliverableID = deliverableIDs.get(i).toString();
            GUIManagedObject deliverable = deliverableService.getStoredDeliverable(deliverableID, includeArchived);
            if (deliverable != null && deliverable.getTenantID() == tenantID)
              {
                deliverableObjects.add(deliverable);
              }
          }
      }
    else
      {
        deliverableObjects = deliverableService.getStoredDeliverables(includeArchived, tenantID);
      }
    for (GUIManagedObject deliverable : deliverableObjects)
      {
        deliverables.add(deliverableService.generateResponseJSON(deliverable, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("deliverables", JSONUtilities.encodeArray(deliverables));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetVoucherTypeList
  *
  *****************************************/

  private JSONObject processGetVoucherTypeList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert voucherTypes
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> voucherTypes = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> voucherTypeObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray voucherTypeIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < voucherTypeIDs.size(); i++)
          {
            String voucherTypeID = voucherTypeIDs.get(i).toString();
            GUIManagedObject voucherType = voucherTypeService.getStoredVoucherType(voucherTypeID, includeArchived);
            if (voucherType != null && voucherType.getTenantID() == tenantID)
              {
                voucherTypeObjects.add(voucherType);
              }
          }
      }
    else
      {
        voucherTypeObjects = voucherTypeService.getStoredVoucherTypes(includeArchived, tenantID);
      }
    for (GUIManagedObject voucherType : voucherTypeObjects)
      {
        voucherTypes.add(voucherTypeService.generateResponseJSON(voucherType, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("voucherTypes", JSONUtilities.encodeArray(voucherTypes));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetVoucherType
  *
  *****************************************/

  private JSONObject processGetVoucherType(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String voucherTypeID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate voucherType
    *
    *****************************************/

    GUIManagedObject voucherType = voucherTypeService.getStoredVoucherType(voucherTypeID, includeArchived);
    JSONObject voucherTypeJSON = voucherTypeService.generateResponseJSON(voucherType, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (voucherType != null) ? "ok" : "voucherTypeNotFound");
    if (voucherType != null) response.put("voucherType", voucherTypeJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutVoucherType
  *
  *****************************************/

  private JSONObject processPutVoucherType(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  voucherTypeID
    *
    *****************************************/

    String voucherTypeID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (voucherTypeID == null)
      {
        voucherTypeID = voucherTypeService.generateVoucherTypeID();
        jsonRoot.put("id", voucherTypeID);
      }

    /*****************************************
    *
    *  existing voucherType
    *
    *****************************************/

    GUIManagedObject existingVoucherType = voucherTypeService.getStoredVoucherType(voucherTypeID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingVoucherType != null && existingVoucherType.getReadOnly())
      {
        response.put("id", existingVoucherType.getGUIManagedObjectID());
        response.put("accepted", existingVoucherType.getAccepted());
        response.put("valid", existingVoucherType.getAccepted());
        response.put("processing", voucherTypeService.isActiveVoucherType(existingVoucherType, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process voucherType
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate voucherType
        *
        ****************************************/

        VoucherType voucherType = new VoucherType(jsonRoot, epoch, existingVoucherType, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            voucherTypeService.putVoucherType(voucherType, (existingVoucherType == null), userID);

            revalidateVouchers(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", voucherType.getID());
        response.put("accepted", voucherType.getAccepted());
        response.put("valid", voucherType.getAccepted());
        response.put("processing", voucherTypeService.isActiveVoucherType(voucherType, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            voucherTypeService.putVoucherType(incompleteObject, (existingVoucherType == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "voucherTypeNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveVoucherType
  *
  *****************************************/

  private JSONObject processRemoveVoucherType(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> voucherTypes = new ArrayList<>();
    JSONArray voucherTypeIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);

    //
    //remove single voucherType
    //
    if (jsonRoot.containsKey("id"))
      {
        String voucherTypeID = JSONUtilities.decodeString(jsonRoot, "id", false);
        voucherTypeIDs.add(voucherTypeID);
        GUIManagedObject voucherType = voucherTypeService.getStoredVoucherType(voucherTypeID);

        if (voucherType != null && (force || !voucherType.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (voucherType != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "voucherTypeNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        voucherTypeIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
    
    //
    // If one of the voucherTypeID is wrong it should reject the request
    //

    for (int i = 0; i < voucherTypeIDs.size(); i++)
      {
        String voucherTypeID = voucherTypeIDs.get(i).toString();
        GUIManagedObject voucherType = voucherTypeService.getStoredVoucherType(voucherTypeID);
        
        if (voucherType != null && (force || !voucherType.getReadOnly()))
          {
            voucherTypes.add(voucherType);
            validIDs.add(voucherTypeID);
          }
      }
        
  

    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < voucherTypes.size(); i++)
      {
        GUIManagedObject voucherType = voucherTypes.get(i);
        
        voucherTypeService.removeVoucherType(voucherType.getGUIManagedObjectID(), userID, tenantID);

        /*****************************************
         *
         * revalidateVouchers
         *
         *****************************************/

        revalidateVouchers(now, tenantID);
      }

    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedVoucherTypeIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusVoucherType
   *
   *****************************************/

  private JSONObject processSetStatusVoucherType(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray voucherTypeIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < voucherTypeIDs.size(); i++)
      {

        String voucherTypeID = voucherTypeIDs.get(i).toString();
        GUIManagedObject existingElement = voucherTypeService.getStoredVoucherType(voucherTypeID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(voucherTypeID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate voucherType
                 *
                 ****************************************/

                VoucherType voucherType = new VoucherType(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                voucherTypeService.putVoucherType(voucherType, (existingElement == null), userID);

                revalidateVouchers(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                voucherTypeService.putVoucherType(incompleteObject, (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }
              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }


  /*****************************************
  *
  *  processGetVoucherCodeFormatList
  *
  *****************************************/

  private JSONObject processGetVoucherCodeFormatList(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve vouchers code format list
    *
    *****************************************/

    JSONArray voucherCodeFormatJSONArray = Deployment.getDeployment(tenantID).getInitialVoucherCodeFormatsJSONArray();

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("voucherCodeFormats", JSONUtilities.encodeArray(voucherCodeFormatJSONArray));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetVoucherList
  *
  *****************************************/

  private JSONObject processGetVoucherList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert vouchers
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> vouchers = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> voucherObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray voucherIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < voucherIDs.size(); i++)
          {
            String voucherID = voucherIDs.get(i).toString();
            GUIManagedObject voucher = voucherService.getStoredVoucherWithCurrentStocks(voucherID, includeArchived);
            if (voucher != null && voucher.getTenantID() == tenantID)
              {
                voucherObjects.add(voucher);
              }
          }
      }
    else
      {
        voucherObjects = voucherService.getStoredVouchersWithCurrentStocks(includeArchived, tenantID);
      }
    for (GUIManagedObject voucher : voucherObjects)
      {
        JSONObject voucherJSON = voucherService.generateResponseJSON(voucher, fullDetails, now);
        if (!fullDetails)
          {
            if (voucher.getJSONRepresentation().get("simpleOffer") != null)
              {
                voucherJSON.put("simpleOffer", voucher.getJSONRepresentation().get("simpleOffer"));
              }
            else
              {
                voucherJSON.put("simpleOffer", "");
              }
          }
        vouchers.add(voucherJSON);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("vouchers", JSONUtilities.encodeArray(vouchers));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetVoucher
  *
  *****************************************/

  private JSONObject processGetVoucher(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String voucherID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate voucher
    *
    *****************************************/

    GUIManagedObject voucher = voucherService.getStoredVoucherWithCurrentStocks(voucherID, includeArchived);
    JSONObject voucherJSON = voucherService.generateResponseJSON(voucher, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (voucher != null) ? "ok" : "voucherNotFound");
    if (voucher != null) response.put("voucher", voucherJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutVoucher
  *
  *****************************************/

  private JSONObject processPutVoucher(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }


    /*****************************************
    *
    *  voucherID
    *
    *****************************************/

    String voucherID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (voucherID == null)
      {
        voucherID = voucherService.generateVoucherID();
        jsonRoot.put("id", voucherID);
      }

    /*****************************************
    *
    *  existing voucher
    *
    *****************************************/

    GUIManagedObject existingVoucher = voucherService.getStoredVoucher(voucherID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingVoucher != null && existingVoucher.getReadOnly())
      {
        response.put("id", existingVoucher.getGUIManagedObjectID());
        response.put("accepted", existingVoucher.getAccepted());
        response.put("valid", existingVoucher.getAccepted());
        response.put("processing", voucherService.isActiveVoucher(existingVoucher, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  check if voucher created by simple offer or standard voucher
    *
    *****************************************/
    if (existingVoucher == null)
      {
        jsonRoot.put("simpleOffer", false); // offer not a simpleOffer
      }
    
    if (existingVoucher != null)
      {
        if (existingVoucher instanceof Voucher)
          {
            if (((Voucher) existingVoucher).getSimpleOffer() == true)
              {
                String display = ((Voucher) existingVoucher).getGUIManagedObjectDisplay();
                String jsonRootDisplay = JSONUtilities.decodeString(jsonRoot, "display", false);
                if (!(jsonRootDisplay.equals(display)))
                  {
                    response.put("responseCode", "voucherNotValid");
                    response.put("responseMessage", "The display cannot be changed for the existing voucher");
                    return JSONUtilities.encodeObject(response);
                  }
                else
                  {
                    jsonRoot.put("simpleOffer", true);
                  }
              }
            else
              {
                jsonRoot.put("simpleOffer", false);
              }

    
    

          }
      }
    
    
    /*****************************************
    *
    *  process voucher
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {

        // get the voucher type to instantiate
        VoucherType voucherType = voucherTypeService.getActiveVoucherType(JSONUtilities.decodeString(jsonRoot,"voucherTypeId",true),now);
        if(log.isDebugEnabled()) log.debug("will use voucherType "+voucherType);

        // voucherType issue
        if(voucherType==null || voucherType.getCodeType()==VoucherType.CodeType.Unknown){
          response.put("responseCode","voucherTypeNotFound");
          return JSONUtilities.encodeObject(response);
        }

		// if stock update, and no more stock, need to warn it
		String responseMessage = null;
        Voucher voucher=null;
        if(voucherType.getCodeType()==VoucherType.CodeType.Shared){
          voucher = new VoucherShared(jsonRoot, epoch, existingVoucher, tenantID);
          if(log.isDebugEnabled()) log.debug("will put shared voucher "+voucher);
		  if(existingVoucher instanceof VoucherShared && !Objects.equals(((VoucherShared) existingVoucher).getStock(),((VoucherShared)voucher).getStock()) && StockMonitor.getRemainingStock((VoucherShared)voucher)==0) responseMessage = "no remaining stock";
        }
        if(voucher==null && voucherType.getCodeType()==VoucherType.CodeType.Personal){
          voucher = new VoucherPersonal(jsonRoot, epoch, existingVoucher,voucherType, tenantID);
          if(log.isDebugEnabled()) log.debug("will put personal voucher "+voucher);
        }

        voucher.validate(voucherTypeService,uploadedFileService,now);


        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            voucherService.putVoucher(voucher, (existingVoucher == null), userID);
            revalidateOffers(now, tenantID);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", voucher.getVoucherID());
        response.put("accepted", voucher.getAccepted());
        response.put("processing", voucherService.isActiveVoucher(voucher, now));
        response.put("responseCode", "ok");
		if(responseMessage!=null) response.put("responseMessage",responseMessage);
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            voucherService.putVoucher(incompleteObject, (existingVoucher == null), userID);
            revalidateOffers(now, tenantID);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "voucherNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveVoucher
  *
  *****************************************/

  private JSONObject processRemoveVoucher(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> vouchers = new ArrayList<>();
    JSONArray voucherIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single voucher
    //
    if (jsonRoot.containsKey("id"))
      {
        String voucherID = JSONUtilities.decodeString(jsonRoot, "id", false);
        voucherIDs.add(voucherID);
        GUIManagedObject voucher = voucherService.getStoredVoucher(voucherID);
        if (voucher != null && (force || !voucher.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (voucher != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "voucherNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        voucherIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
  
    for (int i = 0; i < voucherIDs.size(); i++)
      {
        String voucherID = voucherIDs.get(i).toString();
        GUIManagedObject voucher = voucherService.getStoredVoucher(voucherID);
        
        if (voucher != null && (force || !voucher.getReadOnly()))
          {
            vouchers.add(voucher);
            validIDs.add(voucherID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < vouchers.size(); i++)
      {

        GUIManagedObject voucher = vouchers.get(i);

        voucherService.removeVoucher(voucher.getGUIManagedObjectID(), userID, uploadedFileService, tenantID);
      }
    
    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedVoucherIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusVoucher
   *
   *****************************************/

  private JSONObject processSetStatusVoucher(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray voucherIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < voucherIDs.size(); i++)
      {

        String voucherID = voucherIDs.get(i).toString();
        GUIManagedObject existingElement = voucherService.getStoredVoucher(voucherID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(voucherID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);

            try
              {

                // get the voucher type to instantiate
                VoucherType voucherType = voucherTypeService
                    .getActiveVoucherType(JSONUtilities.decodeString(elementRoot, "voucherTypeId", true), now);
                if (log.isDebugEnabled())
                  log.debug("will use voucherType " + voucherType);

                Voucher voucher = null;
                if (voucherType.getCodeType() == VoucherType.CodeType.Shared)
                  {
                    voucher = new VoucherShared(elementRoot, epoch, existingElement, tenantID);
                    if (log.isDebugEnabled())
                      log.debug("will put shared voucher " + voucher);
                  }
                if (voucher == null && voucherType.getCodeType() == VoucherType.CodeType.Personal)
                  {
                    voucher = new VoucherPersonal(elementRoot, epoch, existingElement, voucherType, tenantID);
                    if (log.isDebugEnabled())
                      log.debug("will put personal voucher " + voucher);
                  }

                voucher.validate(voucherTypeService, uploadedFileService, now);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                voucherService.putVoucher(voucher, (existingElement == null), userID);
                revalidateOffers(now, tenantID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                voucherService.putVoucher(incompleteObject, (existingElement == null), userID);
                revalidateOffers(now, tenantID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  process voucher change action
  *
  *****************************************/

  private JSONObject processVoucherChange(String userID, JSONObject jsonRoot, VoucherChange.VoucherChangeAction voucherChangeAction, int tenantID) throws GUIManagerException
  {

    // response
    HashMap<String,Object> response = new HashMap<String,Object>();
    Date now = SystemTime.getCurrentTime();

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String voucherCode = JSONUtilities.decodeString(jsonRoot, "voucherCode", true);
    String voucherID = JSONUtilities.decodeString(jsonRoot, "voucherID", true);
    Date newExpiryDate = GUIManagedObject.parseDateField(JSONUtilities.decodeString(jsonRoot, "expiryDate", voucherChangeAction.equals(VoucherChange.VoucherChangeAction.Extend)));
    String origin = JSONUtilities.decodeString(jsonRoot, "origin", false);

    /*****************************************
     *
     *  resolve subscriberID
     *
     *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
    {
      log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
      response.put("responseCode", "CustomerNotFound");
      return JSONUtilities.encodeObject(response);
    }
    //build the request to send
    VoucherChange request = new VoucherChange(
            subscriberID,
            SystemTime.getCurrentTime(),
            newExpiryDate,
            zuksVoucherChange.getStringKey().concat("-").concat(Module.Customer_Care.toString()),
            voucherChangeAction,
            voucherCode,
            voucherID,
            null,
            DeliveryRequest.Module.Customer_Care.getExternalRepresentation(),
            (userID != null) ? userID : "1",//for PTT tests, never happens when called by browser
            origin,
            RESTAPIGenericReturnCodes.UNKNOWN,
            tenantID);

    // put a listener on the reponse topic
    Future<VoucherChange> waitingResponse=voucherChangeResponseListenerService.addWithOnValueFilter((value)->value.getEventID().equals(request.getEventID())&&value.getReturnStatus()!=RESTAPIGenericReturnCodes.UNKNOWN);
    // send the request
    String requestTopic = Deployment.getVoucherChangeRequestTopic();
    kafkaProducer.send(new ProducerRecord<byte[], byte[]>(
            requestTopic,
            StringKey.serde().serializer().serialize(requestTopic, new StringKey(subscriberID)),
            VoucherChange.serde().serializer().serialize(requestTopic, request)
    ));
    // check response
    VoucherChange voucherChangeResponse = handleWaitingResponse(waitingResponse);
    response.put("responseCode",voucherChangeResponse.getReturnStatus().equals(RESTAPIGenericReturnCodes.SUCCESS)?"ok":voucherChangeResponse.getReturnStatus().getGenericDescription());
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetMailTemplateList
  *
  *****************************************/

  private JSONObject processGetMailTemplateList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean externalOnly, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert templates
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> templates = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> templateObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < templateIDs.size(); i++)
          {
            String templateID = templateIDs.get(i).toString();
            GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID, includeArchived);
            if (template != null && template.getTenantID() == tenantID)
              {
                templateObjects.add(template);
              }
          }
      }
    else
      {
        templateObjects = subscriberMessageTemplateService.getStoredMailTemplates(externalOnly, includeArchived, tenantID);
      }
    for (GUIManagedObject template : templateObjects)
      {
        templates.add(subscriberMessageTemplateService.generateResponseJSON(template, fullDetails, now));
      }
    if (!fullDetails && jsonRoot.containsKey("areaAvailability"))
      {
        List<JSONObject> templatesWithAreaAvailability = new ArrayList<JSONObject>();
        JSONArray areaAvailability = JSONUtilities.decodeJSONArray(jsonRoot, "areaAvailability", false);
        for (JSONObject template : templates)
          {
            JSONArray mailTemplateAreaAvailability = (JSONArray) template.get("areaAvailability");
            if (mailTemplateAreaAvailability == null || mailTemplateAreaAvailability.isEmpty())
              {
                templatesWithAreaAvailability.add(template);
              }
            else
              {
                for (int i = 0; i < mailTemplateAreaAvailability.size(); i++)
                  {
                    if (areaAvailability.contains(mailTemplateAreaAvailability.get(i)))
                      {
                        templatesWithAreaAvailability.add(template);
                        break;
                      }
                  }
              }
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        HashMap<String,Object> response = new HashMap<String,Object>();;
        response.put("responseCode", "ok");
        response.put("templates", JSONUtilities.encodeArray(templatesWithAreaAvailability));
        return JSONUtilities.encodeObject(response);
      }


    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("templates", JSONUtilities.encodeArray(templates));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetMailTemplate
  *
  *****************************************/

  private JSONObject processGetMailTemplate(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String templateID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate template
    *
    *****************************************/

    GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID, includeArchived);
    template = (template != null && template.getGUIManagedObjectType() == GUIManagedObjectType.MailMessageTemplate) ? template : null;
    JSONObject templateJSON = subscriberMessageTemplateService.generateResponseJSON(template, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (template != null) ? "ok" : "templateNotFound");
    if (template != null) response.put("template", templateJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutMailTemplate
  *
  *****************************************/

  private JSONObject processPutMailTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  templateID
    *
    *****************************************/

    String templateID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (templateID == null)
      {
        templateID = subscriberMessageTemplateService.generateSubscriberMessageTemplateID();
        jsonRoot.put("id", templateID);
      }

    /*****************************************
    *
    *  existing template
    *
    *****************************************/

    GUIManagedObject existingTemplate = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID);
    existingTemplate = (existingTemplate != null && existingTemplate.getGUIManagedObjectType() == GUIManagedObjectType.MailMessageTemplate) ? existingTemplate : null;

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingTemplate != null && existingTemplate.getReadOnly())
      {
        response.put("id", existingTemplate.getGUIManagedObjectID());
        response.put("accepted", existingTemplate.getAccepted());
        response.put("processing", subscriberMessageTemplateService.isActiveSubscriberMessageTemplate(existingTemplate, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process template
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate template
        *
        ****************************************/

        MailTemplate mailTemplate = new MailTemplate(jsonRoot, epoch, existingTemplate, tenantID);

        /*****************************************
        *
        *  enhance with parameterTags
        *
        *****************************************/

        if (mailTemplate.getParameterTags().size() > 0)
          {
            List<JSONObject> parameterTags = new ArrayList<JSONObject>();
            for (CriterionField parameterTag : mailTemplate.getParameterTags())
              {
                parameterTags.add(parameterTag.getJSONRepresentation());
              }
            mailTemplate.getJSONRepresentation().put("parameterTags", JSONUtilities.encodeArray(parameterTags));
          }

        /*****************************************
        *
        *  store read-only copy
        *
        *****************************************/

        if (existingTemplate == null || mailTemplate.getEpoch() != existingTemplate.getEpoch())
          {
            if (! mailTemplate.getReadOnly())
              {
                MailTemplate readOnlyCopy = (MailTemplate) SubscriberMessageTemplate.newReadOnlyCopy(mailTemplate, subscriberMessageTemplateService, tenantID);
                mailTemplate.setReadOnlyCopyID(readOnlyCopy.getMailTemplateID());
                subscriberMessageTemplateService.putSubscriberMessageTemplate(readOnlyCopy, true, null);
              }
          }
        else if (existingTemplate.getAccepted())
          {
            mailTemplate.setReadOnlyCopyID(((MailTemplate) existingTemplate).getReadOnlyCopyID());
          }

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            subscriberMessageTemplateService.putSubscriberMessageTemplate(mailTemplate, (existingTemplate == null),
                userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", mailTemplate.getMailTemplateID());
        response.put("accepted", mailTemplate.getAccepted());
        response.put("processing", subscriberMessageTemplateService.isActiveSubscriberMessageTemplate(mailTemplate, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, GUIManagedObjectType.MailMessageTemplate, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            subscriberMessageTemplateService.putIncompleteSubscriberMessageTemplate(incompleteObject,
                (existingTemplate == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "mailTemplateNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveMailTemplate
  *
  *****************************************/

  private JSONObject processRemoveMailTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> mailTemplates = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray mailTemplateIDs = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single mailTemplate
    //
    if (jsonRoot.containsKey("id"))
      {
        String mailTemplateID = JSONUtilities.decodeString(jsonRoot, "id", false);
        mailTemplateIDs.add(mailTemplateID);
        GUIManagedObject mailTemplate = subscriberMessageTemplateService
            .getStoredSubscriberMessageTemplate(mailTemplateID);

        if (mailTemplate != null && (force || !mailTemplate.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (mailTemplate != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "templateNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        mailTemplateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < mailTemplateIDs.size(); i++)
      {
        String mailTemplateID = mailTemplateIDs.get(i).toString();
        GUIManagedObject mailTemplate = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(mailTemplateID);
        
        if (mailTemplate != null && (force || !mailTemplate.getReadOnly()))
          {
            mailTemplates.add(mailTemplate);
            validIDs.add(mailTemplateID);
          }
      }
        
  

    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < mailTemplates.size(); i++)
      {

        GUIManagedObject template = mailTemplates.get(i);
        template = (template != null && template.getGUIManagedObjectType() == GUIManagedObjectType.MailMessageTemplate)
            ? template
            : null;

        subscriberMessageTemplateService.removeSubscriberMessageTemplate(template.getGUIManagedObjectID(), userID, tenantID);
      
      }
    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }
    /*****************************************
     *
     * response
     *
     *****************************************/

    response.put("removedTemplateDS", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusMailTemplate
   *
   *****************************************/

  private JSONObject processSetStatusMailTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < templateIDs.size(); i++)
      {

        String templateID = templateIDs.get(i).toString();
        GUIManagedObject existingElement = subscriberMessageTemplateService
            .getStoredSubscriberMessageTemplate(templateID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(templateID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate template
                 *
                 ****************************************/

                MailTemplate mailTemplate = new MailTemplate(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                subscriberMessageTemplateService.putSubscriberMessageTemplate(mailTemplate, (existingElement == null),
                    userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot,
                    GUIManagedObjectType.MailMessageTemplate, epoch, tenantID);

                //
                // store
                //

                subscriberMessageTemplateService.putIncompleteSubscriberMessageTemplate(incompleteObject,
                    (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetSMSTemplateList
  *
  *****************************************/

  private JSONObject processGetSMSTemplateList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean externalOnly, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert templates
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> templates = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> templateObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < templateIDs.size(); i++)
          {
            String templateID = templateIDs.get(i).toString();
            GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID, includeArchived);
            if (template != null && template.getTenantID() == tenantID)
              {
                templateObjects.add(template);
              }
          }
      }
    else
      {
        templateObjects = subscriberMessageTemplateService.getStoredSMSTemplates(externalOnly, includeArchived, tenantID);
      }
    for (GUIManagedObject template : templateObjects)
      {
        templates.add(subscriberMessageTemplateService.generateResponseJSON(template, fullDetails, now));
      }
    
    if (!fullDetails && jsonRoot.containsKey("areaAvailability"))
      {
        List<JSONObject> templatesWithAreaAvailability = new ArrayList<JSONObject>();
        JSONArray areaAvailability = JSONUtilities.decodeJSONArray(jsonRoot, "areaAvailability", false);
        for (JSONObject template : templates)
          {
            JSONArray SMSTemplateAreaAvailability = (JSONArray) template.get("areaAvailability");
            if (SMSTemplateAreaAvailability == null || SMSTemplateAreaAvailability.isEmpty())
              {
                templatesWithAreaAvailability.add(template);
              }
            else
              {
                for (int i = 0; i < SMSTemplateAreaAvailability.size(); i++)
                  {
                    if (areaAvailability.contains(SMSTemplateAreaAvailability.get(i)))
                      {
                        templatesWithAreaAvailability.add(template);
                        break;
                      }
                  }
              }
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        HashMap<String,Object> response = new HashMap<String,Object>();;
        response.put("responseCode", "ok");
        response.put("templates", JSONUtilities.encodeArray(templatesWithAreaAvailability));
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("templates", JSONUtilities.encodeArray(templates));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetSMSTemplate
  *
  *****************************************/

  private JSONObject processGetSMSTemplate(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String templateID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate template
    *
    *****************************************/

    GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID, includeArchived);
    template = (template != null && template.getGUIManagedObjectType() == GUIManagedObjectType.SMSMessageTemplate) ? template : null;
    JSONObject templateJSON = subscriberMessageTemplateService.generateResponseJSON(template, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (template != null) ? "ok" : "templateNotFound");
    if (template != null) response.put("template", templateJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutSMSTemplate
  *
  *****************************************/

  private JSONObject processPutSMSTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  templateID
    *
    *****************************************/

    String templateID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (templateID == null)
      {
        templateID = subscriberMessageTemplateService.generateSubscriberMessageTemplateID();
        jsonRoot.put("id", templateID);
      }

    /*****************************************
    *
    *  existing template
    *
    *****************************************/

    GUIManagedObject existingTemplate = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID);
    existingTemplate = (existingTemplate != null && existingTemplate.getGUIManagedObjectType() == GUIManagedObjectType.SMSMessageTemplate) ? existingTemplate : null;

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingTemplate != null && existingTemplate.getReadOnly())
      {
        response.put("id", existingTemplate.getGUIManagedObjectID());
        response.put("accepted", existingTemplate.getAccepted());
        response.put("processing", subscriberMessageTemplateService.isActiveSubscriberMessageTemplate(existingTemplate, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process template
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate template
        *
        ****************************************/

        SMSTemplate smsTemplate = new SMSTemplate(jsonRoot, epoch, existingTemplate, tenantID);

        /*****************************************
        *
        *  enhance with parameterTags
        *
        *****************************************/

        if (smsTemplate.getParameterTags().size() > 0)
          {
            List<JSONObject> parameterTags = new ArrayList<JSONObject>();
            for (CriterionField parameterTag : smsTemplate.getParameterTags())
              {
                parameterTags.add(parameterTag.getJSONRepresentation());
              }
            smsTemplate.getJSONRepresentation().put("parameterTags", JSONUtilities.encodeArray(parameterTags));
          }

        /*****************************************
        *
        *  store read-only copy
        *
        *****************************************/

        if (existingTemplate == null || smsTemplate.getEpoch() != existingTemplate.getEpoch())
          {
            if (! smsTemplate.getReadOnly())
              {
                SMSTemplate readOnlyCopy = (SMSTemplate) SubscriberMessageTemplate.newReadOnlyCopy(smsTemplate, subscriberMessageTemplateService, tenantID);
                smsTemplate.setReadOnlyCopyID(readOnlyCopy.getSMSTemplateID());
                subscriberMessageTemplateService.putSubscriberMessageTemplate(readOnlyCopy, true, null);
              }
          }
        else if (existingTemplate.getAccepted())
          {
            smsTemplate.setReadOnlyCopyID(((SMSTemplate) existingTemplate).getReadOnlyCopyID());
          }

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            subscriberMessageTemplateService.putSubscriberMessageTemplate(smsTemplate, (existingTemplate == null),
                userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", smsTemplate.getSMSTemplateID());
        response.put("accepted", smsTemplate.getAccepted());
        response.put("processing", subscriberMessageTemplateService.isActiveSubscriberMessageTemplate(smsTemplate, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, GUIManagedObjectType.SMSMessageTemplate, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            subscriberMessageTemplateService.putIncompleteSubscriberMessageTemplate(incompleteObject,
                (existingTemplate == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "smsTemplateNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveSMSTemplate
  *
  *****************************************/

  private JSONObject processRemoveSMSTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> smsTemplates = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray smsTemplateIDs = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single smsTemplate
    //
    if (jsonRoot.containsKey("id"))
      {
        String smsTemplateID = JSONUtilities.decodeString(jsonRoot, "id", false);
        smsTemplateIDs.add(smsTemplateID);
        GUIManagedObject smsTemplate = subscriberMessageTemplateService
            .getStoredSubscriberMessageTemplate(smsTemplateID);

        if (smsTemplate != null && (force || !smsTemplate.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (smsTemplate != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "templateNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        smsTemplateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < smsTemplateIDs.size(); i++)
      {
        String smsTemplateID = smsTemplateIDs.get(i).toString();
        GUIManagedObject smsTemplate = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(smsTemplateID);
        
        if (smsTemplate != null && (force || !smsTemplate.getReadOnly()))
          {
            smsTemplates.add(smsTemplate);
            validIDs.add(smsTemplateID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < smsTemplates.size(); i++)
      {

        GUIManagedObject template = smsTemplates.get(i);
        template = (template != null && template.getGUIManagedObjectType() == GUIManagedObjectType.SMSMessageTemplate)
            ? template
            : null;

        subscriberMessageTemplateService.removeSubscriberMessageTemplate(template.getGUIManagedObjectID(), userID, tenantID);

      }
    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }
    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedTemplateIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusSMSTemplate
   *
   *****************************************/

  private JSONObject processSetStatusSMSTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < templateIDs.size(); i++)
      {

        String templateID = templateIDs.get(i).toString();
        GUIManagedObject existingElement = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(templateID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate template
                 *
                 ****************************************/

                SMSTemplate smsTemplate = new SMSTemplate(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/

                subscriberMessageTemplateService.putSubscriberMessageTemplate(smsTemplate, (existingElement == null),
                    userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot,
                    GUIManagedObjectType.SMSMessageTemplate, epoch, tenantID);

                //
                // store
                //

                subscriberMessageTemplateService.putIncompleteSubscriberMessageTemplate(incompleteObject,
                    (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetPushTemplateList
  *
  *****************************************/

  private JSONObject processGetPushTemplateList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean externalOnly, boolean includeArchived, int tenantID)
  {
    
    /****************************************
    *
    *  argument
    *
    ****************************************/

    String communicationChannelID = JSONUtilities.decodeString(jsonRoot, "communicationChannelID", false);
    
    /*****************************************
    *
    *  retrieve and convert templates
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> templates = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> templateObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < templateIDs.size(); i++)
          {
            String templateID = templateIDs.get(i).toString();
            GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID, includeArchived);
            if (template != null && template.getTenantID() == tenantID)
              {
                templateObjects.add(template);
              }
          }
      }
    else
      {
        templateObjects = subscriberMessageTemplateService.getStoredPushTemplates(externalOnly, includeArchived, tenantID);
      }
    for (GUIManagedObject template : templateObjects)
      {
        String templateCommunicationChannelID = (String) template.getJSONRepresentation().get("communicationChannelID");
        if(communicationChannelID == null || communicationChannelID.isEmpty() || communicationChannelID.equals(templateCommunicationChannelID)){
          templates.add(subscriberMessageTemplateService.generateResponseJSON(template, fullDetails, now));
        }
      }
    
    if (!fullDetails && jsonRoot.containsKey("areaAvailability"))
      {
        List<JSONObject> templatesWithAreaAvailability = new ArrayList<JSONObject>();
        JSONArray areaAvailability = JSONUtilities.decodeJSONArray(jsonRoot, "areaAvailability", false);
        for (JSONObject template : templates)
          {
            JSONArray pushTemplateAreaAvailability = (JSONArray) template.get("areaAvailability");
            if (pushTemplateAreaAvailability == null || pushTemplateAreaAvailability.isEmpty())
              {
                templatesWithAreaAvailability.add(template);
              }
            else
              {
                for (int i = 0; i < pushTemplateAreaAvailability.size(); i++)
                  {
                    if (areaAvailability.contains(pushTemplateAreaAvailability.get(i)))
                      {
                        templatesWithAreaAvailability.add(template);
                        break;
                      }
                  }
              }
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        HashMap<String,Object> response = new HashMap<String,Object>();;
        response.put("responseCode", "ok");
        response.put("templates", JSONUtilities.encodeArray(templatesWithAreaAvailability));
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("templates", JSONUtilities.encodeArray(templates));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetPushTemplate
  *
  *****************************************/

  private JSONObject processGetPushTemplate(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String templateID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate template
    *
    *****************************************/

    GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID, includeArchived);
    template = (template != null && (template.getGUIManagedObjectType() == GUIManagedObjectType.PushMessageTemplate)) ? template : null;
    JSONObject templateJSON = subscriberMessageTemplateService.generateResponseJSON(template, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (template != null) ? "ok" : "templateNotFound");
    if (template != null) response.put("template", templateJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutPushTemplate
  *
  *****************************************/

  @Deprecated
  private JSONObject processPutPushTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  templateID
    *
    *****************************************/

    String templateID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (templateID == null)
      {
        templateID = subscriberMessageTemplateService.generateSubscriberMessageTemplateID();
        jsonRoot.put("id", templateID);
      }

    /*****************************************
    *
    *  existing template
    *
    *****************************************/

    GUIManagedObject existingTemplate = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID);
    existingTemplate = (existingTemplate != null && existingTemplate.getGUIManagedObjectType() == GUIManagedObjectType.PushMessageTemplate) ? existingTemplate : null;

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingTemplate != null && existingTemplate.getReadOnly())
      {
        response.put("id", existingTemplate.getGUIManagedObjectID());
        response.put("accepted", existingTemplate.getAccepted());
        response.put("processing", subscriberMessageTemplateService.isActiveSubscriberMessageTemplate(existingTemplate, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process template
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate template
        *
        ****************************************/

        PushTemplate pushTemplate = new PushTemplate(jsonRoot, epoch, existingTemplate, tenantID);

        /*****************************************
        *
        *  enhance with parameterTags
        *
        *****************************************/

        if (pushTemplate.getParameterTags().size() > 0)
          {
            List<JSONObject> parameterTags = new ArrayList<JSONObject>();
            for (CriterionField parameterTag : pushTemplate.getParameterTags())
              {
                parameterTags.add(parameterTag.getJSONRepresentation());
              }
            pushTemplate.getJSONRepresentation().put("parameterTags", JSONUtilities.encodeArray(parameterTags));
          }

        /*****************************************
        *
        *  store read-only copy
        *
        *****************************************/

        if (existingTemplate == null || pushTemplate.getEpoch() != existingTemplate.getEpoch())
          {
            if (! pushTemplate.getReadOnly())
              {
                PushTemplate readOnlyCopy = (PushTemplate) SubscriberMessageTemplate.newReadOnlyCopy(pushTemplate, subscriberMessageTemplateService, tenantID);
                pushTemplate.setReadOnlyCopyID(readOnlyCopy.getPushTemplateID());
                subscriberMessageTemplateService.putSubscriberMessageTemplate(readOnlyCopy, true, null);
              }
          }
        else if (existingTemplate.getAccepted())
          {
            pushTemplate.setReadOnlyCopyID(((PushTemplate) existingTemplate).getReadOnlyCopyID());
          }

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            subscriberMessageTemplateService.putSubscriberMessageTemplate(pushTemplate, (existingTemplate == null),
                userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", pushTemplate.getGUIManagedObjectID());
        response.put("accepted", pushTemplate.getAccepted());
        response.put("processing", subscriberMessageTemplateService.isActiveSubscriberMessageTemplate(pushTemplate, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, GUIManagedObjectType.PushMessageTemplate, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            subscriberMessageTemplateService.putIncompleteSubscriberMessageTemplate(incompleteObject,
                (existingTemplate == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "pushTemplateNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemovePushTemplate
  *
  *****************************************/

  private JSONObject processRemovePushTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> templates = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray templateIDs = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single journey
    //
    if (jsonRoot.containsKey("id"))
      {
        String templateID = JSONUtilities.decodeString(jsonRoot, "id", false);
        templateIDs.add(templateID);
        GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID);

        if (template != null && (force || !template.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (template != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "templateNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < templateIDs.size(); i++)
      {
        String templateID = templateIDs.get(i).toString();
        GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID);
        
        if (template != null && (force || !template.getReadOnly()))
          {
            templates.add(template);
            validIDs.add(templateID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < templates.size(); i++)
      {

        GUIManagedObject template = templates.get(i);
        template = (template != null && template.getGUIManagedObjectType() == GUIManagedObjectType.PushMessageTemplate)
            ? template
            : null;

        subscriberMessageTemplateService.removeSubscriberMessageTemplate(template.getGUIManagedObjectID(), userID, tenantID);

      }
    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedTemplateIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusPushTemplate
   *
   *****************************************/
  private JSONObject processSetStatusPushTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < templateIDs.size(); i++)
      {

        String templateID = templateIDs.get(i).toString();
        GUIManagedObject existingElement = subscriberMessageTemplateService
            .getStoredSubscriberMessageTemplate(templateID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(templateID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate template
                 *
                 ****************************************/

                PushTemplate pushTemplate = new PushTemplate(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                subscriberMessageTemplateService.putSubscriberMessageTemplate(pushTemplate, (existingElement == null),
                    userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot,
                    GUIManagedObjectType.PushMessageTemplate, epoch, tenantID);

                //
                // store
                //

                subscriberMessageTemplateService.putIncompleteSubscriberMessageTemplate(incompleteObject,
                    (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetDialogTemplateList
  *
  *****************************************/

  private JSONObject processGetDialogTemplateList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean externalOnly, boolean includeArchived, int tenantID)
  {
    
    /****************************************
    *
    *  argument
    *
    ****************************************/

    String communicationChannelID = JSONUtilities.decodeString(jsonRoot, "communicationChannelID", false);
    
    /*****************************************
    *
    *  retrieve and convert templates
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> templates = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> templateObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < templateIDs.size(); i++)
          {
            String templateID = templateIDs.get(i).toString();
            GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID, includeArchived);
            if (template != null && template.getTenantID() == tenantID)
              {
                templateObjects.add(template);
              }
          }
      }
    else
      {
        templateObjects = subscriberMessageTemplateService.getStoredDialogTemplates(externalOnly, includeArchived, tenantID);
      }
    for (GUIManagedObject template : templateObjects)
      {
        String templateCommunicationChannelID = (String) template.getJSONRepresentation().get("communicationChannelID");
        if(communicationChannelID == null || communicationChannelID.isEmpty() || communicationChannelID.equals(templateCommunicationChannelID)){
          JSONObject templateJSON = subscriberMessageTemplateService.generateResponseJSON(template, fullDetails, now);
          templateJSON.put("communicationChannelID", templateCommunicationChannelID);
          templates.add(templateJSON);
        }
      }
    if (!fullDetails && jsonRoot.containsKey("areaAvailability"))
      {
        List<JSONObject> templatesWithAreaAvailability = new ArrayList<JSONObject>();
        JSONArray areaAvailability = JSONUtilities.decodeJSONArray(jsonRoot, "areaAvailability", false);
        for (JSONObject template : templates)
          {
            JSONArray dialogTemplateAreaAvailability = (JSONArray) template.get("areaAvailability");
            if (dialogTemplateAreaAvailability == null || dialogTemplateAreaAvailability.isEmpty())
              {
                templatesWithAreaAvailability.add(template);
              }
            else
              {
                for (int i = 0; i < dialogTemplateAreaAvailability.size(); i++)
                  {
                    if (areaAvailability.contains(dialogTemplateAreaAvailability.get(i)))
                      {
                        templatesWithAreaAvailability.add(template);
                        break;
                      }
                  }
              }
          }
        /*****************************************
         *
         * response
         *
         *****************************************/

        HashMap<String, Object> response = new HashMap<String, Object>();
        ;
        response.put("responseCode", "ok");
        response.put("templates", JSONUtilities.encodeArray(templatesWithAreaAvailability));
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("templates", JSONUtilities.encodeArray(templates));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetDialogTemplate
  *
  *****************************************/

  private JSONObject processGetDialogTemplate(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String templateID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate template
    *
    *****************************************/

    GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID, includeArchived);
    template = (template != null && template.getGUIManagedObjectType() == GUIManagedObjectType.DialogTemplate) ? template : null;
    JSONObject templateJSON = subscriberMessageTemplateService.generateResponseJSON(template, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (template != null) ? "ok" : "templateNotFound");
    if (template != null) response.put("template", templateJSON);
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processPutDialogTemplate
  *
  *****************************************/

  private JSONObject processPutDialogTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  templateID
    *
    *****************************************/

    String templateID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (templateID == null)
      {
        templateID = subscriberMessageTemplateService.generateSubscriberMessageTemplateID();
        jsonRoot.put("id", templateID);
      }

    /*****************************************
    *
    *  existing template
    *
    *****************************************/

    GUIManagedObject existingTemplate = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID);
    existingTemplate = (existingTemplate != null && existingTemplate.getGUIManagedObjectType() == GUIManagedObjectType.DialogTemplate) ? existingTemplate : null;

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingTemplate != null && existingTemplate.getReadOnly())
      {
        response.put("id", existingTemplate.getGUIManagedObjectID());
        response.put("accepted", existingTemplate.getAccepted());
        response.put("processing", subscriberMessageTemplateService.isActiveSubscriberMessageTemplate(existingTemplate, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process template
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate template
        *
        ****************************************/

        DialogTemplate dialogTemplate = new DialogTemplate(jsonRoot, epoch, existingTemplate, tenantID);

        /*****************************************
        *
        *  enhance with parameterTags
        *
        *****************************************/

        if (dialogTemplate.getParameterTags().size() > 0)
          {
            List<JSONObject> parameterTags = new ArrayList<JSONObject>();
            for (CriterionField parameterTag : dialogTemplate.getParameterTags())
              {
                parameterTags.add(parameterTag.getJSONRepresentation());
              }
            dialogTemplate.getJSONRepresentation().put("parameterTags", JSONUtilities.encodeArray(parameterTags));
          }

        /*****************************************
        *
        *  store read-only copy
        *
        *****************************************/

        if (existingTemplate == null || dialogTemplate.getEpoch() != existingTemplate.getEpoch())
          {
            if (! dialogTemplate.getReadOnly())
              {
                DialogTemplate readOnlyCopy = (DialogTemplate) SubscriberMessageTemplate.newReadOnlyCopy(dialogTemplate, subscriberMessageTemplateService, tenantID);
                dialogTemplate.setReadOnlyCopyID(readOnlyCopy.getDialogTemplateID());
                subscriberMessageTemplateService.putSubscriberMessageTemplate(readOnlyCopy, true, null);
              }
          }
        else if (existingTemplate.getAccepted())
          {
            dialogTemplate.setReadOnlyCopyID(((DialogTemplate) existingTemplate).getReadOnlyCopyID());
          }

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            subscriberMessageTemplateService.putSubscriberMessageTemplate(dialogTemplate, (existingTemplate == null),
                userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", dialogTemplate.getDialogTemplateID());
        response.put("accepted", dialogTemplate.getAccepted());
        response.put("processing", subscriberMessageTemplateService.isActiveSubscriberMessageTemplate(dialogTemplate, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, GUIManagedObjectType.DialogTemplate, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            subscriberMessageTemplateService.putIncompleteSubscriberMessageTemplate(incompleteObject,
                (existingTemplate == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "dialogTemplateNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveDialogTemplate
  *
  *****************************************/

  private JSONObject processRemoveDialogTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> templates = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray templateIDs = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single dialogTemplate
    //
    if (jsonRoot.containsKey("id"))
      {
        String templateID = JSONUtilities.decodeString(jsonRoot, "id", false);
        templateIDs.add(templateID);
        GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID);

        if (template != null && (force || !template.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (template != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "templateNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < templateIDs.size(); i++)
      {
        String templateID = templateIDs.get(i).toString();
        GUIManagedObject template = subscriberMessageTemplateService.getStoredSubscriberMessageTemplate(templateID);
        
        if (template != null && (force || !template.getReadOnly()))
          {
            templates.add(template);
            validIDs.add(templateID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < templates.size(); i++)
      {

        GUIManagedObject template = templates.get(i);
        template = (template != null && template.getGUIManagedObjectType() == GUIManagedObjectType.DialogTemplate)
            ? template
            : null;

        subscriberMessageTemplateService.removeSubscriberMessageTemplate(template.getGUIManagedObjectID(), userID, tenantID);

      }
    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/

    response.put("removedtemplateIDS", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }
  

  /*****************************************
   *
   * processSetStatusDialogTemplate
   *
   *****************************************/

  private JSONObject processSetStatusDialogTemplate(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray templateIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < templateIDs.size(); i++)
      {

        String templateID = templateIDs.get(i).toString();
        GUIManagedObject existingElement = subscriberMessageTemplateService
            .getStoredSubscriberMessageTemplate(templateID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(templateID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate template
                 *
                 ****************************************/

                DialogTemplate dialogTemplate = new DialogTemplate(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                subscriberMessageTemplateService.putSubscriberMessageTemplate(dialogTemplate, (existingElement == null),
                    userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot,
                    GUIManagedObjectType.DialogTemplate, epoch, tenantID);

                //
                // store
                //

                subscriberMessageTemplateService.putIncompleteSubscriberMessageTemplate(incompleteObject,
                    (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }



  /*****************************************
  *
  *  processGetFulfillmentProviders
  *
  *****************************************/

  private JSONObject processGetFulfillmentProviders(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve fulfillment providers
    *
    *****************************************/

    List<JSONObject> fulfillmentProviders = new ArrayList<JSONObject>();
    for(DeliveryManagerDeclaration deliveryManager : Deployment.getDeployment(tenantID).getFulfillmentProviders().values())
      {
        Map<String, String> providerJSON = new HashMap<String, String>();
        providerJSON.put("id", deliveryManager.getProviderID());
        providerJSON.put("name", deliveryManager.getProviderName());
        providerJSON.put("providerType", (deliveryManager.getProviderType() != null) ? deliveryManager.getProviderType().toString() : null);
        providerJSON.put("deliveryType", deliveryManager.getDeliveryType());
        providerJSON.put("url", (String) deliveryManager.getJSONRepresentation().get("url"));
        fulfillmentProviders.add(JSONUtilities.encodeObject(providerJSON));
      } 

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("fulfillmentProviders", JSONUtilities.encodeArray(fulfillmentProviders));
    return JSONUtilities.encodeObject(response);
  }  

  /*****************************************
  *
  *  processGetPaymentMeanList
  *
  *****************************************/

  private JSONObject processGetPaymentMeanList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {

    /*****************************************
    *
    *  retrieve payment means
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> paymentMeans = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> paymentMeanObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray paymentMeanIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < paymentMeanIDs.size(); i++)
          {
            String paymentMeanID = paymentMeanIDs.get(i).toString();
            GUIManagedObject paymentMean = paymentMeanService.getStoredPaymentMean(paymentMeanID, includeArchived);
            if (paymentMean != null && paymentMean.getTenantID() == tenantID)
              {
                paymentMeanObjects.add(paymentMean);
              }
          }
      }
    else
      {
        paymentMeanObjects = paymentMeanService.getStoredPaymentMeans(includeArchived, tenantID);
      }
    for (GUIManagedObject paymentMean : paymentMeanObjects)
      {
        paymentMeans.add(paymentMeanService.generateResponseJSON(paymentMean, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("paymentMeans", JSONUtilities.encodeArray(paymentMeans));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetCustomer
  * @throws GUIManagerException
  *
  *****************************************/

  private JSONObject processGetCustomer(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {

    Map<String, Object> response = new LinkedHashMap<String, Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);

    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID {}", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
      }

    /*****************************************
    *
    *  getSubscriberProfile
    *
    *****************************************/

    if (subscriberID != null)
      {
        try
          {
            SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, true);
            if (baseSubscriberProfile == null)
              {
                response.put("responseCode", "CustomerNotFound");
              }
            else
              {
                response = baseSubscriberProfile.getProfileMapForGUIPresentation(subscriberProfileService, loyaltyProgramService, segmentationDimensionService, targetService, pointService, complexObjectTypeService, voucherService, voucherTypeService, exclusionInclusionTargetService, subscriberGroupEpochReader);
                response.put("responseCode", "ok");
              }
          }
        catch (SubscriberProfileServiceException e)
          {
            throw new GUIManagerException(e);
          }
      }

    /*****************************************
    *
    *  return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetCustomerMetaData
  *
  *****************************************/

  private JSONObject processGetCustomerMetaData(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    Map<String, Object> response = new HashMap<String, Object>();

    /***************************************
    *
    *  argument
    *
    ****************************************/

    //
    //  no args
    //

    /*****************************************
    *
    *  retrieve CustomerMetaData
    *
    *****************************************/

    List<JSONObject> generalDetailsMetaDataList = Deployment.getDeployment(tenantID).getCustomerMetaData().getGeneralDetailsMetaData().stream().map(generalDetailsMetaData -> generalDetailsMetaData.getJSONRepresentation()).collect(Collectors.toList());
    List<JSONObject> kpisMetaDataList = Deployment.getDeployment(tenantID).getCustomerMetaData().getKpiMetaData().stream().map(kpisMetaData -> kpisMetaData.getJSONRepresentation()).collect(Collectors.toList());
    List<JSONObject> complexObjectMetaDataList = complexObjectTypeService.getActiveComplexObjectTypes(SystemTime.getCurrentTime(), tenantID).stream().map(complexMetaData -> complexMetaData.getJSONRepresentation()).collect(Collectors.toList()); 
    
    
    response.put("generalDetailsMetaData", JSONUtilities.encodeArray(generalDetailsMetaDataList));
    response.put("kpisMetaData", JSONUtilities.encodeArray(kpisMetaDataList));
    response.put("complexObjectsMetaData", JSONUtilities.encodeArray(complexObjectMetaDataList));
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", "ok");

    /****************************************
    *
    *  return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  * processGetCustomerBDRs
  *
  *****************************************/

  private JSONObject processGetCustomerBDRs(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {

    /****************************************
    *
    *  response
    *
    ****************************************/
    
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String startDateReq = JSONUtilities.decodeString(jsonRoot, "startDate", false);
    String moduleID = JSONUtilities.decodeString(jsonRoot, "moduleID", false);
    String featureID = JSONUtilities.decodeString(jsonRoot, "featureID", false);
    JSONArray deliverableIDs = JSONUtilities.decodeJSONArray(jsonRoot, "deliverableIDs", false);

    
    //
    //  filters
    //
    
    Collection<String> deliverableIDCollection = new ArrayList<String>();
    List<QueryBuilder> filters = new ArrayList<QueryBuilder>();
    if (moduleID != null && !moduleID.isEmpty()) filters.add(QueryBuilders.matchQuery("moduleID", moduleID));
    if (featureID != null && !featureID.isEmpty()) filters.add(QueryBuilders.matchQuery("featureID", featureID));
    if (deliverableIDs != null)
      {
        for(int i=0; i<deliverableIDs.size(); i++)
          {
            deliverableIDCollection.add(deliverableIDs.get(i).toString());
          }
        if (!deliverableIDCollection.isEmpty()) filters.add(QueryBuilders.termsQuery("deliverableID", deliverableIDCollection));
      }

    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
      }
    else
      {
        /*****************************************
        *
        *  getSubscriberProfile
        *
        *****************************************/
        try
          {
            SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
            if (baseSubscriberProfile == null)
              {
                response.put("responseCode", "CustomerNotFound");
                log.debug("SubscriberProfile is null for subscriberID {}" , subscriberID);
              }
            else
              {
                List<JSONObject> BDRsJson = new ArrayList<JSONObject>();
                
                //
                // read history
                //

                SearchRequest searchRequest = this.elasticsearch.getSearchRequest(API.getCustomerBDRs, subscriberID, startDateReq == null ? null : RLMDateUtils.parseDateFromDay(startDateReq, Deployment.getDeployment(tenantID).getTimeZone()), filters, tenantID);
                List<SearchHit> hits = this.elasticsearch.getESHits(searchRequest);
                for (SearchHit hit : hits)
                  {
                    Map<String, Object> esFields = hit.getSourceAsMap();
                    CommodityDeliveryRequest commodityDeliveryRequest = new CommodityDeliveryRequest(esFields);
                    Map<String, Object> esbdrMap = commodityDeliveryRequest.getGUIPresentationMap(subscriberMessageTemplateService, salesChannelService, journeyService, offerService, loyaltyProgramService, productService, voucherService, deliverableService, paymentMeanService, resellerService, tenantID);
                    BDRsJson.add(JSONUtilities.encodeObject(esbdrMap));
                  }

                //
                // prepare response
                //

                response.put("BDRs", JSONUtilities.encodeArray(BDRsJson));
                response.put("responseCode", "ok");
              }
          }
        catch (SubscriberProfileServiceException | java.text.ParseException e)
          {
            throw new GUIManagerException(e);
          }
      }

    /*****************************************
    *
    *  return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  * processGetCustomerEDRs
  *
  *****************************************/

  private JSONObject processGetCustomerEDRs(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {

    /****************************************
    *
    *  response
    *
    ****************************************/
    
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String startDateReq = JSONUtilities.decodeString(jsonRoot, "startDate", false);
    String eventID = JSONUtilities.decodeString(jsonRoot, "eventID", false);
    
    //
    //  filters
    //
    
    List<QueryBuilder> filters = new ArrayList<QueryBuilder>();
    if (eventID != null && !eventID.isEmpty()) filters.add(QueryBuilders.matchQuery("eventID", eventID));

    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
      }
    else
      {
        /*****************************************
        *
        *  getSubscriberProfile
        *
        *****************************************/
        try
          {
            SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
            if (baseSubscriberProfile == null)
              {
                response.put("responseCode", "CustomerNotFound");
                log.debug("SubscriberProfile is null for subscriberID {}" , subscriberID);
              }
            else
              {
                List<JSONObject> EDRsJson = new ArrayList<JSONObject>();
                
                //
                // read history
                //

                SearchRequest searchRequest = this.elasticsearch.getSearchRequest(API.getCustomerEDRs, subscriberID, startDateReq == null ? null : RLMDateUtils.parseDateFromDay(startDateReq, Deployment.getDeployment(tenantID).getTimeZone()), filters, tenantID);
                List<SearchHit> hits = this.elasticsearch.getESHits(searchRequest);
                for (SearchHit hit : hits)
                  {
                    Map<String, Object> esFields = hit.getSourceAsMap();
                    EDRsJson.add(JSONUtilities.encodeObject(esFields));
                  }

                //
                // prepare response
                //

                response.put("EDRs", JSONUtilities.encodeArray(EDRsJson));
                response.put("responseCode", "ok");
              }
          }
        catch (SubscriberProfileServiceException | java.text.ParseException e)
          {
            throw new GUIManagerException(e);
          }
      }

    /*****************************************
    *
    *  return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  * processGetCustomerODRs
  *
  *****************************************/

  private JSONObject processGetCustomerODRs(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {

    /****************************************
    *
    *  response
    *
    ****************************************/
    
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String startDateReq = JSONUtilities.decodeString(jsonRoot, "startDate", false);
    String moduleID = JSONUtilities.decodeString(jsonRoot, "moduleID", false);
    String featureID = JSONUtilities.decodeString(jsonRoot, "featureID", false);
    String offerID = JSONUtilities.decodeString(jsonRoot, "offerID", false);
    String salesChannelID = JSONUtilities.decodeString(jsonRoot, "salesChannelID", false);
    String paymentMeanID = JSONUtilities.decodeString(jsonRoot, "paymentMeanID", false);
    
    List<QueryBuilder> filters = new ArrayList<QueryBuilder>();
    if (moduleID != null && !moduleID.isEmpty()) filters.add(QueryBuilders.matchQuery("moduleID", moduleID));
    if (featureID != null && !featureID.isEmpty()) filters.add(QueryBuilders.matchQuery("featureID", featureID));
    if (offerID != null && !offerID.isEmpty()) filters.add(QueryBuilders.matchQuery("offerID", offerID));
    if (salesChannelID != null && !salesChannelID.isEmpty()) filters.add(QueryBuilders.matchQuery("salesChannelID", salesChannelID));

    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
      }
    else
      {
        /*****************************************
        *
        *  getSubscriberProfile - include history
        *
        *****************************************/
        try
          {
            SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
            if (baseSubscriberProfile == null)
              {
                response.put("responseCode", "CustomerNotFound");
                log.debug("SubscriberProfile is null for subscriberID {}" , subscriberID);
              }
            else
              {
                List<JSONObject> ODRsJson = new ArrayList<JSONObject>();
                
                List<DeliveryRequest> ODRs = new ArrayList<DeliveryRequest>();
                SearchRequest searchRequest = this.elasticsearch.getSearchRequest(API.getCustomerODRs, subscriberID, startDateReq == null ? null : RLMDateUtils.parseDateFromDay(startDateReq, Deployment.getDeployment(tenantID).getTimeZone()), filters, tenantID);
                List<SearchHit> hits = this.elasticsearch.getESHits(searchRequest);
                for (SearchHit hit : hits)
                  {
                    PurchaseFulfillmentRequest purchaseFulfillmentRequest = new PurchaseFulfillmentRequest(hit.getSourceAsMap(), supplierService, offerService, productService, voucherService, resellerService);
                    ODRs.add(purchaseFulfillmentRequest);
                  }

                //
                // filter on paymentMeanID * NOT in ES SHOULD BE FILTER AS IT IS *
                //

                if (paymentMeanID != null)
                  {
                    List<DeliveryRequest> result = new ArrayList<DeliveryRequest>();
                    for (DeliveryRequest request : ODRs)
                      {
                        if (request instanceof PurchaseFulfillmentRequest)
                          {
                            PurchaseFulfillmentRequest odrRequest = (PurchaseFulfillmentRequest) request;
                            Offer offer = (Offer) offerService.getStoredGUIManagedObject(odrRequest.getOfferID());
                            if (offer != null)
                              {
                                if (offer.getOfferSalesChannelsAndPrices() != null)
                                  {
                                    for (OfferSalesChannelsAndPrice channel : offer.getOfferSalesChannelsAndPrices())
                                      {
                                        if (channel.getPrice() != null && paymentMeanID.equals(channel.getPrice().getPaymentMeanID()))
                                          {
                                            result.add(request);
                                          }
                                      }
                                  }
                              }
                          }
                      }
                    ODRs = result;
                  }

                //
                // filter using dates and prepare json
                //

                for (DeliveryRequest odr : ODRs)
                  {
                    Map<String, Object> presentationMap = odr.getGUIPresentationMap(subscriberMessageTemplateService, salesChannelService, journeyService, offerService, loyaltyProgramService, productService, voucherService, deliverableService, paymentMeanService, resellerService, tenantID);
                    ODRsJson.add(JSONUtilities.encodeObject(presentationMap));
                  }

                //
                // prepare response
                //

                response.put("ODRs", JSONUtilities.encodeArray(ODRsJson));
                response.put("responseCode", "ok");
              }
          }
        catch (SubscriberProfileServiceException | java.text.ParseException e)
          {
            throw new GUIManagerException(e);
          }
      }

    /*****************************************
    *
    *  return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  * processGetCustomerMessages
  *
  *****************************************/

  private JSONObject processGetCustomerMessages(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    
    /****************************************
    *
    *  response
    *
    ****************************************/
    
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String startDateReq = JSONUtilities.decodeString(jsonRoot, "startDate", false);
    String moduleID = JSONUtilities.decodeString(jsonRoot, "moduleID", false);
    String featureID = JSONUtilities.decodeString(jsonRoot, "featureID", false);
    
    //
    //  filters
    //
    
    List<QueryBuilder> filters = new ArrayList<QueryBuilder>();
    if (moduleID != null && !moduleID.isEmpty()) filters.add(QueryBuilders.matchQuery("moduleID", moduleID));
    if (featureID != null && !featureID.isEmpty()) filters.add(QueryBuilders.matchQuery("featureID", featureID));

    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
      }
    else
      {
        /*****************************************
        *
        *  getSubscriberProfile
        *
        *****************************************/
        try
          {
            SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
            if (baseSubscriberProfile == null)
              {
                response.put("responseCode", "CustomerNotFound");
                log.debug("SubscriberProfile is null for subscriberID {}" , subscriberID);
              }
            else
              {
                List<JSONObject> messagesJson = new ArrayList<JSONObject>();
                SearchRequest searchRequest = this.elasticsearch.getSearchRequest(API.getCustomerMessages, subscriberID, startDateReq == null ? null : RLMDateUtils.parseDateFromDay(startDateReq, Deployment.getDeployment(tenantID).getTimeZone()), filters, tenantID);
                List<SearchHit> hits = this.elasticsearch.getESHits(searchRequest);
                for (SearchHit hit : hits)
                  {
                    String channelID = (String) hit.getSourceAsMap().get("channelID");
                    if (channelID != null && !channelID.isEmpty())
                      {
                        String deliveryType = null;
                        for (String deliveryTypeInMap : Deployment.getDeliveryTypeCommunicationChannelIDMap().keySet())
                          {
                            String chID = Deployment.getDeliveryTypeCommunicationChannelIDMap().get(deliveryTypeInMap);
                            if (channelID.equals(chID))
                              {
                                deliveryType = deliveryTypeInMap;
                                break;
                              }
                          }
                        if (deliveryType != null && Deployment.getDeliveryManagers().get(deliveryType) != null)
                          {
                            String requestClass = Deployment.getDeliveryManagers().get(deliveryType).getRequestClassName();
                            if (requestClass != null)
                              {
                                DeliveryRequest notification = ElasticsearchClientAPI.getNotificationDeliveryRequest(requestClass, hit);
                                if (notification != null)
                                  {
                                    Map<String, Object> esNotificationMap = notification.getGUIPresentationMap(subscriberMessageTemplateService, salesChannelService, journeyService, offerService, loyaltyProgramService, productService, voucherService, deliverableService, paymentMeanService, resellerService, tenantID);
                                    messagesJson.add(JSONUtilities.encodeObject(esNotificationMap));
                                  }
                              }
                          }
                      }
                  }

                //
                // prepare response
                //

                response.put("messages", JSONUtilities.encodeArray(messagesJson));
                response.put("responseCode", "ok");
              }
          }
        catch (SubscriberProfileServiceException | java.text.ParseException e)
          {
            throw new GUIManagerException(e);
          }
      }

    /*****************************************
    *
    *  return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  * processGetCustomerJourneys
  *
  *****************************************/

  private JSONObject processGetCustomerJourneys(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    Date now = SystemTime.getCurrentTime();
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String journeyObjectiveName = JSONUtilities.decodeString(jsonRoot, "objective", false);
    String journeyState = JSONUtilities.decodeString(jsonRoot, "journeyState", false);
    String customerStatus = JSONUtilities.decodeString(jsonRoot, "customerStatus", false);
    String journeyStartDateStr = JSONUtilities.decodeString(jsonRoot, "journeyStartDate", false);
    String journeyEndDateStr = JSONUtilities.decodeString(jsonRoot, "journeyEndDate", false);
    
    List<QueryBuilder> filters = new ArrayList<QueryBuilder>();

    Date journeyStartDate;
    Date journeyEndDate;
    try
      {
        String timeZone = Deployment.getDeployment(tenantID).getTimeZone();
        journeyStartDate = prepareStartDate(RLMDateUtils.parseDateFromDay(journeyStartDateStr, timeZone), timeZone);
        journeyEndDate = prepareEndDate(RLMDateUtils.parseDateFromDay(journeyEndDateStr, timeZone), timeZone);
      } 
    catch (java.text.ParseException e1)
      {
        throw new GUIManagerException(e1);
      }

    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
      }
    else
      {
        /*****************************************
        *
        *  getSubscriberProfile
        *
        *****************************************/
        try
          {
            SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
            if (baseSubscriberProfile == null)
              {
                response.put("responseCode", "CustomerNotFound");
                log.debug("SubscriberProfile is null for subscriberID {}" , subscriberID);
              }
            else
              {
                List<JSONObject> journeysJson = new ArrayList<JSONObject>();
                SearchRequest searchRequest = this.elasticsearch.getSearchRequest(API.getCustomerJourneys, subscriberID, journeyStartDate, filters, tenantID);
                List<SearchHit> hits = this.elasticsearch.getESHits(searchRequest);
                Map<String, JourneyHistory> journeyHistoryMap = new HashMap<String, JourneyHistory>(hits.size());
                for (SearchHit hit : hits)
                  {
                    Map<String, Object> esFields = hit.getSourceAsMap();
                    JourneyHistory journeyHistory = new JourneyHistory(esFields);
                    journeyHistoryMap.put(journeyHistory.getJourneyID(), journeyHistory);
                  }

                //
                // read campaigns
                //

                Collection<GUIManagedObject> stroeRawJourneys = journeyService.getStoredJourneys(true, tenantID);
                List<Journey> storeJourneys = new ArrayList<Journey>();
                for (GUIManagedObject storeJourney : stroeRawJourneys)
                  {
                    if (storeJourney instanceof Journey) storeJourneys.add((Journey) storeJourney);
                  }

                //
                // filter Journeys
                //

                storeJourneys = storeJourneys.stream().filter(journey -> journey.getGUIManagedObjectType() == GUIManagedObjectType.Journey).collect(Collectors.toList());

                //
                // filter on journeyStartDate
                //

                if (journeyStartDate != null)
                  {
                    storeJourneys = storeJourneys.stream().filter(journey -> (journey.getEffectiveStartDate() == null || journey.getEffectiveStartDate().compareTo(journeyStartDate) >= 0)).collect(Collectors.toList());
                  }

                //
                // filter on journeyEndDate
                //

                if (journeyEndDate != null)
                  {
                    storeJourneys = storeJourneys.stream().filter(journey -> (journey.getEffectiveEndDate() == null || journey.getEffectiveEndDate().compareTo(journeyEndDate) <= 0)).collect(Collectors.toList());
                  }

                //
                // filter on journeyObjectiveName
                //

                if (journeyObjectiveName != null && !journeyObjectiveName.isEmpty())
                  {

                    //
                    // read objective
                    //

                    Collection<JourneyObjective> activejourneyObjectives = journeyObjectiveService.getActiveJourneyObjectives(SystemTime.getCurrentTime(), tenantID);

                    //
                    // filter activejourneyObjective by name
                    //

                    List<JourneyObjective> journeyObjectives = activejourneyObjectives.stream().filter(journeyObj -> journeyObjectiveName.equals(journeyObj.getJSONRepresentation().get("display"))).collect(Collectors.toList());
                    JourneyObjective exactJourneyObjective = journeyObjectives.size() > 0 ? journeyObjectives.get(0) : null;

                    //
                    // filter
                    //
                    if (exactJourneyObjective == null)
                      storeJourneys = new ArrayList<Journey>();
                    else
                      storeJourneys = storeJourneys.stream().filter(journey -> (journey.getJourneyObjectiveInstances() != null && (journey.getJourneyObjectiveInstances().stream().filter(obj -> obj.getJourneyObjectiveID().equals(exactJourneyObjective.getJourneyObjectiveID())).count() > 0L))).collect(Collectors.toList());

                  }

                for (Journey storeJourney : storeJourneys)
                  {

                    //
                    // subsLatestStatistic
                    //

                    JourneyHistory subsLatestStatistic = journeyHistoryMap.get(storeJourney.getJourneyID());

                    //
                    // continue if not in stat
                    //

                    if (subsLatestStatistic == null) continue;

                    //
                    // filter on journeyState
                    //

                    if (journeyState != null && !journeyState.isEmpty())
                      {
                        boolean criteriaSatisfied = false;
                        if (journeyService.getJourneyStatus(storeJourney).getExternalRepresentation().equalsIgnoreCase(journeyState))
                          {
                            criteriaSatisfied = true;
                          }
                        if (!criteriaSatisfied)
                          continue;
                      }

                    //
                    // filter on customerStatus
                    //

                    boolean statusNotified = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> SubscriberJourneyStatus.Notified.getExternalRepresentation().equals(campaignStat.getStatus())).count() > 0L;
                    boolean statusConverted = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> campaignStat.isConverted()).count() > 0L;
                    Boolean statusTargetGroup = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> SubscriberJourneyStatus.Targeted.getExternalRepresentation().equals(campaignStat.getStatus())).count() > 0L;
                    Boolean statusControlGroup = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> SubscriberJourneyStatus.ControlGroup.getExternalRepresentation().equals(campaignStat.getStatus()) || SubscriberJourneyStatus.ControlGroupConverted.getExternalRepresentation().equals(campaignStat.getStatus())).count() > 0L;
                    Boolean statusUniversalControlGroup = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> SubscriberJourneyStatus.UniversalControlGroup.getExternalRepresentation().equals(campaignStat.getStatus()) || SubscriberJourneyStatus.UniversalControlGroupConverted.getExternalRepresentation().equals(campaignStat.getStatus())).count() > 0L;
                    boolean journeyComplete = subsLatestStatistic.getStatusHistory().stream().filter(journeyStat -> journeyStat.getJourneyComplete()).count() > 0L;

                    SubscriberJourneyStatus customerStatusInJourney = Journey.getSubscriberJourneyStatus(statusConverted, statusNotified, statusTargetGroup, statusControlGroup, statusUniversalControlGroup);
                    SubscriberJourneyStatus profilejourneyStatus = baseSubscriberProfile.getSubscriberJourneys().get(storeJourney.getJourneyID() + "");
                    if (profilejourneyStatus.in(SubscriberJourneyStatus.NotEligible, SubscriberJourneyStatus.UniversalControlGroup, SubscriberJourneyStatus.Excluded, SubscriberJourneyStatus.ObjectiveLimitReached)) {
                      customerStatusInJourney = profilejourneyStatus;
                    }

                    if (customerStatus != null)
                      {
                        SubscriberJourneyStatus customerStatusInReq = SubscriberJourneyStatus.fromExternalRepresentation(customerStatus);
                        boolean criteriaSatisfied = customerStatusInJourney == customerStatusInReq;
                        if (!criteriaSatisfied) continue;
                      }

                    //
                    // prepare response
                    //

                    Map<String, Object> journeyResponseMap = new HashMap<String, Object>();
                    journeyResponseMap.put("journeyID", storeJourney.getJourneyID());
                    journeyResponseMap.put("journeyName", journeyService.generateResponseJSON(storeJourney, true, SystemTime.getCurrentTime()).get("display"));
                    journeyResponseMap.put("description", journeyService.generateResponseJSON(storeJourney, true, SystemTime.getCurrentTime()).get("description")); // @rl:
                                                                                                                                                                    // maybe
                                                                                                                                                                    // generateJSON
                                                                                                                                                                    // only
                                                                                                                                                                    // once?
                    journeyResponseMap.put("startDate", getDateString(storeJourney.getEffectiveStartDate(), tenantID));
                    journeyResponseMap.put("endDate", getDateString(storeJourney.getEffectiveEndDate(), tenantID));
                    journeyResponseMap.put("entryDate", getDateString(subsLatestStatistic.getJourneyEntranceDate(), tenantID));
                    journeyResponseMap.put("exitDate", subsLatestStatistic.getJourneyExitDate(journeyService) != null ? getDateString(subsLatestStatistic.getJourneyExitDate(journeyService), tenantID) : "");
                    journeyResponseMap.put("journeyState", journeyService.getJourneyStatus(storeJourney).getExternalRepresentation());

                    List<JSONObject> resultObjectives = new ArrayList<JSONObject>();
                    for (JourneyObjectiveInstance journeyObjectiveInstance : storeJourney.getJourneyObjectiveInstances())
                      {
                        List<JSONObject> resultCharacteristics = new ArrayList<JSONObject>();
                        JSONObject result = new JSONObject();

                        JourneyObjective journeyObjective = journeyObjectiveService.getActiveJourneyObjective(journeyObjectiveInstance.getJourneyObjectiveID(), SystemTime.getCurrentTime());
                        result.put("active", journeyObjective.getActive());
                        result.put("parentJourneyObjectiveID", journeyObjective.getParentJourneyObjectiveID());
                        result.put("display", journeyObjective.getJSONRepresentation().get("display"));
                        result.put("readOnly", journeyObjective.getReadOnly());
                        result.put("name", journeyObjective.getGUIManagedObjectName());
                        result.put("contactPolicyID", journeyObjective.getContactPolicyID());
                        result.put("id", journeyObjective.getGUIManagedObjectID());

                        for (CatalogCharacteristicInstance catalogCharacteristicInstance : journeyObjectiveInstance.getCatalogCharacteristics())
                          {
                            JSONObject characteristics = new JSONObject();
                            characteristics.put("catalogCharacteristicID", catalogCharacteristicInstance.getCatalogCharacteristicID());
                            characteristics.put("value", catalogCharacteristicInstance.getValue());
                            resultCharacteristics.add(characteristics);
                          }

                        result.put("catalogCharacteristics", JSONUtilities.encodeArray(resultCharacteristics));
                        resultObjectives.add(result);
                      }

                    journeyResponseMap.put("objectives", JSONUtilities.encodeArray(resultObjectives));

                    Map<String, Object> currentState = new HashMap<String, Object>();
                    NodeHistory nodeHistory = subsLatestStatistic.getLastNodeEntered();
                    currentState.put("nodeID", nodeHistory.getToNodeID());
                    currentState.put("nodeName", nodeHistory.getToNodeID() == null ? null : (storeJourney.getJourneyNode(nodeHistory.getToNodeID()) == null ? "node has been removed" : storeJourney.getJourneyNode(nodeHistory.getToNodeID()).getNodeName()));
                    JSONObject currentStateJson = JSONUtilities.encodeObject(currentState);

                    //
                    // node history
                    //


                    List<JSONObject> nodeHistoriesJson = new ArrayList<JSONObject>();
                    for (NodeHistory journeyHistories : subsLatestStatistic.getNodeHistory())
                      {
                        Map<String, Object> nodeHistoriesMap = new HashMap<String, Object>();
                        nodeHistoriesMap.put("fromNodeID", journeyHistories.getFromNodeID());
                        nodeHistoriesMap.put("toNodeID", journeyHistories.getToNodeID());
                        nodeHistoriesMap.put("fromNode", journeyHistories.getFromNodeID() == null ? null : (storeJourney.getJourneyNode(journeyHistories.getFromNodeID()) == null ? "node has been removed" : storeJourney.getJourneyNode(journeyHistories.getFromNodeID()).getNodeName()));
                        nodeHistoriesMap.put("toNode", journeyHistories.getToNodeID() == null ? null : (storeJourney.getJourneyNode(journeyHistories.getToNodeID()) == null ? "node has been removed" : storeJourney.getJourneyNode(journeyHistories.getToNodeID()).getNodeName()));
                        nodeHistoriesMap.put("transitionDate", getDateString(journeyHistories.getTransitionDate(), tenantID));
                        nodeHistoriesMap.put("linkID", journeyHistories.getLinkID());
                        nodeHistoriesMap.put("deliveryRequestID", journeyHistories.getDeliveryRequestID());
                        nodeHistoriesJson.add(JSONUtilities.encodeObject(nodeHistoriesMap));
                      }

                    journeyResponseMap.put("customerStatus", customerStatusInJourney.getExternalRepresentation());
                    journeyResponseMap.put("journeyComplete", journeyComplete);
                    journeyResponseMap.put("nodeHistories", JSONUtilities.encodeArray(nodeHistoriesJson));
                    journeyResponseMap.put("currentState", currentStateJson);
                    journeysJson.add(JSONUtilities.encodeObject(journeyResponseMap));
                  }
                response.put("journeys", JSONUtilities.encodeArray(journeysJson));
                response.put("responseCode", "ok");
              }
          }
        catch (SubscriberProfileServiceException e)
          {
            throw new GUIManagerException(e);
          }
      }

    /*****************************************
    *
    *  return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  * processGetGetCustomerCampaigns
  *
  *****************************************/

  private JSONObject processGetCustomerCampaigns(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    Date now = SystemTime.getCurrentTime();
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String campaignObjectiveName = JSONUtilities.decodeString(jsonRoot, "objective", false);
    String campaignState = JSONUtilities.decodeString(jsonRoot, "campaignState", false);
    String customerStatus = JSONUtilities.decodeString(jsonRoot, "customerStatus", false);
    String campaignStartDateStr = JSONUtilities.decodeString(jsonRoot, "campaignStartDate", false);
    String campaignEndDateStr = JSONUtilities.decodeString(jsonRoot, "campaignEndDate", false);
    
    List<QueryBuilder> filters = new ArrayList<QueryBuilder>();

    Date campaignStartDate;
    Date campaignEndDate;
    try
      {
        String timeZone = Deployment.getDeployment(tenantID).getTimeZone();
        campaignStartDate = prepareStartDate(RLMDateUtils.parseDateFromDay(campaignStartDateStr, timeZone), timeZone);
        campaignEndDate = prepareEndDate(RLMDateUtils.parseDateFromDay(campaignEndDateStr, timeZone), timeZone);
      } 
    catch (java.text.ParseException e1)
      {
        throw new GUIManagerException(e1);
      }

    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
      }
    else
      {
        /*****************************************
        *
        *  getSubscriberProfile
        *
        *****************************************/
        try
          {
            SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
            if (baseSubscriberProfile == null)
              {
                response.put("responseCode", "CustomerNotFound");
                log.debug("SubscriberProfile is null for subscriberID {}" , subscriberID);
              }
            else
              {
                List<JSONObject> campaignsJson = new ArrayList<JSONObject>();
                
                SearchRequest searchRequest = this.elasticsearch.getSearchRequest(API.getCustomerCampaigns, subscriberID, campaignStartDate, filters, tenantID);
                List<SearchHit> hits = this.elasticsearch.getESHits(searchRequest);
                Map<String, JourneyHistory> journeyHistoryMap = new HashMap<String, JourneyHistory>(hits.size());
                for (SearchHit hit : hits)
                  {
                    Map<String, Object> esFields = hit.getSourceAsMap();
                    JourneyHistory journeyHistory = new JourneyHistory(esFields);
                    journeyHistoryMap.put(journeyHistory.getJourneyID(), journeyHistory);
                  }

                //
                // read campaigns
                //

                Collection<GUIManagedObject> storeRawCampaigns = journeyService.getStoredJourneys(true, tenantID);
                List<Journey> storeCampaigns = new ArrayList<Journey>();
                for (GUIManagedObject storeCampaign : storeRawCampaigns)
                  {
                    if (storeCampaign instanceof Journey) storeCampaigns.add((Journey) storeCampaign);
                  }

                //
                // filter campaigns
                //

                storeCampaigns = storeCampaigns.stream().filter(campaign -> (campaign.getGUIManagedObjectType() == GUIManagedObjectType.Campaign || campaign.getGUIManagedObjectType() == GUIManagedObjectType.BulkCampaign)).collect(Collectors.toList());

                //
                // filter on campaignStartDate
                //

                if (campaignStartDate != null)
                  {
                    storeCampaigns = storeCampaigns.stream().filter(campaign -> (campaign.getEffectiveStartDate() == null || campaign.getEffectiveStartDate().compareTo(campaignStartDate) >= 0)).collect(Collectors.toList());
                  }

                //
                // filter on campaignEndDate
                //

                if (campaignEndDate != null)
                  {
                    storeCampaigns = storeCampaigns.stream().filter(campaign -> (campaign.getEffectiveEndDate() == null || campaign.getEffectiveEndDate().compareTo(campaignEndDate) <= 0)).collect(Collectors.toList());
                  }

                //
                // filter on campaignObjectiveName
                //

                if (campaignObjectiveName != null && !campaignObjectiveName.isEmpty())
                  {

                    //
                    // read objective
                    //

                    Collection<JourneyObjective> activecampaignObjectives = journeyObjectiveService.getActiveJourneyObjectives(SystemTime.getCurrentTime(), tenantID);

                    //
                    // lookup activecampaignObjective by name
                    //

                    List<JourneyObjective> campaignObjectives = activecampaignObjectives.stream().filter(journeyObj -> campaignObjectiveName.equals(journeyObj.getJSONRepresentation().get("display"))).collect(Collectors.toList());
                    JourneyObjective exactCampaignObjective = campaignObjectives.size() > 0 ? campaignObjectives.get(0) : null;

                    //
                    // filter
                    //

                    if (exactCampaignObjective == null)
                      storeCampaigns = new ArrayList<Journey>();
                    else
                      storeCampaigns = storeCampaigns.stream().filter(campaign -> (campaign.getJourneyObjectiveInstances() != null && (campaign.getJourneyObjectiveInstances().stream().filter(obj -> obj.getJourneyObjectiveID().equals(exactCampaignObjective.getJourneyObjectiveID())).count() > 0L))).collect(Collectors.toList());

                  }

                for (Journey storeCampaign : storeCampaigns)
                  {

                    //
                    // subsLatestStatistic
                    //

                    JourneyHistory subsLatestStatistic = journeyHistoryMap.get(storeCampaign.getJourneyID());

                    //
                    // continue if not in stat
                    //

                    if (subsLatestStatistic == null) continue;

                    //
                    // filter on campaignState
                    //

                    if (campaignState != null && !campaignState.isEmpty())
                      {
                        boolean criteriaSatisfied = false;
                        if (journeyService.getJourneyStatus(storeCampaign).getExternalRepresentation().equalsIgnoreCase(campaignState))
                          {
                            criteriaSatisfied = true;
                          }
                        if (!criteriaSatisfied) continue;
                      }

                    //
                    // filter on customerStatus
                    //

                    boolean statusNotified = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> SubscriberJourneyStatus.Notified.getExternalRepresentation().equals(campaignStat.getStatus())).count() > 0L;
                    boolean statusConverted = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> campaignStat.isConverted()).count() > 0L;
                    Boolean statusTargetGroup = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> SubscriberJourneyStatus.Targeted.getExternalRepresentation().equals(campaignStat.getStatus())).count() > 0L;
                    Boolean statusControlGroup = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> SubscriberJourneyStatus.ControlGroup.getExternalRepresentation().equals(campaignStat.getStatus()) || SubscriberJourneyStatus.ControlGroupConverted.getExternalRepresentation().equals(campaignStat.getStatus())).count() > 0L;
                    Boolean statusUniversalControlGroup = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> SubscriberJourneyStatus.UniversalControlGroup.getExternalRepresentation().equals(campaignStat.getStatus()) || SubscriberJourneyStatus.UniversalControlGroupConverted.getExternalRepresentation().equals(campaignStat.getStatus())).count() > 0L;
                    boolean campaignComplete = subsLatestStatistic.getStatusHistory().stream().filter(campaignStat -> campaignStat.getJourneyComplete()).count() > 0L; // ??
                    SubscriberJourneyStatus customerStatusInJourney = Journey.getSubscriberJourneyStatus(statusConverted, statusNotified, statusTargetGroup, statusControlGroup, statusUniversalControlGroup);
                    SubscriberJourneyStatus profilejourneyStatus = baseSubscriberProfile.getSubscriberJourneys().get(storeCampaign.getJourneyID() + "");
                    if (profilejourneyStatus.in(SubscriberJourneyStatus.NotEligible, SubscriberJourneyStatus.UniversalControlGroup, SubscriberJourneyStatus.Excluded, SubscriberJourneyStatus.ObjectiveLimitReached))
                      customerStatusInJourney = profilejourneyStatus;

                    if (customerStatus != null)
                      {
                        SubscriberJourneyStatus customerStatusInReq = SubscriberJourneyStatus.fromExternalRepresentation(customerStatus);
                        boolean criteriaSatisfied = customerStatusInReq == customerStatusInJourney;
                        if (!criteriaSatisfied) continue;
                      }

                    //
                    // prepare response
                    //

                    Map<String, Object> campaignResponseMap = new HashMap<String, Object>();
                    campaignResponseMap.put("campaignID", storeCampaign.getJourneyID());
                    campaignResponseMap.put("campaignName", journeyService.generateResponseJSON(storeCampaign, true, SystemTime.getCurrentTime()).get("display"));
                    campaignResponseMap.put("description", journeyService.generateResponseJSON(storeCampaign, true, SystemTime.getCurrentTime()).get("description"));
                    campaignResponseMap.put("startDate", getDateString(storeCampaign.getEffectiveStartDate(), tenantID));
                    campaignResponseMap.put("endDate", getDateString(storeCampaign.getEffectiveEndDate(), tenantID));
                    campaignResponseMap.put("entryDate", getDateString(subsLatestStatistic.getJourneyEntranceDate(), tenantID));
                    campaignResponseMap.put("exitDate", subsLatestStatistic.getJourneyExitDate(journeyService) != null ? getDateString(subsLatestStatistic.getJourneyExitDate(journeyService), tenantID) : "");
                    campaignResponseMap.put("campaignState", journeyService.getJourneyStatus(storeCampaign).getExternalRepresentation());

                    List<JSONObject> resultObjectives = new ArrayList<JSONObject>();
                    for (JourneyObjectiveInstance journeyObjectiveInstance : storeCampaign.getJourneyObjectiveInstances())
                      {
                        List<JSONObject> resultCharacteristics = new ArrayList<JSONObject>();
                        JSONObject result = new JSONObject();

                        JourneyObjective journeyObjective = journeyObjectiveService.getActiveJourneyObjective(journeyObjectiveInstance.getJourneyObjectiveID(), SystemTime.getCurrentTime());
                        result.put("active", journeyObjective.getActive());
                        result.put("parentJourneyObjectiveID", journeyObjective.getParentJourneyObjectiveID());
                        result.put("display", journeyObjective.getJSONRepresentation().get("display"));
                        result.put("readOnly", journeyObjective.getReadOnly());
                        result.put("name", journeyObjective.getGUIManagedObjectName());
                        result.put("contactPolicyID", journeyObjective.getContactPolicyID());
                        result.put("id", journeyObjective.getGUIManagedObjectID());

                        for (CatalogCharacteristicInstance catalogCharacteristicInstance : journeyObjectiveInstance.getCatalogCharacteristics())
                          {
                            JSONObject characteristics = new JSONObject();
                            characteristics.put("catalogCharacteristicID", catalogCharacteristicInstance.getCatalogCharacteristicID());
                            String catalogCharacteristicValue = "" + catalogCharacteristicInstance.getValue();
                            characteristics.put("value", catalogCharacteristicValue);
                            resultCharacteristics.add(characteristics);
                          }

                        result.put("catalogCharacteristics", JSONUtilities.encodeArray(resultCharacteristics));
                        resultObjectives.add(result);
                      }

                    campaignResponseMap.put("objectives", JSONUtilities.encodeArray(resultObjectives));

                    Map<String, Object> currentState = new HashMap<String, Object>();
                    NodeHistory nodeHistory = subsLatestStatistic.getLastNodeEntered();
                    currentState.put("nodeID", nodeHistory.getToNodeID());
                    currentState.put("nodeName", nodeHistory.getToNodeID() == null ? null : (storeCampaign.getJourneyNode(nodeHistory.getToNodeID()) == null ? "node has been removed" : storeCampaign.getJourneyNode(nodeHistory.getToNodeID()).getNodeName()));
                    JSONObject currentStateJson = JSONUtilities.encodeObject(currentState);

                    //
                    // node history
                    //

                    List<JSONObject> nodeHistoriesJson = new ArrayList<JSONObject>();
                    for (NodeHistory journeyHistories : subsLatestStatistic.getNodeHistory())
                      {
                        Map<String, Object> nodeHistoriesMap = new HashMap<String, Object>();
                        nodeHistoriesMap.put("fromNodeID", journeyHistories.getFromNodeID());
                        nodeHistoriesMap.put("toNodeID", journeyHistories.getToNodeID());
                        nodeHistoriesMap.put("fromNode", journeyHistories.getFromNodeID() == null ? null : (storeCampaign.getJourneyNode(journeyHistories.getFromNodeID()) == null ? "node has been removed" : storeCampaign.getJourneyNode(journeyHistories.getFromNodeID()).getNodeName()));
                        nodeHistoriesMap.put("toNode", journeyHistories.getToNodeID() == null ? null : (storeCampaign.getJourneyNode(journeyHistories.getToNodeID()) == null ? "node has been removed" : storeCampaign.getJourneyNode(journeyHistories.getToNodeID()).getNodeName()));
                        nodeHistoriesMap.put("transitionDate", getDateString(journeyHistories.getTransitionDate(), tenantID));
                        nodeHistoriesMap.put("linkID", journeyHistories.getLinkID());
                        nodeHistoriesMap.put("deliveryRequestID", journeyHistories.getDeliveryRequestID());
                        nodeHistoriesJson.add(JSONUtilities.encodeObject(nodeHistoriesMap));
                      }
                    campaignResponseMap.put("customerStatus", customerStatusInJourney.getExternalRepresentation());
                    campaignResponseMap.put("journeyComplete", campaignComplete);
                    campaignResponseMap.put("nodeHistories", JSONUtilities.encodeArray(nodeHistoriesJson));
                    campaignResponseMap.put("currentState", currentStateJson);
                    campaignsJson.add(JSONUtilities.encodeObject(campaignResponseMap));
                  }
                response.put("campaigns", JSONUtilities.encodeArray(campaignsJson));
                response.put("responseCode", "ok");
              }
          }
        catch (SubscriberProfileServiceException e)
          {
            throw new GUIManagerException(e);
          }
      }

    /*****************************************
    *
    *  return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  * processGetGetCustomerPoints
  *
  *****************************************/

  private JSONObject processGetCustomerPoints(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
     *
     *  now
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();

    /****************************************
     *
     *  argument
     *
     ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String bonusDisplay = JSONUtilities.decodeString(jsonRoot, "bonusDisplay", false);

    /*****************************************
     *
     *  resolve point
     *
     *****************************************/

    Point searchedPoint = null;
    if(bonusDisplay != null && !bonusDisplay.isEmpty())
      {
        for(GUIManagedObject storedPoint : pointService.getStoredPoints(tenantID)){
          if(storedPoint instanceof Point && (((Point) storedPoint).getDisplay().equals(bonusDisplay))){
            searchedPoint = (Point)storedPoint;
          }
        }
        if(searchedPoint == null){
          log.info("bonus with display '"+bonusDisplay+"' not found");
          response.put("responseCode", "BonusNotFound");
          return JSONUtilities.encodeObject(response);
        }
      }

    /*****************************************
     *
     *  resolve subscriberID
     *
     *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
     *
     *  getSubscriberProfile
     *
     *****************************************/

    try
    {
      SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, true);
      if (baseSubscriberProfile == null)
        {
          response.put("responseCode", "CustomerNotFound");
        }
      else
        {
          ArrayList<JSONObject> pointsPresentation = new ArrayList<JSONObject>();
          Map<String, PointBalance> pointBalances = baseSubscriberProfile.getPointBalances();
          for (String pointID : pointBalances.keySet())
            {
              Point point = pointService.getActivePoint(pointID, now);
              if (point != null && (searchedPoint == null || searchedPoint.getPointID().equals(point.getPointID())))
                {
                  HashMap<String, Object> pointPresentation = new HashMap<String,Object>();
                  PointBalance pointBalance = pointBalances.get(pointID);
                  pointPresentation.put("pointID", pointID);
                  pointPresentation.put("pointDisplay", point.getDisplay());
                  pointPresentation.put("balance", pointBalance.getBalance(now));
                  pointPresentation.put("earned", pointBalance.getEarnedHistory().getAllTimeBucket());
                  pointPresentation.put("expired", pointBalance.getExpiredHistory().getAllTimeBucket());
                  pointPresentation.put("consumed", pointBalance.getConsumedHistory().getAllTimeBucket());
                  Set<Object> pointExpirations = new HashSet<Object>();
                  for(Date expirationDate : pointBalance.getBalances().keySet()){
                    HashMap<String, Object> expirationPresentation = new HashMap<String, Object>();
                    expirationPresentation.put("expirationDate", getDateString(expirationDate, tenantID));
                    expirationPresentation.put("quantity", pointBalance.getBalances().get(expirationDate));
                    pointExpirations.add(JSONUtilities.encodeObject(expirationPresentation));
                  }
                  pointPresentation.put("expirations", pointExpirations);


                  pointsPresentation.add(JSONUtilities.encodeObject(pointPresentation));
                }
            }
          
          response.put("points", pointsPresentation);
          response.put("responseCode", "ok");
        }
    }
    catch (SubscriberProfileServiceException e)
    {
      throw new GUIManagerException(e);
    }

    /*****************************************
     *
     *  return
     *
     *****************************************/

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  * processGetCustomerLoyaltyPrograms
  *
  *****************************************/

  private JSONObject processGetCustomerLoyaltyPrograms(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    *  now
    *
    ****************************************/

   Date now = SystemTime.getCurrentTime();

   /****************************************
    *
    *  argument
    *
    ****************************************/

   String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
   String searchedLoyaltyProgramID = JSONUtilities.decodeString(jsonRoot, "loyaltyProgramID", false);
   if(searchedLoyaltyProgramID != null && searchedLoyaltyProgramID.isEmpty()){ searchedLoyaltyProgramID = null; }

   /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/

   String subscriberID = resolveSubscriberID(customerID, tenantID);
   if (subscriberID == null)
     {
       log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
       response.put("responseCode", "CustomerNotFound");
       return JSONUtilities.encodeObject(response);
     }

    /*****************************************
     *
     *  getSubscriberProfile
     *
     *****************************************/
    try
    {
      SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, true);
      if (baseSubscriberProfile == null)
        {
          response.put("responseCode", "CustomerNotFound");
        }
      else
        {

          Map<String,LoyaltyProgramState> loyaltyPrograms = baseSubscriberProfile.getLoyaltyPrograms();
          List<JSONObject> loyaltyProgramsPresentation = new ArrayList<JSONObject>();
          for (String loyaltyProgramID : loyaltyPrograms.keySet())
            {
              //
              //  check loyalty program still exist
              //

              GUIManagedObject loyaltyProgramUnchecked = loyaltyProgramService.getStoredLoyaltyProgram(loyaltyProgramID);
              if (loyaltyProgramUnchecked != null && (searchedLoyaltyProgramID == null || loyaltyProgramID.equals(searchedLoyaltyProgramID)) && loyaltyProgramUnchecked.getAccepted())
                {

                  HashMap<String, Object> loyaltyProgramPresentation = new HashMap<String,Object>();
                  LoyaltyProgram loyaltyProgram = (LoyaltyProgram) loyaltyProgramUnchecked;

                  //
                  //  loyalty program informations
                  //

                  LoyaltyProgramState loyaltyProgramState = loyaltyPrograms.get(loyaltyProgramID);
                  loyaltyProgramPresentation.put("loyaltyProgramType", loyaltyProgram.getLoyaltyProgramType().getExternalRepresentation());
                  loyaltyProgramPresentation.put("loyaltyProgramName", loyaltyProgram.getLoyaltyProgramName());
                  loyaltyProgramPresentation.put("loyaltyProgramDisplay", loyaltyProgram.getLoyaltyProgramDisplay());
                  loyaltyProgramPresentation.put("loyaltyProgramEnrollmentDate", getDateString(loyaltyProgramState.getLoyaltyProgramEnrollmentDate(), tenantID));
                  loyaltyProgramPresentation.put("loyaltyProgramExitDate", getDateString(loyaltyProgramState.getLoyaltyProgramExitDate(), tenantID));
                  loyaltyProgramPresentation.put("active", loyaltyProgram.getActive());
                  
                  switch (loyaltyProgramState.getLoyaltyProgramType())
                  {
                    case POINTS:
                      LoyaltyProgramPointsState loyaltyProgramPointsState = (LoyaltyProgramPointsState) loyaltyProgramState;

                      //
                      // current tier
                      //

                      if(loyaltyProgramPointsState.getTierName() != null){ loyaltyProgramPresentation.put("tierName", loyaltyProgramPointsState.getTierName()); }
                      if(loyaltyProgramPointsState.getTierEnrollmentDate() != null){ loyaltyProgramPresentation.put("tierEnrollmentDate", getDateString(loyaltyProgramPointsState.getTierEnrollmentDate(), tenantID)); }

                      //
                      // status point
                      //

                      LoyaltyProgramPoints loyaltyProgramPoints = (LoyaltyProgramPoints) loyaltyProgram;
                      String statusPointID = loyaltyProgramPoints.getStatusPointsID();
                      Point statusPoint = pointService.getActivePoint(statusPointID, now);
                      if (statusPoint != null)
                        {
                          loyaltyProgramPresentation.put("statusPointID", statusPoint.getPointID());
                          loyaltyProgramPresentation.put("statusPointName", statusPoint.getPointName());
                          loyaltyProgramPresentation.put("statusPointDisplay", statusPoint.getDisplay());
                        }
                      PointBalance pointBalance = baseSubscriberProfile.getPointBalances().get(statusPointID);
                      if (pointBalance != null)
                        {
                          loyaltyProgramPresentation.put("statusPointsBalance", pointBalance.getBalance(now));
                        } 
                      else
                        {
                          loyaltyProgramPresentation.put("statusPointsBalance", 0);
                        }

                      //
                      // reward point informations
                      //

                      String rewardPointID = loyaltyProgramPoints.getRewardPointsID();
                      Point rewardPoint = pointService.getActivePoint(rewardPointID, now);
                      if (rewardPoint != null)
                        {
                          loyaltyProgramPresentation.put("rewardsPointID", rewardPoint.getPointID());
                          loyaltyProgramPresentation.put("rewardsPointName", rewardPoint.getPointName());
                          loyaltyProgramPresentation.put("rewardsPointDisplay", rewardPoint.getDisplay());
                        }
                      PointBalance rewardBalance = baseSubscriberProfile.getPointBalances().get(rewardPointID);
                      if (rewardBalance != null)
                        {
                          loyaltyProgramPresentation.put("rewardsPointsBalance", rewardBalance.getBalance(now));
                          loyaltyProgramPresentation.put("rewardsPointsEarned", rewardBalance.getEarnedHistory().getAllTimeBucket());
                          loyaltyProgramPresentation.put("rewardsPointsConsumed", rewardBalance.getConsumedHistory().getAllTimeBucket());
                          loyaltyProgramPresentation.put("rewardsPointsExpired", rewardBalance.getExpiredHistory().getAllTimeBucket());
                          Date firstExpirationDate = rewardBalance.getFirstExpirationDate(now);
                          if (firstExpirationDate != null)
                            {
                              int firstExpirationQty = rewardBalance.getBalance(firstExpirationDate);
                              loyaltyProgramPresentation.put("rewardsPointsEarliestexpirydate", getDateString(firstExpirationDate, tenantID));
                              loyaltyProgramPresentation.put("rewardsPointsEarliestexpiryquantity", firstExpirationQty);
                            } 
                          else
                            {
                              loyaltyProgramPresentation.put("rewardsPointsEarliestexpirydate", getDateString(now, tenantID));
                              loyaltyProgramPresentation.put("rewardsPointsEarliestexpiryquantity", 0);
                            }
                        } 
                      else
                        {
                          loyaltyProgramPresentation.put("rewardsPointsBalance", 0);
                          loyaltyProgramPresentation.put("rewardsPointsEarned", 0);
                          loyaltyProgramPresentation.put("rewardsPointsConsumed", 0);
                          loyaltyProgramPresentation.put("rewardsPointsExpired", 0);
                          loyaltyProgramPresentation.put("rewardsPointsEarliestexpirydate", getDateString(now, tenantID));
                          loyaltyProgramPresentation.put("rewardsPointsEarliestexpiryquantity", 0);
                        }

                      //
                      // history
                      //
                      
                      ArrayList<JSONObject> loyaltyProgramHistoryJSON = new ArrayList<JSONObject>();
                      LoyaltyProgramHistory history = loyaltyProgramPointsState.getLoyaltyProgramHistory();
                      if(history != null && history.getTierHistory() != null && !history.getTierHistory().isEmpty()){
                        for(TierHistory tier : history.getTierHistory()){
                          HashMap<String, Object> tierHistoryJSON = new HashMap<String,Object>();
                          tierHistoryJSON.put("fromTier", tier.getFromTier());
                          tierHistoryJSON.put("toTier", tier.getToTier());
                          tierHistoryJSON.put("transitionDate", getDateString(tier.getTransitionDate(), tenantID));
                          loyaltyProgramHistoryJSON.add(JSONUtilities.encodeObject(tierHistoryJSON));
                        }
                      }
                      loyaltyProgramPresentation.put("loyaltyProgramHistory", loyaltyProgramHistoryJSON);
                      break;
                      
                    case CHALLENGE:
                      LoyaltyProgramChallengeState loyaltyProgramChallengeState = (LoyaltyProgramChallengeState) loyaltyProgramState;
                      
                      //
                      // current level
                      //

                      if (loyaltyProgramChallengeState.getLevelName() != null)
                        {
                          loyaltyProgramPresentation.put("levelName", loyaltyProgramChallengeState.getLevelName());
                        }
                      if (loyaltyProgramChallengeState.getLevelEnrollmentDate() != null)
                        {
                          loyaltyProgramPresentation.put("levelEnrollmentDate", getDateString(loyaltyProgramChallengeState.getLevelEnrollmentDate(), tenantID));
                        }
                      
                      //
                      // score
                      //

                      loyaltyProgramPresentation.put("score", loyaltyProgramChallengeState.getCurrentScore());
                      
                      //
                      // history
                      //
                      
                      ArrayList<JSONObject> loyaltyProgramChallengeHistoryJSON = new ArrayList<JSONObject>();
                      LoyaltyProgramChallengeHistory loyaltyProgramChallengeHistory = loyaltyProgramChallengeState.getLoyaltyProgramChallengeHistory();
                      if (loyaltyProgramChallengeHistory != null && loyaltyProgramChallengeHistory.getLevelHistory() != null && !loyaltyProgramChallengeHistory.getLevelHistory().isEmpty())
                        {
                          for (LevelHistory level : loyaltyProgramChallengeHistory.getLevelHistory())
                            {
                              HashMap<String, Object> levelHistoryJSON = new HashMap<String, Object>();
                              levelHistoryJSON.put("fromLevel", level.getFromLevel());
                              levelHistoryJSON.put("toLevel", level.getToLevel());
                              levelHistoryJSON.put("transitionDate", getDateString(level.getTransitionDate(), tenantID));
                              levelHistoryJSON.put("occouranceNumber", level.getOccurrenceNumber());
                              loyaltyProgramChallengeHistoryJSON.add(JSONUtilities.encodeObject(levelHistoryJSON));
                            }
                        }
                      
                      //
                      //  Recurrence
                      //
                      
                      if (loyaltyProgram instanceof LoyaltyProgramChallenge && ((LoyaltyProgramChallenge) loyaltyProgram).getRecurrence())
                        {
                          loyaltyProgramPresentation.put("previousPeriodLevel", loyaltyProgramChallengeState.getPreviousPeriodLevel());
                          loyaltyProgramPresentation.put("previousPeriodScore", loyaltyProgramChallengeState.getPreviousPeriodScore());
                          loyaltyProgramPresentation.put("previousPeriodStartDate", getDateString(loyaltyProgramChallengeState.getPreviousPeriodStartDate(), tenantID));
                        }
                      
                      loyaltyProgramPresentation.put("loyaltyProgramChallengeHistory", loyaltyProgramChallengeHistoryJSON);
                      break;
                      
                    case MISSION:
                      LoyaltyProgramMissionState loyaltyProgramMissionState = (LoyaltyProgramMissionState) loyaltyProgramState;
                      loyaltyProgramPresentation.put("isMissionCompleted", loyaltyProgramMissionState.isMissionCompleted());
                      
                      //
                      // current step
                      //

                      loyaltyProgramPresentation.put("stepName", loyaltyProgramMissionState.getStepName());
                      loyaltyProgramPresentation.put("stepEnrollmentDate", getDateString(loyaltyProgramMissionState.getStepEnrollmentDate(), tenantID));
                      loyaltyProgramPresentation.put("currentProgression", loyaltyProgramMissionState.getCurrentProgression());
                      
                      //
                      // history
                      //
                      
                      ArrayList<JSONObject> loyaltyProgramMissionHistoryJSON = new ArrayList<JSONObject>();
                      LoyaltyProgramMissionHistory loyaltyProgramMissionHistory = loyaltyProgramMissionState.getLoyaltyProgramMissionHistory();
                      if (loyaltyProgramMissionHistory != null && loyaltyProgramMissionHistory.getStepHistory() != null && !loyaltyProgramMissionHistory.getStepHistory().isEmpty())
                        {
                          for (StepHistory step : loyaltyProgramMissionHistory.getStepHistory())
                            {
                              HashMap<String, Object> levelHistoryJSON = new HashMap<String, Object>();
                              levelHistoryJSON.put("fromStep", step.getFromStep());
                              levelHistoryJSON.put("toStep", step.getToStep());
                              levelHistoryJSON.put("transitionDate", getDateString(step.getTransitionDate(), tenantID));
                              loyaltyProgramMissionHistoryJSON.add(JSONUtilities.encodeObject(levelHistoryJSON));
                            }
                        }
                      
                      loyaltyProgramPresentation.put("loyaltyProgramMissionHistory", loyaltyProgramMissionHistoryJSON);
                      break;
                      
                    default:
                      break;
                  }

                  //
                  //  
                  //

                  loyaltyProgramsPresentation.add(JSONUtilities.encodeObject(loyaltyProgramPresentation));

                }
            }

          response.put("loyaltyPrograms", loyaltyProgramsPresentation);
          response.put("responseCode", "ok");
        }
    } 
    catch (SubscriberProfileServiceException e)
    {
      throw new GUIManagerException(e);
    }

    /*****************************************
     *
     *  return
     *
     *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  getCustomerAlternateIDs
  *
  *****************************************/

  private JSONObject processGetCustomerAlternateIDs(String userID, JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve alternateIDs
    *
    *****************************************/

    List<JSONObject> alternateIDs = new ArrayList<JSONObject>();
    for (AlternateID alternateID : Deployment.getAlternateIDs().values())
      {
        JSONObject json = new JSONObject();
        json.put("id", alternateID.getID());
        json.put("display", alternateID.getDisplay());
        alternateIDs.add(json);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("alternateIDs", JSONUtilities.encodeArray(alternateIDs));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetCustomerAvailableCampaigns
  *
  *****************************************/

  private JSONObject processGetCustomerAvailableCampaigns(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    Date now = SystemTime.getCurrentTime();
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    * argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);

    /*****************************************
    *
    * resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        response.put("responseCode", "CustomerNotFound");
      } 
    else
      {
        /*****************************************
        *
        * getSubscriberProfile - include history
        *
        *****************************************/
        try
          {
            SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
            if (subscriberProfile == null)
              {
                response.put("responseCode", "CustomerNotFound");
              } 
            else
              {
                SubscriberEvaluationRequest evaluationRequest = new SubscriberEvaluationRequest(subscriberProfile, subscriberGroupEpochReader, now, tenantID);
                
                //
                //  journeys
                //
                
                List<String> enteredJourneysID = new ArrayList<String>();
                enteredJourneysID.addAll(subscriberProfile.getSubscriberJourneys().keySet());
                enteredJourneysID.addAll(subscriberProfile.getSubscriberJourneysEnded().keySet()); // double check
                
                //
                //  read the active journeys
                //

                Collection<Journey> activeCampaigns = journeyService.getActiveJourneys(now, tenantID);

                //
                //  respect manual campaigns only
                //

                activeCampaigns = activeCampaigns.stream().filter(activeJourney -> activeJourney.getGUIManagedObjectType() == GUIManagedObjectType.Campaign && TargetingType.Manual == activeJourney.getTargetingType()).collect(Collectors.toList());

                //
                // list the eligible campaigns
                //

                Collection<Journey> elgibleActiveCampaigns = activeCampaigns.stream().filter(activeJourney -> activeJourney.evaluateEligibilityCriteria(evaluationRequest)).collect(Collectors.toList());

                //
                //  consider if not enter
                //

                List<JSONObject> campaignsJson = new ArrayList<JSONObject>();
                for (Journey elgibleActiveCampaign : elgibleActiveCampaigns)
                  {
                    if (!enteredJourneysID.contains(elgibleActiveCampaign.getJourneyID()))
                      {
                        //
                        // prepare and decorate response
                        //

                        Map<String, Object> campaignMap = new HashMap<String, Object>();
                        campaignMap.put("campaignID", elgibleActiveCampaign.getJourneyID());
                        campaignMap.put("campaignName", journeyService.generateResponseJSON(elgibleActiveCampaign, true, now).get("display"));
                        campaignMap.put("description", journeyService.generateResponseJSON(elgibleActiveCampaign, true, now).get("description"));
                        campaignMap.put("startDate", getDateString(elgibleActiveCampaign.getEffectiveStartDate(), tenantID));
                        campaignMap.put("endDate", getDateString(elgibleActiveCampaign.getEffectiveEndDate(), tenantID));
                        List<JSONObject> resultObjectives = new ArrayList<JSONObject>();
                        for (JourneyObjectiveInstance journeyObjectiveInstance : elgibleActiveCampaign.getJourneyObjectiveInstances())
                          {
                            List<JSONObject> resultCharacteristics = new ArrayList<JSONObject>();
                            JSONObject result = new JSONObject();
                            
                            JourneyObjective journeyObjective = journeyObjectiveService.getActiveJourneyObjective(journeyObjectiveInstance.getJourneyObjectiveID(), SystemTime.getCurrentTime());
                            result.put("active", journeyObjective.getActive());
                            result.put("parentJourneyObjectiveID", journeyObjective.getParentJourneyObjectiveID());
                            result.put("display", journeyObjective.getJSONRepresentation().get("display"));
                            result.put("readOnly", journeyObjective.getReadOnly());
                            result.put("name", journeyObjective.getGUIManagedObjectName());
                            result.put("contactPolicyID", journeyObjective.getContactPolicyID());
                            result.put("id", journeyObjective.getGUIManagedObjectID());
                            
                            for (CatalogCharacteristicInstance catalogCharacteristicInstance : journeyObjectiveInstance.getCatalogCharacteristics())
                              {
                                JSONObject characteristics = new JSONObject();
                                characteristics.put("catalogCharacteristicID", catalogCharacteristicInstance.getCatalogCharacteristicID());
                                characteristics.put("value", catalogCharacteristicInstance.getValue());
                                resultCharacteristics.add(characteristics);
                              }
                            
                            result.put("catalogCharacteristics", JSONUtilities.encodeArray(resultCharacteristics));
                            resultObjectives.add(result);
                          }
                        campaignMap.put("objectives", JSONUtilities.encodeArray(resultObjectives));
                        campaignsJson.add(JSONUtilities.encodeObject(campaignMap));
                      }
                  }
                response.put("campaigns", JSONUtilities.encodeArray(campaignsJson));
                response.put("responseCode", "ok");
              }
          }
        catch (SubscriberProfileServiceException e)
          {
            log.error("SubscriberProfileServiceException ", e.getMessage());
            throw new GUIManagerException(e);
          }
      }

    /*****************************************
    *
    * return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processUpdateCustomerParent
  *
  *****************************************/

  private JSONObject processUpdateCustomerParent(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /****************************************
    *
    * /!\ this code is duplicated in GUImanager & ThirdPartyManager, do not forget to update both.
    *
    ****************************************/
    
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    * argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String relationshipID = JSONUtilities.decodeString(jsonRoot, "relationshipID", true);
    String newParentCustomerID = JSONUtilities.decodeString(jsonRoot, "newParentCustomerID", true);

    /*****************************************
    *
    * resolve relationship
    *
    *****************************************/
      
    boolean isRelationshipSupported = false;
    for (SupportedRelationship supportedRelationship : Deployment.getDeployment(tenantID).getSupportedRelationships().values())
      {
        if (supportedRelationship.getID().equals(relationshipID))
          {
            isRelationshipSupported = true;
            break;
          }
      }
    
    if(!isRelationshipSupported)
      {
        response.put("responseCode", RESTAPIGenericReturnCodes.RELATIONSHIP_NOT_FOUND.getGenericResponseMessage());
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    * resolve subscriberID
    *
    *****************************************/
    
    String subscriberID = resolveSubscriberID(customerID, tenantID);
    String newParentSubscriberID = resolveSubscriberID(newParentCustomerID, tenantID);
    if (subscriberID == null)
      {
        response.put("responseCode", RESTAPIGenericReturnCodes.CUSTOMER_NOT_FOUND.getGenericResponseMessage() + "-{specified customerID do not relate to any customer}");
        return JSONUtilities.encodeObject(response);
      } 
    else if (newParentSubscriberID == null)
      {
        response.put("responseCode", RESTAPIGenericReturnCodes.CUSTOMER_NOT_FOUND.getGenericResponseMessage() + "-{specified newParentCustomerID do not relate to any customer}");
        return JSONUtilities.encodeObject(response);
      } 
    else if (subscriberID.equals(newParentSubscriberID))
      {
        response.put("responseCode", RESTAPIGenericReturnCodes.BAD_FIELD_VALUE.getGenericResponseMessage() + "-{a customer cannot be its own parent}");
        return JSONUtilities.encodeObject(response);
      }

    try
      {
        SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID);
        String previousParentSubscriberID = null;
        SubscriberRelatives relatives = subscriberProfile.getRelations().get(relationshipID);
        if(relatives != null) 
          {
            previousParentSubscriberID = relatives.getParentSubscriberID(); // can still be null if undefined (no parent)
          }
        
        if(! newParentSubscriberID.equals(previousParentSubscriberID)) 
          {
            if(previousParentSubscriberID != null)
              {
                //
                // Delete child for the parent 
                // 
                
                jsonRoot.put("subscriberID", previousParentSubscriberID);
                SubscriberProfileForceUpdate previousParentProfileForceUpdate = new SubscriberProfileForceUpdate(jsonRoot);
                ParameterMap previousParentParameterMap = previousParentProfileForceUpdate.getParameterMap();
                previousParentParameterMap.put("subscriberRelationsUpdateMethod", SubscriberRelationsUpdateMethod.RemoveChild.getExternalRepresentation());
                previousParentParameterMap.put("relationshipID", relationshipID);
                previousParentParameterMap.put("relativeSubscriberID", subscriberID);
                
                //
                // submit to kafka 
                //
                  
                kafkaProducer.send(new ProducerRecord<byte[], byte[]>(Deployment.getSubscriberProfileForceUpdateTopic(), StringKey.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), new StringKey(previousParentProfileForceUpdate.getSubscriberID())), SubscriberProfileForceUpdate.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), previousParentProfileForceUpdate)));
                
              }
            

            //
            // Set child for the new parent 
            //
            
            jsonRoot.put("subscriberID", newParentSubscriberID);
            SubscriberProfileForceUpdate newParentProfileForceUpdate = new SubscriberProfileForceUpdate(jsonRoot);
            ParameterMap newParentParameterMap = newParentProfileForceUpdate.getParameterMap();
            newParentParameterMap.put("subscriberRelationsUpdateMethod", SubscriberRelationsUpdateMethod.AddChild.getExternalRepresentation());
            newParentParameterMap.put("relationshipID", relationshipID);
            newParentParameterMap.put("relativeSubscriberID", subscriberID);
              
            //
            // Set parent 
            //
            
            jsonRoot.put("subscriberID", subscriberID);
            SubscriberProfileForceUpdate subscriberProfileForceUpdate = new SubscriberProfileForceUpdate(jsonRoot);
            ParameterMap subscriberParameterMap = subscriberProfileForceUpdate.getParameterMap();
            subscriberParameterMap.put("subscriberRelationsUpdateMethod", SubscriberRelationsUpdateMethod.SetParent.getExternalRepresentation());
            subscriberParameterMap.put("relationshipID", relationshipID);
            subscriberParameterMap.put("relativeSubscriberID", newParentSubscriberID);
            
            //
            // submit to kafka 
            //
              
            kafkaProducer.send(new ProducerRecord<byte[], byte[]>(Deployment.getSubscriberProfileForceUpdateTopic(), StringKey.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), new StringKey(newParentProfileForceUpdate.getSubscriberID())), SubscriberProfileForceUpdate.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), newParentProfileForceUpdate)));
            kafkaProducer.send(new ProducerRecord<byte[], byte[]>(Deployment.getSubscriberProfileForceUpdateTopic(), StringKey.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), new StringKey(subscriberProfileForceUpdate.getSubscriberID())), SubscriberProfileForceUpdate.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), subscriberProfileForceUpdate)));
          }

        response.put("responseCode", "ok");
      } 
    catch (SubscriberProfileServiceException e)
      {
        throw new GUIManagerException(e);
      }

    /*****************************************
    *
    * return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processDeleteCustomerParent
  *
  *****************************************/

  private JSONObject processRemoveCustomerParent(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /****************************************
    *
    * /!\ this code is duplicated in GUImanager & ThirdPartyManager, do not forget to update both.
    *
    ****************************************/
    
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    * argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String relationshipID = JSONUtilities.decodeString(jsonRoot, "relationshipID", true);

    /*****************************************
    *
    * resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        response.put("responseCode", RESTAPIGenericReturnCodes.CUSTOMER_NOT_FOUND.getGenericResponseMessage() + "-{specified customerID do not relate to any customer}");
        return JSONUtilities.encodeObject(response);
      }
    
    try
      {
        SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID);
        String previousParentSubscriberID = null;
        SubscriberRelatives relatives = subscriberProfile.getRelations().get(relationshipID);
        if(relatives != null) 
          {
            previousParentSubscriberID = relatives.getParentSubscriberID(); // can still be null if undefined (no parent)
          }
        
        if(previousParentSubscriberID != null)
          {
            //
            // Delete child for the parent 
            // 
            
            jsonRoot.put("subscriberID", previousParentSubscriberID);
            SubscriberProfileForceUpdate parentProfileForceUpdate = new SubscriberProfileForceUpdate(jsonRoot);
            ParameterMap parentParameterMap = parentProfileForceUpdate.getParameterMap();
            parentParameterMap.put("subscriberRelationsUpdateMethod", SubscriberRelationsUpdateMethod.RemoveChild.getExternalRepresentation());
            parentParameterMap.put("relationshipID", relationshipID);
            parentParameterMap.put("relativeSubscriberID", subscriberID);
            
            
            //
            // Set parent null 
            //
            
            jsonRoot.put("subscriberID", subscriberID);
            SubscriberProfileForceUpdate subscriberProfileForceUpdate = new SubscriberProfileForceUpdate(jsonRoot);
            ParameterMap subscriberParameterMap = subscriberProfileForceUpdate.getParameterMap();
            subscriberParameterMap.put("subscriberRelationsUpdateMethod", SubscriberRelationsUpdateMethod.SetParent.getExternalRepresentation());
            subscriberParameterMap.put("relationshipID", relationshipID);
            // "relativeSubscriberID" must stay null
            
            //
            // submit to kafka 
            //
            
            kafkaProducer.send(new ProducerRecord<byte[], byte[]>(Deployment.getSubscriberProfileForceUpdateTopic(), StringKey.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), new StringKey(parentProfileForceUpdate.getSubscriberID())), SubscriberProfileForceUpdate.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), parentProfileForceUpdate)));
            kafkaProducer.send(new ProducerRecord<byte[], byte[]>(Deployment.getSubscriberProfileForceUpdateTopic(), StringKey.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), new StringKey(subscriberProfileForceUpdate.getSubscriberID())), SubscriberProfileForceUpdate.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), subscriberProfileForceUpdate)));
          }


        response.put("responseCode", "ok");
      } 
    catch (SubscriberProfileServiceException e)
      {
        throw new GUIManagerException(e);
      }

    /*****************************************
    *
    * return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processUpdateCustomer
  *
  *****************************************/

  private JSONObject processUpdateCustomer(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    Map<String, Object> response = new HashMap<String, Object>();

    /****************************************
    *
    * argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);

    /*****************************************
    *
    * resolve subscriberID
    *
    *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        response.put("responseCode", "CustomerNotFound");
      } 
    else
      {
        jsonRoot.put("subscriberID", subscriberID);
        SubscriberProfileForceUpdate subscriberProfileForceUpdate = new SubscriberProfileForceUpdate(jsonRoot);

        //
        //  submit to kafka
        //

        kafkaProducer.send(new ProducerRecord<byte[], byte[]>(Deployment.getSubscriberProfileForceUpdateTopic(), StringKey.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), new StringKey(subscriberProfileForceUpdate.getSubscriberID())), SubscriberProfileForceUpdate.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), subscriberProfileForceUpdate)));

        response.put("responseCode", "ok");
      }

    /*****************************************
    *
    * return
    *
    *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processgetCommunicationChannelList
  *
  *****************************************/

  private JSONObject processGetCommunicationChannelList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve communication channel list
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> communicationChannelList = new ArrayList<JSONObject>();
    Collection <CommunicationChannel> communicationChannelObjects = new ArrayList<CommunicationChannel>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray communicationChannelIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < communicationChannelIDs.size(); i++)
          {
            String communicationChannelID = communicationChannelIDs.get(i).toString();
            CommunicationChannel communicationChannel = Deployment.getDeployment(tenantID).getCommunicationChannels().get(communicationChannelID);
            if (communicationChannel != null && communicationChannel.getTenantID() == tenantID)
              {
                communicationChannelObjects.add(communicationChannel);
              }
          }
      }
    else
      {
        communicationChannelObjects = Deployment.getDeployment(tenantID).getCommunicationChannels().values();
      }
    for (CommunicationChannel communicationChannel : communicationChannelObjects)
      {
        JSONObject channel = communicationChannel.generateResponseJSON(fullDetails, now);        
        
        CommunicationChannelTimeWindow timeWindow = communicationChannelTimeWindowService.getActiveCommunicationChannelTimeWindow(communicationChannel.getID(), SystemTime.getCurrentTime());
        
        if(timeWindow != null) 
          {
            JSONObject timeWindowJsonRepresentation = timeWindow.getJSONRepresentation(); 
            timeWindowJsonRepresentation.remove("communicationChannelID");
            channel.put("notificationDailyWindows", timeWindowJsonRepresentation); 
          }
        
        communicationChannelList.add(channel);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("communicationChannels", JSONUtilities.encodeArray(communicationChannelList));
    if(fullDetails) {
      CommunicationChannelTimeWindow notifWindows = Deployment.getDeployment(tenantID).getDefaultNotificationDailyWindows();
      if(notifWindows != null)
        {
          response.put("defaultNoftificationDailyWindows", notifWindows.getJSONRepresentation());
        }
    }
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetCommunicationChannel
  *
  *****************************************/

  private JSONObject processGetCommunicationChannel(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String communicationChannelID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate communication channel
    *
    *****************************************/

    CommunicationChannel communicationChannel = Deployment.getDeployment(tenantID).getCommunicationChannels().get(communicationChannelID);
    JSONObject communicationChannelJSON = communicationChannel.generateResponseJSON(true, SystemTime.getCurrentTime());
    
    CommunicationChannelTimeWindow timeWindow = communicationChannelTimeWindowService.getActiveCommunicationChannelTimeWindow(communicationChannelID, SystemTime.getCurrentTime());
    if(timeWindow == null)
      {
        // use the default timeWindow
        timeWindow = Deployment.getDeployment(tenantID).getDefaultNotificationDailyWindows();        
      }
    
    if(timeWindow != null) 
      {
        JSONObject timeWindowJsonRepresentation = timeWindow.getJSONRepresentation(); 
        timeWindowJsonRepresentation.remove("communicationChannelID");
        communicationChannelJSON.put("notificationDailyWindows", timeWindowJsonRepresentation); 
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (communicationChannel != null) ? "ok" : "communicationChannelNotFound");
    if (communicationChannel != null) response.put("communicationChannel", communicationChannelJSON);
    return JSONUtilities.encodeObject(response);
  }
  
    /*****************************************
  *
  *  processPutCommunicationChannel ==> Deprecated, only for TimeWindow hack
     * @throws GUIManagerException 
  *
  *****************************************/

  private JSONObject processPutCommunicationChannel(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  communicationChannelID
    *
    *****************************************/

    String communicationChannelID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (communicationChannelID == null)
      {
        throw new GUIManagerException("No communication channel ID", "");
      }

    /*****************************************
    *
    *  process CommunicationChannel
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /*****************************************
        *
        *  extract TimeWindow
        *
        *****************************************/
        
        CommunicationChannelTimeWindow existingCommunicationChannelTimeWindow = communicationChannelTimeWindowService.getActiveCommunicationChannelTimeWindow(communicationChannelID, now);
        
        if(jsonRoot.get("notificationDailyWindows") != null) {
          // let GUIMangedObject This (this is a F$$$ hack)
          JSONObject json = (JSONObject) jsonRoot.get("notificationDailyWindows");
          json.put("communicationChannelID", communicationChannelID);
          json.put("id", "timewindow-" + communicationChannelID);
          json.put("name", "timewindow-" + communicationChannelID);
          json.put("display", "timewindow-" + communicationChannelID);
          json.put("readOnly", false);
          json.put("internalOnly", false);
          json.put("active", true);
          json.put("deleted", false);
          json.put("userID", jsonRoot.get("userID"));
          json.put("userName", jsonRoot.get("userName"));
          json.put("groupID", jsonRoot.get("groupID"));          
          
          CommunicationChannelTimeWindow communicationChannelTimeWindow = new CommunicationChannelTimeWindow(json, epoch, existingCommunicationChannelTimeWindow, tenantID);
          
          /*****************************************
          *
          *  store
          *
          *****************************************/

          communicationChannelTimeWindowService.putCommunicationChannelTimeWindow(communicationChannelTimeWindow, (existingCommunicationChannelTimeWindow == null), userID);
          
        }else {
          // delete this time window for the associated channel
          communicationChannelTimeWindowService.removeCommunicationChannelTimeWindow(communicationChannelID, userID, tenantID);
        }
        
 

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", communicationChannelID);
        response.put("accepted", true);
        response.put("valid", true);
        response.put("processing", true);
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("communicationChannelID", communicationChannelID);
        response.put("responseCode", "communicationChannelNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processGetBlackoutPeriodsList
  *
  *****************************************/

  private JSONObject processGetBlackoutPeriodsList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve blackout period list
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> communicationChannelBlackoutList = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> communicationChannelBlackoutObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray communicationChannelBlackoutIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < communicationChannelBlackoutIDs.size(); i++)
          {
            String communicationChannelBlackoutID = communicationChannelBlackoutIDs.get(i).toString();
            GUIManagedObject communicationChannelBlackout = communicationChannelBlackoutService.getStoredCommunicationChannelBlackout(communicationChannelBlackoutID, includeArchived);
            if (communicationChannelBlackout != null && communicationChannelBlackout.getTenantID() == tenantID)
              {
                communicationChannelBlackoutObjects.add(communicationChannelBlackout);
              }            
          }
      }
    else
      {
        communicationChannelBlackoutObjects = communicationChannelBlackoutService.getStoredCommunicationChannelBlackouts(includeArchived, tenantID);
      }
    for (GUIManagedObject blackoutPeriods : communicationChannelBlackoutObjects)
      {
        JSONObject blackoutPeriod = communicationChannelBlackoutService.generateResponseJSON(blackoutPeriods, fullDetails, now);
        communicationChannelBlackoutList.add(blackoutPeriod);
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("blackoutPeriods", JSONUtilities.encodeArray(communicationChannelBlackoutList));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetBlackoutPeriods
  *
  *****************************************/

  private JSONObject processGetBlackoutPeriods(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String communicationChannelBlackoutPeriodID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /**************************************************************
    *
    *  retrieve and decorate communication channel blackout period
    *
    ***************************************************************/

    GUIManagedObject communicationChannelBlackoutPeriod = communicationChannelBlackoutService.getStoredCommunicationChannelBlackout(communicationChannelBlackoutPeriodID, includeArchived);
    JSONObject communicationChannelBlackoutPeriodJSON = communicationChannelBlackoutService.generateResponseJSON(communicationChannelBlackoutPeriod, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (communicationChannelBlackoutPeriod != null) ? "ok" : "communicationChannelBlackoutPeriodNotFound");
    if (communicationChannelBlackoutPeriod != null) response.put("blackoutPeriods", communicationChannelBlackoutPeriodJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutBlackoutPeriods
  *
  *****************************************/

  private JSONObject processPutBlackoutPeriods(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  CommunicationChannelBlackoutPeriodID
    *
    *****************************************/

    String communicationChannelBlackoutPeriodID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (communicationChannelBlackoutPeriodID == null)
      {
        communicationChannelBlackoutPeriodID = communicationChannelBlackoutService.generateCommunicationChannelBlackoutID();
        jsonRoot.put("id", communicationChannelBlackoutPeriodID);
      }

    /*****************************************
    *
    *  existing CommunicationChannelBlackoutPeriod
    *
    *****************************************/

    GUIManagedObject existingCommunicationChannelBlackoutPeriod = communicationChannelBlackoutService.getStoredCommunicationChannelBlackout(communicationChannelBlackoutPeriodID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingCommunicationChannelBlackoutPeriod != null && existingCommunicationChannelBlackoutPeriod.getReadOnly())
      {
        response.put("id", existingCommunicationChannelBlackoutPeriod.getGUIManagedObjectID());
        response.put("accepted", existingCommunicationChannelBlackoutPeriod.getAccepted());
        response.put("valid", existingCommunicationChannelBlackoutPeriod.getAccepted());
        response.put("processing", communicationChannelBlackoutService.isActiveCommunicationChannelBlackout(existingCommunicationChannelBlackoutPeriod, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process CommunicationChannelBlackoutPeriod
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate CommunicationChannelBlackoutPeriod
        *
        ****************************************/

        CommunicationChannelBlackoutPeriod communicationChannelBlackoutPeriod = new CommunicationChannelBlackoutPeriod(jsonRoot, epoch, existingCommunicationChannelBlackoutPeriod, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            communicationChannelBlackoutService.putCommunicationChannelBlackout(communicationChannelBlackoutPeriod,
                (existingCommunicationChannelBlackoutPeriod == null), userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", communicationChannelBlackoutPeriod.getGUIManagedObjectID());
        response.put("accepted", communicationChannelBlackoutPeriod.getAccepted());
        response.put("valid", communicationChannelBlackoutPeriod.getAccepted());
        response.put("processing", communicationChannelBlackoutService.isActiveCommunicationChannelBlackout(communicationChannelBlackoutPeriod, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {

            communicationChannelBlackoutService.putCommunicationChannelBlackout(incompleteObject,
                (existingCommunicationChannelBlackoutPeriod == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "communicationChannelBlackoutPeriodNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }

  /*****************************************
  *
  *  processRemoveBlackoutPeriods
  *
  *****************************************/

  private JSONObject processRemoveBlackoutPeriods(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> blackoutPeriods = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray blackoutPeriodsIDS = new JSONArray();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single communicationChannel
    //
    if (jsonRoot.containsKey("id"))
      {
        String blackoutPeriodsID = JSONUtilities.decodeString(jsonRoot, "id", false);
        blackoutPeriodsIDS.add(blackoutPeriodsID);
        GUIManagedObject blackoutPeriod = communicationChannelBlackoutService
            .getStoredCommunicationChannelBlackout(blackoutPeriodsID);

        if (blackoutPeriod != null && (force || !blackoutPeriod.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (blackoutPeriod != null)
          singleIDresponseCode = "failedReadOnly";
        else

          singleIDresponseCode = "existingBlackoutPeriodNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        blackoutPeriodsIDS = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
    
    for (int i = 0; i < blackoutPeriodsIDS.size(); i++)
      {
        String blackoutPeriodID = blackoutPeriodsIDS.get(i).toString();
        GUIManagedObject blackoutPeriod = communicationChannelBlackoutService.getStoredCommunicationChannelBlackout(blackoutPeriodID);
        if (blackoutPeriod != null && (force || !blackoutPeriod.getReadOnly()))
          {
            blackoutPeriods.add(blackoutPeriod);
            validIDs.add(blackoutPeriodID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < blackoutPeriods.size(); i++)
      {

        GUIManagedObject existingBlackoutPeriod = blackoutPeriods.get(i);

        communicationChannelBlackoutService
            .removeCommunicationChannelBlackout(existingBlackoutPeriod.getGUIManagedObjectID(), userID, tenantID);

      }
    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedExistingBlackoutPeriodIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
   *
   * processSetStatusBlackoutPeriods
   *
   *****************************************/

  private JSONObject processSetStatusBlackoutPeriods(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray blackoutIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < blackoutIDs.size(); i++)
      {

        String blackoutID = blackoutIDs.get(i).toString();
        GUIManagedObject existingElement = communicationChannelBlackoutService.getStoredCommunicationChannelBlackout(blackoutID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(blackoutID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);

            try
              {
                /****************************************
                 *
                 * instantiate CommunicationChannelBlackoutPeriod
                 *
                 ****************************************/

                CommunicationChannelBlackoutPeriod communicationChannelBlackoutPeriod = new CommunicationChannelBlackoutPeriod(
                    elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                communicationChannelBlackoutService.putCommunicationChannelBlackout(communicationChannelBlackoutPeriod,
                    (existingElement == null), userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                communicationChannelBlackoutService.putCommunicationChannelBlackout(incompleteObject,
                    (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }


  /*****************************************
  *
  *  processGetResellerList
  *
  *****************************************/

  private JSONObject processGetResellerList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve Reseller list
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> resellerList = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> resellerObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray resellerIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < resellerIDs.size(); i++)
          {
            String resellerID = resellerIDs.get(i).toString();
            GUIManagedObject reseller = resellerService.getStoredReseller(resellerID, includeArchived);
            if (reseller != null && reseller.getTenantID() == tenantID)
              {
                resellerObjects.add(reseller);
              }
          }
      }
    else
      {
        resellerObjects = resellerService.getStoredResellers(includeArchived, tenantID);
      }
    for (GUIManagedObject reseller : resellerObjects)
      {
        JSONObject resellerPro = resellerService.generateResponseJSON(reseller, fullDetails, now);
        resellerList.add(resellerPro);
      } 
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();   
    response.put("responseCode", "ok");
    response.put("resellers", JSONUtilities.encodeArray(resellerList));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processGetReseller
  *
  *****************************************/

  private JSONObject processGetReseller(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String resellerID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /**************************************************************
    *
    *  retrieve and decorate partner
    *
    ***************************************************************/

    GUIManagedObject reseller = resellerService.getStoredGUIManagedObject(resellerID, includeArchived);
    JSONObject resellerJSON = resellerService.generateResponseJSON(reseller, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (reseller != null) ? "ok" : "resellerNotFound");
    if (reseller != null) response.put("reseller", resellerJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processPutReseller
  *
  *****************************************/

  private JSONObject processPutReseller(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    List<String>existingResellersUserIDs = new ArrayList<>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }
  
     

    /*****************************************
    *
    *  resellerID
    *
    *****************************************/

    String resellerID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (resellerID == null)
      {
        resellerID = resellerService.generateResellerID();
        jsonRoot.put("id", resellerID);
      }
    
  
    /*****************************************
    *
    *  existing Reseller
    *
    *****************************************/

    GUIManagedObject existingReseller= resellerService.getStoredGUIManagedObject(resellerID);
    
    /*****************************************
    *
    *  To check if the user is already in another reseller users list
    *
    *****************************************/
   for (GUIManagedObject storedResellerObject : resellerService.getStoredResellers(tenantID))
      {
       if (storedResellerObject instanceof Reseller ) {
         Reseller storedReseller = (Reseller)storedResellerObject;
         for (String userid: storedReseller.getUserIDs()) {
           existingResellersUserIDs.add(userid);
         }
       }
      } 
  
    List<String> userIDs = JSONUtilities.decodeJSONArray(jsonRoot, "userIDs", new JSONArray());
 
    if (userIDs.size() != 0 && existingReseller == null) {
      for(String userId : userIDs) {
        if (existingResellersUserIDs.contains(userId))
          {
            response.put("responseCode", "USER ERROR");
            response.put("responseMessage", "The user already exist in another reseller");
            return JSONUtilities.encodeObject(response);           
          }    
      }
    }  

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingReseller != null && existingReseller.getReadOnly())
      {
        response.put("id", existingReseller.getGUIManagedObjectID());
        response.put("accepted", existingReseller.getAccepted());
        response.put("valid", existingReseller.getAccepted());        
        response.put("processing", resellerService.isActiveReseller(existingReseller, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process Reseller
    *
    *****************************************/
    
    processPartnerAlternateID(jsonRoot, tenantID);
    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate Reseller
        *
        ****************************************/

        Reseller reseller = new Reseller(jsonRoot, epoch, existingReseller, tenantID);
        
     
        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {
           resellerService.putReseller(reseller, (existingReseller == null), userID, resellerService);
          }

        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", reseller.getGUIManagedObjectID());
        response.put("accepted", reseller.getAccepted());
        response.put("valid", reseller.getAccepted());
        response.put("processing", resellerService.isActiveReseller(reseller, now));        
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            resellerService.putReseller(incompleteObject, (existingReseller == null), userID, resellerService);
          }

        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "ResellerInvalid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }
  
  /*****************************************
   *
   * processSetResellerStatus
   *
   *****************************************/

  private JSONObject processSetStatusReseller(String userID, JSONObject jsonRoot, int tenantID)
  {
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray resellerIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < resellerIDs.size(); i++)
      {

        String resellerID = resellerIDs.get(i).toString();
        GUIManagedObject existingElement = resellerService.getStoredReseller(resellerID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(resellerID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);

            try
              {

                Reseller reseller = new Reseller(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                resellerService.putReseller(reseller, (existingElement == null), userID, resellerService);
                
              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //
                resellerService.putReseller(incompleteObject, (existingElement == null), userID, resellerService);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }

          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);

  }

  /*****************************************
  *
  *  processGetSegmentContactPolicyList
  *
  *****************************************/

  private JSONObject processGetSegmentContactPolicyList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {
    /*****************************************
    *
    *  retrieve and convert SegmentContactPolicys
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    List<JSONObject> segmentContactPolicys = new ArrayList<JSONObject>();
    Collection <GUIManagedObject> segmentContactPolicyObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray segmentContactPolicyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < segmentContactPolicyIDs.size(); i++)
          {
            String segmentContactPolicyID = segmentContactPolicyIDs.get(i).toString();
            GUIManagedObject segmentContactPolicy = segmentContactPolicyService.getStoredSegmentContactPolicy(segmentContactPolicyID, includeArchived);
            if (segmentContactPolicy != null && segmentContactPolicy.getTenantID() == tenantID)
              {
                segmentContactPolicyObjects.add(segmentContactPolicy);
              }
          }
      }
    else
      {
        segmentContactPolicyObjects = segmentContactPolicyService.getStoredSegmentContactPolicys(includeArchived, tenantID);
      }
    for (GUIManagedObject segmentContactPolicy : segmentContactPolicyObjects)
      {
        segmentContactPolicys.add(segmentContactPolicyService.generateResponseJSON(segmentContactPolicy, fullDetails, now));
      }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();;
    response.put("responseCode", "ok");
    response.put("segmentContactPolicys", JSONUtilities.encodeArray(segmentContactPolicys));
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processPutSegmentContactPolicy
  *
  *****************************************/

  private JSONObject processPutSegmentContactPolicy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  segmentContactPolicyID -- there is only one -- add the hardwired ID to the requestb
    *
    *****************************************/


    jsonRoot.put("id", SegmentContactPolicy.singletonID);

    /*****************************************
    *
    *  existing existingSegmentContactPolicy
    *
    *****************************************/

    GUIManagedObject existingSegmentContactPolicy = segmentContactPolicyService.getStoredSegmentContactPolicy(SegmentContactPolicy.singletonID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingSegmentContactPolicy != null && existingSegmentContactPolicy.getReadOnly())
      {
        response.put("id", existingSegmentContactPolicy.getGUIManagedObjectID());
        response.put("accepted", existingSegmentContactPolicy.getAccepted());
        response.put("valid", existingSegmentContactPolicy.getAccepted());
        response.put("processing", segmentContactPolicyService.isActiveSegmentContactPolicy(existingSegmentContactPolicy, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process existingSegmentContactPolicy
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /****************************************
        *
        *  instantiate existingSegmentContactPolicy
        *
        ****************************************/

        SegmentContactPolicy segmentContactPolicy = new SegmentContactPolicy(jsonRoot, epoch, existingSegmentContactPolicy, tenantID);

        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {
            segmentContactPolicyService.putSegmentContactPolicy(segmentContactPolicy, contactPolicyService,
                segmentationDimensionService, (existingSegmentContactPolicy == null), userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", segmentContactPolicy.getGUIManagedObjectID());
        response.put("accepted", segmentContactPolicy.getAccepted());
        response.put("valid", segmentContactPolicy.getAccepted());
        response.put("processing", segmentContactPolicyService.isActiveSegmentContactPolicy(segmentContactPolicy, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            segmentContactPolicyService.putSegmentContactPolicy(incompleteObject, contactPolicyService,
                segmentationDimensionService, (existingSegmentContactPolicy == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "segmentContactPolicyNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }
  
  /*****************************************
  *
  *  processGetSegmentContactPolicy
  *
  *****************************************/

  private JSONObject processGetSegmentContactPolicy(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String segmentContactPolicyID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate segmentContactPolicy
    *
    *****************************************/

    GUIManagedObject segmentContactPolicy = segmentContactPolicyService.getStoredSegmentContactPolicy(segmentContactPolicyID, includeArchived);
    JSONObject segmentContactPolicyJSON = segmentContactPolicyService.generateResponseJSON(segmentContactPolicy, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (segmentContactPolicy != null) ? "ok" : "segmentContactPolicyNotFound");
    if (segmentContactPolicy != null) response.put("exclusionInclusionTarget", segmentContactPolicyJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processRemoveSegmentContactPolicy
  *
  *****************************************/

  private JSONObject processRemoveSegmentContactPolicy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> segmentContactPolicies = new ArrayList<>();
    JSONArray segmentContactPolicyIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single segmentContactPolicy
    //
    if (jsonRoot.containsKey("id"))
      {
        String segmentContactPolicyID = JSONUtilities.decodeString(jsonRoot, "id", false);
        segmentContactPolicyIDs.add(segmentContactPolicyID);
        GUIManagedObject segmentContactPolicy = segmentContactPolicyService
            .getStoredSegmentContactPolicy(segmentContactPolicyID);

        if (segmentContactPolicy != null && (force || !segmentContactPolicy.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (segmentContactPolicy != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "segmentContactPolicyNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        segmentContactPolicyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
  
    for (int i = 0; i < segmentContactPolicyIDs.size(); i++)
      {
        String segmentContactPolicyID = segmentContactPolicyIDs.get(i).toString();
        GUIManagedObject segmentContactPolicy = segmentContactPolicyService.getStoredSegmentContactPolicy(segmentContactPolicyID);
        
        if (segmentContactPolicy != null && (force || !segmentContactPolicy.getReadOnly()))
          {
            segmentContactPolicies.add(segmentContactPolicy);
            validIDs.add(segmentContactPolicyID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < segmentContactPolicies.size(); i++)
      {

        GUIManagedObject segmentContactPolicy = segmentContactPolicies.get(i);

        segmentContactPolicyService.removeSegmentContactPolicy(segmentContactPolicy.getGUIManagedObjectID(), userID, tenantID);

      }
    
    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedSegmentContactPolicyIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusSegmentContactPolicy
   *
   *****************************************/

  private JSONObject processSetStatusSegmentContactPolicy(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray segmentContactPolicyIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < segmentContactPolicyIDs.size(); i++)
      {

        String segmentContactPolicyID = segmentContactPolicyIDs.get(i).toString();
        GUIManagedObject existingElement = segmentContactPolicyService
            .getStoredSegmentContactPolicy(segmentContactPolicyID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(segmentContactPolicyID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                /****************************************
                 *
                 * instantiate existingSegmentContactPolicy
                 *
                 ****************************************/

                SegmentContactPolicy segmentContactPolicy = new SegmentContactPolicy(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                segmentContactPolicyService.putSegmentContactPolicy(segmentContactPolicy, contactPolicyService,
                    segmentationDimensionService, (existingElement == null), userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                segmentContactPolicyService.putSegmentContactPolicy(incompleteObject, contactPolicyService,
                    segmentationDimensionService, (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }
              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processEnterCampaign
   * @throws GUIManagerException 
  *
  *****************************************/
  
  private JSONObject processEnterCampaign(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    
    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/
    String responseCode = null;
    
    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID {}", getCustomerAlternateID, customerID);
        responseCode = "CustomerNotFound";
      }

    /*****************************************
    *
    *  getSubscriberProfile
    *
    *****************************************/

    SubscriberProfile baseSubscriberProfile = null;
    if (subscriberID != null)
      {
        try
          {
            baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, true);
            if (baseSubscriberProfile == null)
              {
                responseCode = "CustomerNotFound";
              }
          }
        catch (SubscriberProfileServiceException e)
          {
            throw new GUIManagerException(e);
          }
      }
    
    Journey journey = null;
    if(responseCode == null)
      {
        String campaignName = JSONUtilities.decodeString(jsonRoot, "campaignName", false);
        String campaignID = "" + JSONUtilities.decodeInteger(jsonRoot, "campaignId", false); // MK hack
        Collection<Journey> allJourneys = journeyService.getActiveJourneys(SystemTime.getCurrentTime(), tenantID);
        if(allJourneys != null)
          {
            for(Journey activeJourney : allJourneys)
              {
                if(campaignName != null)
                  {
                    if(activeJourney.getJourneyName().equalsIgnoreCase(campaignName))
                      {
                        if(activeJourney.getTargetingType().equals(TargetingType.Manual))
                          {
                            journey = activeJourney;
                            responseCode = null;
                            break;
                          }
                        else
                          {
                            responseCode = "Campaign is not manual targeting";
                          }
                      }
                    else
                      {
                        responseCode = "Campaign not found";
                      }
                  }
                else if(campaignID != null)
                  {
                    if(activeJourney.getJourneyID().equals(campaignID))
                      {
                        if(activeJourney.getTargetingType().equals(TargetingType.Manual))
                          {
                            journey = activeJourney;
                            responseCode = null;
                            break;
                          }
                        else
                          {
                            responseCode = "Campaign is not manual targeting";
                          }
                      }
                    else
                      {
                        responseCode = "Campaign not found";
                      }
                  }
                else 
                  {
                    responseCode = "campaignName or campaignID must be provided";
                    break;
                  }
              }
          }
        else
          {
            responseCode = "Campaign not found";
          }
      }
    
    if(journey != null)
      {
        String uniqueKey = UUID.randomUUID().toString();
        JourneyRequest journeyRequest = new JourneyRequest(baseSubscriberProfile, subscriberGroupEpochReader, uniqueKey, subscriberID, journey.getJourneyID(), baseSubscriberProfile.getUniversalControlGroup(), tenantID);
        journeyRequest.forceDeliveryPriority(DELIVERY_REQUEST_PRIORITY);
        DeliveryManagerDeclaration journeyManagerDeclaration = Deployment.getDeliveryManagers().get(journeyRequest.getDeliveryType());
        String journeyRequestTopic = journeyManagerDeclaration.getRequestTopic(journeyRequest.getDeliveryPriority());
        
        Properties kafkaProducerProperties = new Properties();
        kafkaProducerProperties.put("bootstrap.servers", Deployment.getBrokerServers());
        kafkaProducerProperties.put("acks", "all");
        kafkaProducerProperties.put("key.serializer", "org.apache.kafka.common.serialization.ByteArraySerializer");
        kafkaProducerProperties.put("value.serializer", "org.apache.kafka.common.serialization.ByteArraySerializer");
        KafkaProducer journeyProducer = new KafkaProducer<byte[], byte[]>(kafkaProducerProperties);
        journeyProducer.send(new ProducerRecord<byte[], byte[]>(journeyRequestTopic, StringKey.serde().serializer().serialize(journeyRequestTopic, new StringKey(journeyRequest.getSubscriberID())), ((ConnectSerde<DeliveryRequest>)journeyManagerDeclaration.getRequestSerde()).serializer().serialize(journeyRequestTopic, journeyRequest)));
      
        responseCode = "ok";
      }
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", responseCode);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processCreditBonus
  *
  *****************************************/
  
  private JSONObject processCreditBonus(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String bonusID = JSONUtilities.decodeString(jsonRoot, "bonusID", true);
    Integer quantity = JSONUtilities.decodeInteger(jsonRoot, "quantity", true);
    String origin = JSONUtilities.decodeString(jsonRoot, "origin", true);
    String userName = JSONUtilities.decodeString(jsonRoot, "userName", false);
    String featureID = (userName != null) ? userName : "administrator";

    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/
    
    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID {}", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
        return JSONUtilities.encodeObject(response);
      }
    
    /*****************************************
    *
    *  resolve bonus
    *
    *****************************************/

    Deliverable searchedBonus = null;
    for (GUIManagedObject storedDeliverable : deliverableService.getStoredDeliverables(tenantID))
      {
        if (storedDeliverable instanceof Deliverable && bonusID.equals(((Deliverable) storedDeliverable).getExternalAccountID()))
          {
              searchedBonus = (Deliverable) storedDeliverable;
              break;
          }
      }
    
    if (searchedBonus == null)
      {
        log.info("bonus " + bonusID + " not found");
        response.put("responseCode", "BonusNotFound");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  generate commodity delivery request
    *
    *****************************************/
    
    String deliveryRequestID = zuks.getStringKey();
    String eventID = deliveryRequestID.concat("-").concat(Module.Customer_Care.toString());
    try {
      SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
      GUIManagedObject pointObject = pointService.getStoredPoint(bonusID);
      com.evolving.nglm.evolution.EvolutionUtilities.TimeUnit validityPeriodType = null;
      int validityPeriod = 0;
      
      if (pointObject != null && pointObject instanceof Point) {
        Point point = (Point) pointObject;
        validityPeriodType = point.getValidity().getPeriodType();
        validityPeriod = point.getValidity().getPeriodQuantity();
      }
     CommodityDeliveryManagerRemovalUtils.sendCommodityDeliveryRequest(paymentMeanService,deliverableService,subscriberProfile,subscriberGroupEpochReader,null, null, deliveryRequestID, null, true, eventID, Module.Customer_Care.getExternalRepresentation(), featureID, subscriberID, searchedBonus.getFulfillmentProviderID(), searchedBonus.getDeliverableID(), CommodityDeliveryOperation.Credit, quantity, validityPeriodType, validityPeriod, DELIVERY_REQUEST_PRIORITY, origin, tenantID);
    } catch (SubscriberProfileServiceException|CommodityDeliveryException e) {
      throw new GUIManagerException(e);
    }

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("deliveryRequestID", deliveryRequestID);
    response.put("responseCode", "ok");
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processDebitBonus
  *
  *****************************************/
  
  private JSONObject processDebitBonus(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException {
    
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String bonusID = JSONUtilities.decodeString(jsonRoot, "bonusID", true);
    Integer quantity = JSONUtilities.decodeInteger(jsonRoot, "quantity", true);
    String origin = JSONUtilities.decodeString(jsonRoot, "origin", true);
    String userName = JSONUtilities.decodeString(jsonRoot, "userName", false);
    String featureID = (userName != null) ? userName : "administrator";

    /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/
    
    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID {}", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
        return JSONUtilities.encodeObject(response);
      }
    
    /*****************************************
    *
    *  resolve bonus
    *
    *****************************************/

    Deliverable searchedBonus = null;
    for (GUIManagedObject storedDeliverable : deliverableService.getStoredDeliverables(tenantID))
      {
        if (storedDeliverable instanceof Deliverable && bonusID.equals(((Deliverable) storedDeliverable).getExternalAccountID()))
          {
              searchedBonus = (Deliverable) storedDeliverable;
              break;
          }
      }

    if(searchedBonus == null){
      log.info("bonus with ID '"+bonusID+"' not found");
      response.put("responseCode", "BonusNotFound");
      return JSONUtilities.encodeObject(response);
    }
    
    /*****************************************
    *
    *  generate commodity delivery request
    *
    *****************************************/
    
    String deliveryRequestID = zuks.getStringKey();
    String eventID = deliveryRequestID.concat("-").concat(Module.Customer_Care.toString());
    try {
      SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
      CommodityDeliveryManagerRemovalUtils.sendCommodityDeliveryRequest(paymentMeanService,deliverableService,subscriberProfile,subscriberGroupEpochReader,null, null, deliveryRequestID, null, true, eventID, Module.Customer_Care.getExternalRepresentation(), featureID, subscriberID, searchedBonus.getFulfillmentProviderID(), searchedBonus.getDeliverableID(), CommodityDeliveryOperation.Debit, quantity, null, null, DELIVERY_REQUEST_PRIORITY, origin, tenantID);
    } catch (SubscriberProfileServiceException|CommodityDeliveryException e) {
      throw new GUIManagerException(e);
    }
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("deliveryRequestID", deliveryRequestID);
    response.put("responseCode", "ok");
    return JSONUtilities.encodeObject(response);
  }
  
   /*****************************************
   *
   * processRemoveReseller
   *
   *****************************************/

  private JSONObject processRemoveReseller(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    HashMap<String, Object> response = new HashMap<String, Object>();
    Date now = SystemTime.getCurrentTime();
    JSONObject dependencyRequest = new JSONObject();
    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> existingResellers = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray resellerIDs = new JSONArray();

    /****************************************
     *
     * argument
     *
     ****************************************/
    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);

    /*****************************************
     *
     * remove
     *
     *****************************************/
    //
    // remove single reseller
    //
    if (jsonRoot.containsKey("id"))
      {
        String resellerID = JSONUtilities.decodeString(jsonRoot, "id", false);
        resellerIDs.add(resellerID);
        GUIManagedObject reseller = resellerService.getStoredReseller(resellerID);
        if (reseller != null && (force || !reseller.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (reseller != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "resellerNotFound";
      }
    //
    // multiple deletion
    //

    if (jsonRoot.containsKey("ids"))
      {
        resellerIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }

    for (int i = 0; i < resellerIDs.size(); i++)
      {
        String resellerID = resellerIDs.get(i).toString();
        GUIManagedObject reseller = resellerService.getStoredGUIManagedObject(resellerID);

        if (reseller != null && (force || !reseller.getReadOnly()))
          {

            dependencyRequest.put("apiVersion", 1);
            dependencyRequest.put("objectType", "reseller");
            dependencyRequest.put("id", resellerID);

            JSONObject dependenciesObject = guiManagerGeneral.processGetDependencies(userID, dependencyRequest, tenantID);
            JSONArray dependencies = JSONUtilities.decodeJSONArray(dependenciesObject, "dependencies", new JSONArray());
            boolean parentDependency = false;
            if (dependencies.size() != 0)
              {
                for (int j = 0; j < dependencies.size(); j++)
                  {
                    JSONObject dependent = (JSONObject) dependencies.get(j);
                    String ojectType = JSONUtilities.decodeString(dependent, "objectType", false);
                    if ("reseller".equals(ojectType))
                      {
                        parentDependency = true;
                        break;
                      }
                  }
              }
            if (!parentDependency)
              {
                existingResellers.add(reseller);
                validIDs.add(resellerID);
              }
            else
              {
                if (jsonRoot.containsKey("id"))
                  {
                    response.put("responseCode",
                        RESTAPIGenericReturnCodes.DEPENDENCY_RESTRICTION.getGenericResponseCode());
                    response.put("responseMessage",
                        RESTAPIGenericReturnCodes.DEPENDENCY_RESTRICTION.getGenericResponseMessage());
                    return JSONUtilities.encodeObject(response);
                  }
              }
          }
      }
    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (GUIManagedObject existingReseller : existingResellers)
      {
        long epoch = epochServer.getKey();

        resellerService.removeReseller(existingReseller.getGUIManagedObjectID(), userID, tenantID);

        List<SalesChannel> storedSalesChannels = new ArrayList<SalesChannel>();
        for (GUIManagedObject storedSalesChannel : salesChannelService.getStoredSalesChannels(tenantID))
          {
            if (storedSalesChannel instanceof SalesChannel)
              storedSalesChannels.add((SalesChannel) storedSalesChannel);
          }
        for (SalesChannel sChannel : storedSalesChannels)
          {
            List<String> resellers = sChannel.getResellerIDs();
            if (resellers != null && resellers.size() > 0
                && resellers.contains(existingReseller.getGUIManagedObjectID()))
              {
                try
                  {
                    JSONObject salesChannelJSON = sChannel.getJSONRepresentation();
                    JSONArray newResellers = new JSONArray();
                    resellers.remove(existingReseller.getGUIManagedObjectID());
                    for (String reseller : resellers)
                      {
                        newResellers.add(reseller);
                      }
                    /*****************************************
                     *
                     * Remove the old Reseller list and update with the new
                     * resellers
                     *
                     *****************************************/
                    salesChannelJSON.replace("resellerIDs", newResellers);

                    SalesChannel newSalesChannel = new SalesChannel(salesChannelJSON, epoch, sChannel, tenantID);

                    /*****************************************
                     *
                     * store
                     *
                     *****************************************/

                    salesChannelService.putSalesChannel(newSalesChannel, callingChannelService, resellerService, true,
                        userID);

                    /*****************************************
                     *
                     * revalidateOffers
                     *
                     *****************************************/

                    revalidateOffers(now, tenantID);

                  }
                catch (JSONUtilitiesException | GUIManagerException e)
                  {

                    log.error("JSONUtilitiesException " + e.getMessage());

                  }

              }
          }

      }


    /*****************************************
     *
     * responseCode
     *
     *****************************************/

    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/
    response.put("removedResellerIDS", JSONUtilities.encodeArray(validIDs));

    return JSONUtilities.encodeObject(response);
  }
 
  /*****************************************
  *
  *  processConfigAdaptorSubscriberMessageTemplate
  *
  *****************************************/

  private JSONObject processConfigAdaptorSubscriberMessageTemplate(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String templateID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve template
    *
    *****************************************/

    SubscriberMessageTemplate template = subscriberMessageTemplateService.getActiveSubscriberMessageTemplate(templateID, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  format result
    *
    *****************************************/

    HashMap<String,Object> templateJSON = new HashMap<String,Object>();
    if (template != null)
      {
        /*****************************************
        *
        *  messageByLanguagea
        *
        *****************************************/

        Map<String,Map<String,Object>> messageByLanguage = new HashMap<String,Map<String,Object>>();
        for (Entry<String, DialogMessage> entry : template.getDialogMessages().entrySet())
          {
            String messageTextField = entry.getKey();
            DialogMessage messageText = entry.getValue();
            for (String language : messageText.getMessageTextByLanguage().keySet())
              {
                //
                //  create entry for language (if necessary)
                //

                Map<String,Object> fieldsByLanguage = messageByLanguage.get(language);
                if (fieldsByLanguage == null)
                  {
                    fieldsByLanguage = new HashMap<String,Object>();
                    fieldsByLanguage.put("language", language);
                    messageByLanguage.put(language, fieldsByLanguage);
                  }

                //
                //  field
                //

                fieldsByLanguage.put(messageTextField, messageText.getMessageTextByLanguage().get(language));
              }
          }

        /*****************************************
        *
        *  messageJSON
        *
        *****************************************/

        List<JSONObject> messageJSON = new ArrayList<JSONObject>();
        for (Map<String,Object> fieldsByLanguage : messageByLanguage.values())
          {
            messageJSON.add(JSONUtilities.encodeObject(fieldsByLanguage));
          }

        /*****************************************
        *
        *  template
        *
        *****************************************/
        
        templateJSON.put("id", template.getSubscriberMessageTemplateID());
        templateJSON.put("name", template.getSubscriberMessageTemplateName());
        templateJSON.put("processing", subscriberMessageTemplateService.isActiveGUIManagedObject(template, SystemTime.getCurrentTime()));
        templateJSON.put("templateType", template.getTemplateType());
        templateJSON.put("message", JSONUtilities.encodeArray(messageJSON));
      }

    
    /*****************************************
    *
    *  response
    *
    *****************************************/


    response.put("responseCode", (template != null) ? "ok" : "templateNotFound");
    if (template != null) response.put("template", JSONUtilities.encodeObject(templateJSON));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorOffer
  *
  *****************************************/

  private JSONObject processConfigAdaptorOffer(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String offerID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate offer
    *
    *****************************************/

    GUIManagedObject offer = offerService.getStoredOffer(offerID);
    JSONObject offerJSON = offerService.generateResponseJSON(offer, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    offerJSON.remove("readOnly");
    offerJSON.remove("accepted");
    offerJSON.remove("valid");
    offerJSON.remove("active");

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (offer != null) ? "ok" : "offerNotFound");
    if (offer != null) response.put("offer", offerJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorProduct
  *
  *****************************************/

  private JSONObject processConfigAdaptorProduct(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String productID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject product = productService.getStoredProduct(productID);
    JSONObject productJSON = productService.generateResponseJSON(product, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    productJSON.remove("readOnly");
    productJSON.remove("accepted");
    productJSON.remove("valid");
    productJSON.remove("active");

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (product != null) ? "ok" : "productNotFound");
    if (product != null) response.put("product", productJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorPresentationStrategy
  *
  *****************************************/

  private JSONObject processConfigAdaptorPresentationStrategy(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String presentationStrategyID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate presentation strategy
    *
    *****************************************/

    GUIManagedObject presentationStrategy = presentationStrategyService.getStoredPresentationStrategy(presentationStrategyID);
    JSONObject presentationStrategyJSON = presentationStrategyService.generateResponseJSON(presentationStrategy, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    presentationStrategyJSON.remove("readOnly");
    presentationStrategyJSON.remove("accepted");
    presentationStrategyJSON.remove("valid");
    presentationStrategyJSON.remove("active");

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (presentationStrategy != null) ? "ok" : "presentationStrategyNotFound");
    if (presentationStrategy != null) response.put("presentationStrategy", presentationStrategyJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorScoringStrategy
  *
  *****************************************/

  private JSONObject processConfigAdaptorScoringStrategy(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String scoringStrategyID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject scoringStrategy = scoringStrategyService.getStoredScoringStrategy(scoringStrategyID);
    JSONObject scoringStrategyJSON = scoringStrategyService.generateResponseJSON(scoringStrategy, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    scoringStrategyJSON.remove("readOnly");
    scoringStrategyJSON.remove("accepted");
    scoringStrategyJSON.remove("valid");
    scoringStrategyJSON.remove("active");
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (scoringStrategy != null) ? "ok" : "scoringStrategyNotFound");
    if (scoringStrategy != null) response.put("scoringStrategy", scoringStrategyJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorCallingChannel
  *
  *****************************************/

  private JSONObject processConfigAdaptorCallingChannel(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String callingChannelID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject callingChannel = callingChannelService.getStoredCallingChannel(callingChannelID);
    JSONObject callingChannelJSON = callingChannelService.generateResponseJSON(callingChannel, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    callingChannelJSON.remove("readOnly");
    callingChannelJSON.remove("accepted");
    callingChannelJSON.remove("valid");
    callingChannelJSON.remove("active");
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (callingChannel != null) ? "ok" : "callingChannelNotFound");
    if (callingChannel != null) response.put("callingChannel", callingChannelJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorSalesChannel
  *
  *****************************************/

  private JSONObject processConfigAdaptorSalesChannel(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String salesChannelID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject salesChannel = salesChannelService.getStoredSalesChannel(salesChannelID);
    JSONObject salesChannelJSON = salesChannelService.generateResponseJSON(salesChannel, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    salesChannelJSON.remove("readOnly");
    salesChannelJSON.remove("accepted");
    salesChannelJSON.remove("valid");
    salesChannelJSON.remove("active");
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (salesChannel != null) ? "ok" : "salesChannelNotFound");
    if (salesChannel != null) response.put("salesChannel", salesChannelJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorCommunicationChannel
  *
  *****************************************/

  private JSONObject processConfigAdaptorCommunicationChannel(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String communicationChannelID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate communication channel
    *
    *****************************************/

    CommunicationChannel communicationChannel = Deployment.getDeployment(tenantID).getCommunicationChannels().get(communicationChannelID);
       
    JSONObject communicationChannelJSON = communicationChannel.generateResponseJSON(true, SystemTime.getCurrentTime());
    
    CommunicationChannelTimeWindow timeWindow = communicationChannelTimeWindowService.getActiveCommunicationChannelTimeWindow(communicationChannel.getID(), SystemTime.getCurrentTime());
    
    if(timeWindow != null) 
      {
        JSONObject timeWindowJsonRepresentation = timeWindow.getJSONRepresentation(); 
        timeWindowJsonRepresentation.remove("communicationChannelID");
        communicationChannelJSON.put("notificationDailyWindows", timeWindowJsonRepresentation); 
      }

    //
    //  remove gui specific fields
    //
    
    communicationChannelJSON.remove("readOnly");
    communicationChannelJSON.remove("accepted");
    communicationChannelJSON.remove("valid");
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (communicationChannel != null) ? "ok" : "communicationChannelNotFound");
    if (communicationChannel != null) response.put("communicationChannel", communicationChannelJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorBlackoutPeriods
  *
  *****************************************/

  private JSONObject processConfigAdaptorBlackoutPeriods(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String communicationChannelBlackoutPeriodID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /**************************************************************
    *
    *  retrieve and decorate communication channel blackout period
    *
    ***************************************************************/

    GUIManagedObject communicationChannelBlackoutPeriod = communicationChannelBlackoutService.getStoredCommunicationChannelBlackout(communicationChannelBlackoutPeriodID);
    JSONObject communicationChannelBlackoutPeriodJSON = communicationChannelBlackoutService.generateResponseJSON(communicationChannelBlackoutPeriod, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    communicationChannelBlackoutPeriodJSON.remove("readOnly");
    communicationChannelBlackoutPeriodJSON.remove("accepted");
    communicationChannelBlackoutPeriodJSON.remove("valid");
    communicationChannelBlackoutPeriodJSON.remove("active");
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (communicationChannelBlackoutPeriod != null) ? "ok" : "communicationChannelBlackoutPeriodNotFound");
    if (communicationChannelBlackoutPeriod != null) response.put("blackoutPeriods", communicationChannelBlackoutPeriodJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorContactPolicy
  *
  *****************************************/

  private JSONObject processConfigAdaptorContactPolicy(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String contactPolicyID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject contactPolicy = contactPolicyService.getStoredContactPolicy(contactPolicyID);
    JSONObject contactPolicyJSON = contactPolicyService.generateResponseJSON(contactPolicy, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    contactPolicyJSON.remove("readOnly");
    contactPolicyJSON.remove("accepted");
    contactPolicyJSON.remove("valid");
    contactPolicyJSON.remove("active");
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (contactPolicy != null) ? "ok" : "contactPolicyNotFound");
    if (contactPolicy != null) response.put("contactPolicy", contactPolicyJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorCampaign
  *
  *****************************************/

  private JSONObject processConfigAdaptorCampaign(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String journeyID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve
    *
    *****************************************/

    GUIManagedObject journey = journeyService.getStoredJourney(journeyID);
    JSONObject journeyJSON = journeyService.generateResponseJSON(journey, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    journeyJSON.remove("readOnly");
    journeyJSON.remove("accepted");
    journeyJSON.remove("valid");
    journeyJSON.remove("targetNoOfConversions");
    journeyJSON.remove("targetingEvent");
    journeyJSON.remove("effectiveEntryPeriodEndDate");
    journeyJSON.remove("maxNoOfCustomers");
    journeyJSON.remove("description");
    journeyJSON.remove("nodes");
    journeyJSON.remove("name");
    journeyJSON.remove("eligibilityCriteria");
    journeyJSON.remove("targetingType");
    journeyJSON.remove("links");
    journeyJSON.remove("status");
    journeyJSON.remove("targetingCriteria");
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (journey != null) ? "ok" : "campaignNotFound");
    if (journey != null) response.put("campaign", journeyJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorJourneyObjective
  *
  *****************************************/

  private JSONObject processConfigAdaptorJourneyObjective(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String journeyObjectiveID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    GUIManagedObject journeyObjective = journeyObjectiveService.getStoredJourneyObjective(journeyObjectiveID);
    JSONObject journeyObjectiveJSON = journeyObjectiveService.generateResponseJSON(journeyObjective, true, now);

    //
    //  remove gui specific fields
    //
    
    journeyObjectiveJSON.remove("readOnly");
    journeyObjectiveJSON.remove("accepted");
    journeyObjectiveJSON.remove("valid");
    journeyObjectiveJSON.remove("targetingLimitWaitingPeriodDuration");
    journeyObjectiveJSON.remove("targetingLimitMaxSimultaneous");
    journeyObjectiveJSON.remove("display");
    journeyObjectiveJSON.remove("targetingLimitMaxOccurrence");
    journeyObjectiveJSON.remove("targetingLimitSlidingWindowTimeUnit");
    journeyObjectiveJSON.remove("targetingLimitWaitingPeriodTimeUnit");
    journeyObjectiveJSON.remove("targetingLimitSlidingWindowDuration");
    journeyObjectiveJSON.remove("name");
    journeyObjectiveJSON.remove("catalogCharacteristics");        
    journeyObjectiveJSON.remove("active");

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (journeyObjective != null) ? "ok" : "journeyObjectiveNotFound");
    if (journeyObjective != null) response.put("journeyObjective", journeyObjectiveJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorProductType
  *
  *****************************************/

  private JSONObject processConfigAdaptorProductType(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String productTypeID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate product type
    *
    *****************************************/

    GUIManagedObject productType = productTypeService.getStoredProductType(productTypeID);
    JSONObject productTypeJSON = productTypeService.generateResponseJSON(productType, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    productTypeJSON.remove("readOnly");
    productTypeJSON.remove("accepted");
    productTypeJSON.remove("valid");
    productTypeJSON.remove("active");

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (productType != null) ? "ok" : "productTypeNotFound");
    if (productType != null) response.put("productType", productTypeJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorOfferObjective
  *
  *****************************************/

  private JSONObject processConfigAdaptorOfferObjective(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String offerObjectiveID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject offerObjective = offerObjectiveService.getStoredOfferObjective(offerObjectiveID);
    JSONObject offerObjectiveJSON = offerObjectiveService.generateResponseJSON(offerObjective, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    offerObjectiveJSON.remove("readOnly");
    offerObjectiveJSON.remove("accepted");
    offerObjectiveJSON.remove("valid");
    offerObjectiveJSON.remove("active");

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (offerObjective != null) ? "ok" : "offerObjectiveNotFound");
    if (offerObjective != null) response.put("offerObjective", offerObjectiveJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorScoringEngines
  *
  *****************************************/

  private JSONObject processConfigAdaptorScoringEngines(JSONObject jsonRoot, int tenantID)
  {
    return processGetScoringEngines(null, jsonRoot, tenantID);
  }

  /*****************************************
  *
  *  processConfigAdaptorPresentationCriterionFields
  *
  *****************************************/

  private JSONObject processConfigAdaptorPresentationCriterionFields(JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  retrieve presentation criterion fields
    *
    *****************************************/

    List<JSONObject> presentationCriterionFields = processCriterionFields(CriterionContext.Presentation(tenantID).getCriterionFields(tenantID), false, tenantID);

    //
    //  remove gui specific objects
    //

    for(JSONObject jSONObject : presentationCriterionFields)
      {
        jSONObject.remove("minValue");
        jSONObject.remove("operators");
        jSONObject.remove("maxValue");
        jSONObject.remove("display");
        jSONObject.remove("singletonComparableFields");
        jSONObject.remove("tagMaxLength");
        jSONObject.remove("availableValues");
        jSONObject.remove("setValuedComparableFields");
      }
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    response.put("presentationCriterionFields", JSONUtilities.encodeArray(presentationCriterionFields));
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorDefaultNoftificationDailyWindows
  *
  *****************************************/

  private JSONObject processConfigAdaptorDefaultNoftificationDailyWindows(JSONObject jsonRoot, int tenantID)
  {
    /*****************************************
    *
    *  response
    *
    *****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    response.put("responseCode", "ok");
    CommunicationChannelTimeWindow notifWindows = communicationChannelTimeWindowService.getActiveCommunicationChannelTimeWindow("default", SystemTime.getCurrentTime());
    response.put("defaultNoftificationDailyWindows", notifWindows.getJSONRepresentation());
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorDeliverable
  *
  *****************************************/

  private JSONObject processConfigAdaptorDeliverable(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String deliverableID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject deliverable = deliverableService.getStoredDeliverable(deliverableID);
    JSONObject deliverableJSON = deliverableService.generateResponseJSON(deliverable, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    deliverableJSON.remove("readOnly");
    deliverableJSON.remove("accepted");
    deliverableJSON.remove("valid");
    deliverableJSON.remove("active");

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (deliverable != null) ? "ok" : "deliverableNotFound");
    if (deliverable != null) response.put("deliverable", deliverableJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processConfigAdaptorSourceAddress
  *
  *****************************************/

  private JSONObject processConfigAdaptorSourceAddress(JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String sourceAddressID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate source address
    *
    *****************************************/

    GUIManagedObject sourceAddress = sourceAddressService.getStoredSourceAddress(sourceAddressID);
    JSONObject sourceAddressJSON = sourceAddressService.generateResponseJSON(sourceAddress, true, SystemTime.getCurrentTime());

    //
    //  remove gui specific fields
    //
    
    sourceAddressJSON.remove("readOnly");
    sourceAddressJSON.remove("accepted");
    sourceAddressJSON.remove("valid");
    sourceAddressJSON.remove("active");
    
    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (sourceAddress != null) ? "ok" : "sourceAddressNotFound");
    if (sourceAddress != null) response.put("sourceAddress", sourceAddressJSON);
    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
   *
   *  processGetTokensCodesList
   *
   *****************************************/

  private JSONObject processGetTokensCodesList(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /****************************************
     *
     *  response
     *
     ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
     *
     *  arguments
     *
     ****************************************/
    
    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String tokenStatus = JSONUtilities.decodeString(jsonRoot, "tokenStatus", false);

    /*****************************************
     *
     *  resolve subscriberID
     *
     *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
        return JSONUtilities.encodeObject(response);
      }

    if (tokenStatus != null)
      {
        boolean found = false;
        for (TokenStatus enumeratedValue : TokenStatus.values())
          {
            if (enumeratedValue.getExternalRepresentation().equalsIgnoreCase(tokenStatus))
              {
                found = true;
                break; 
              }
          }
        if (!found)
          {
            String str = "bad tokenStatus : " + tokenStatus;
            log.error(str);
            response.put("responseCode", str);
            return JSONUtilities.encodeObject(response);
          }
      }
    String tokenStatusForStreams = tokenStatus; // We need a 'final-like' variable to process streams later
    boolean hasFilter = (tokenStatusForStreams != null);

    /*****************************************
     *
     *  getSubscriberProfile
     *
     *****************************************/

    try
    {
      SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
      if (subscriberProfile == null)
        {
          response.put("responseCode", "CustomerNotFound");
        } 
      else
        {
          List<JSONObject> tokensJson;
          List<Token> tokens = subscriberProfile.getTokens();
          if (tokens == null)
            {
              tokensJson = new ArrayList<>();
            }
          else 
            {
              Stream<Token> tokenStream = tokens.stream();
              if (hasFilter)
                {
                  if (log.isTraceEnabled()) log.trace("Filter provided : "+tokenStatus);
                  tokenStream = tokenStream.filter(token -> tokenStatusForStreams.equalsIgnoreCase(token.getTokenStatus().getExternalRepresentation()));
                }
              tokensJson = tokenStream
                  .map(token -> ThirdPartyJSONGenerator.generateTokenJSONForThirdParty(token, journeyService, offerService, scoringStrategyService, presentationStrategyService, offerObjectiveService, loyaltyProgramService, tokenTypeService, tenantID))
                  .collect(Collectors.toList());
            }

          /*****************************************
          *
          *  decorate and response
          *
          *****************************************/

          response.put("tokens", JSONUtilities.encodeArray(tokensJson));
          response.put("responseCode", "ok");
        }
    }
    catch (SubscriberProfileServiceException e)
    {
      throw new GUIManagerException(e);
    }

    /*****************************************
     *
     * return
     *
     *****************************************/

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
   *
   *  processGetCustomerNBOs
   *
   *****************************************/

  private JSONObject processGetCustomerNBOs(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /****************************************
     *
     *  response
     *
     ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
     *
     *  argument
     *
     ****************************************/
    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String tokenCode = JSONUtilities.decodeString(jsonRoot, "tokenCode", false);
    Boolean viewOffersOnly = JSONUtilities.decodeBoolean(jsonRoot, "viewOffersOnly", Boolean.FALSE);
    String supplierID = JSONUtilities.decodeString(jsonRoot, "supplier", false);
    Supplier supplier = null;

    /*****************************************
    *
    *  getSupplier
    *
    *****************************************/
    if (supplierID != null) {
      GUIManagedObject supplierObject = supplierService.getStoredSupplier(supplierID);
      if (supplierObject instanceof Supplier) {
        supplier = (Supplier) supplierObject;
      }
    }

    /*****************************************
     *
     *  resolve subscriberID
     *
     *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
        return JSONUtilities.encodeObject(response);
      }

    Date now = SystemTime.getCurrentTime();

    /*****************************************
     *
     *  getSubscriberProfile
     *
     *****************************************/

    try
    {
      SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
      if (subscriberProfile == null)
        {
          response.put("responseCode", "CustomerNotFound");
        } 
      else
        {
          Token subscriberToken = null;
          if (tokenCode != null)
            {
              for (Token token : subscriberProfile.getTokens())
                {
                  if (tokenCode.equals(token.getTokenCode()))
                    {
                      subscriberToken = token;
                      break;
                    }
                }
            }
          if (subscriberToken == null)
            {
              String str = "No tokens returned";
              log.error(str);
              response.put("responseCode", str);
              generateTokenChange(subscriberID, now, tokenCode, userID, TokenChange.ALLOCATE, str, tenantID);
              return JSONUtilities.encodeObject(response);
            }

          if (!(subscriberToken instanceof DNBOToken))
            {
              // TODO can this really happen ?
              String str = "Bad token type";
              log.error(str);
              response.put("responseCode", str);
              generateTokenChange(subscriberID, now, tokenCode, userID, TokenChange.ALLOCATE, str, tenantID);
              return JSONUtilities.encodeObject(response);
            }

          DNBOToken subscriberStoredToken = (DNBOToken) subscriberToken;
          String presentationStrategyID = subscriberStoredToken.getPresentationStrategyID();
          if (presentationStrategyID == null)
            {
              String str = "Bad strategy : null value";
              log.error(str);
              response.put("responseCode", str);
              return JSONUtilities.encodeObject(response);
            }
          PresentationStrategy presentationStrategy = (PresentationStrategy) presentationStrategyService.getStoredPresentationStrategy(presentationStrategyID);
          if (presentationStrategy == null)
            {
              String str = "Bad strategy : unknown id : "+presentationStrategyID;
              log.error(str);
              response.put("responseCode", str);
              generateTokenChange(subscriberID, now, tokenCode, userID, TokenChange.ALLOCATE, str, tenantID);
              return JSONUtilities.encodeObject(response);
            }

          if (!viewOffersOnly)
            {
              Collection<ProposedOfferDetails> list = ThirdPartyManager.allocateAndSendPresentationLog(jsonRoot,
                  subscriberID, tokenCode, now, null/*supplierFilter*/, subscriberProfile,
                  subscriberStoredToken, presentationStrategyID, presentationStrategy,
                  kafkaProducer,
                  offerService,
                  segmentationDimensionService,
                  productService,
                  voucherService,
                  scoringStrategyService,
                  productTypeService,
                  voucherTypeService,
                  catalogCharacteristicService,
                  dnboMatrixService,
                  supplierService,
                  subscriberGroupEpochReader, tenantID);
              if (list.isEmpty()) {
                generateTokenChange(subscriberID, now, tokenCode, userID, TokenChange.ALLOCATE, "no offers presented", tenantID);
              }
            }

          /*****************************************
           *
           *  decorate and response
           *
           *****************************************/
          response = ThirdPartyJSONGenerator.generateTokenJSONForThirdParty(subscriberStoredToken, journeyService, offerService, scoringStrategyService, presentationStrategyService, offerObjectiveService, loyaltyProgramService, tokenTypeService, tenantID);
          response.put("responseCode", "ok");
        }
    }
    catch (SubscriberProfileServiceException e)
    {
      throw new GUIManagerException(e);
    }
    catch (GetOfferException e) 
    {
      log.error(e.getLocalizedMessage());
      throw new GUIManagerException(e) ;
    }    

    /*****************************************
     *
     * return
     *
     *****************************************/

    return JSONUtilities.encodeObject(response);

  }
  
  /*****************************************
   *
   *  processAcceptOffer
   *
   *****************************************/

  private JSONObject processAcceptOffer(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
  {
    /****************************************
     *
     *  response
     *
     ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();
    Date now = SystemTime.getCurrentTime();

    /****************************************
     *
     *  argument
     *
     ****************************************/
    String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
    String tokenCode = JSONUtilities.decodeString(jsonRoot, "tokenCode", false);
    String offerID = JSONUtilities.decodeString(jsonRoot, "offerID", false);
    String origin = JSONUtilities.decodeString(jsonRoot, "origin", false);

    /*****************************************
     *
     *  resolve subscriberID
     *
     *****************************************/

    String subscriberID = resolveSubscriberID(customerID, tenantID);
    if (subscriberID == null)
      {
        log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
        response.put("responseCode", "CustomerNotFound");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
     *
     *  getSubscriberProfile
     *
     *****************************************/
    String deliveryRequestID = "";

    try
    {
      SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
      if (subscriberProfile == null)
        {
          response.put("responseCode", "CustomerNotFound");
        } 
      else
        {
          Token subscriberToken = null;
          if (tokenCode != null)
            {
              for (Token token : subscriberProfile.getTokens())
                {
                  if (token.getTokenCode().equals(tokenCode))
                    {
                      subscriberToken = token;
                      break;
                    }
                }
            }
          if (subscriberToken == null)
            {
              String str = "No tokens returned";
              log.error(str);
              response.put("responseCode", str);
              generateTokenChange(subscriberID, now, tokenCode, userID, TokenChange.REDEEM, str, tenantID);
              return JSONUtilities.encodeObject(response);
            }

          if (!(subscriberToken instanceof DNBOToken))
            {
              // TODO can this really happen ?
              String str = "Bad token type";
              log.error(str);
              response.put("responseCode", str);
              generateTokenChange(subscriberID, now, tokenCode, userID, TokenChange.REDEEM, str, tenantID);
              return JSONUtilities.encodeObject(response);
            }

          DNBOToken subscriberStoredToken = (DNBOToken) subscriberToken;

          if (subscriberStoredToken.getTokenStatus() == TokenStatus.Redeemed)
            {
              String str = "Token already in Redeemed state";
              log.error(str);
              response.put("responseCode", str);
              generateTokenChange(subscriberID, now, tokenCode, userID, TokenChange.REDEEM, str, tenantID);
              return JSONUtilities.encodeObject(response);
            }

          if (subscriberStoredToken.getTokenStatus() != TokenStatus.Bound)
            {
              String str = "No offers allocated for this token";
              log.error(str);
              response.put("responseCode", str);
              generateTokenChange(subscriberID, now, tokenCode, userID, TokenChange.REDEEM, str, tenantID);
              return JSONUtilities.encodeObject(response);
            }

          // Check that offer has been presented to customer

          List<String> offers = subscriberStoredToken.getPresentedOfferIDs();
          int position = 0;
          boolean found = false;
          for (String offID : offers)
            {
              if (offID.equals(offerID))
                {
                  found = true;
                  break;
                }
              position++;
            }
          if (!found)
            {
              String str = "Offer has not been presented";
              log.error(str);
              response.put("responseCode", str);
              generateTokenChange(subscriberID, now, tokenCode, userID, TokenChange.REDEEM, str, tenantID);
              return JSONUtilities.encodeObject(response);
            }
          String salesChannelID = subscriberStoredToken.getPresentedOffersSalesChannel();
          String userName = JSONUtilities.decodeString(jsonRoot, "userName", false);
          String featureID = (userName != null) ? userName : "administrator"; // for PTT tests, never happens when called by browser
          String moduleID = DeliveryRequest.Module.Customer_Care.getExternalRepresentation();
          String resellerID = "";
          Offer offer = offerService.getActiveOffer(offerID, now);
          deliveryRequestID = purchaseOffer(subscriberProfile,true, subscriberID, offerID, salesChannelID, 1, moduleID, featureID, origin, resellerID, kafkaProducer).getDeliveryRequestID();

          // Redeem the token : Send an AcceptanceLog to EvolutionEngine

          String msisdn = subscriberID; // TODO check this
          String presentationStrategyID = subscriberStoredToken.getPresentationStrategyID();
          String tokenTypeID = subscriberStoredToken.getTokenTypeID();
          
          // TODO BEGIN Following fields are currently not used in EvolutionEngine, might need to be set later
          String callUniqueIdentifier = ""; 
          String controlGroupState = "controlGroupState";
          String channelID = "channelID";
          Integer actionCall = 1;
          int transactionDurationMs = 0;
          // TODO END

          Date fulfilledDate = now;

          AcceptanceLog acceptanceLog = new AcceptanceLog(
              msisdn, subscriberID, now, 
              callUniqueIdentifier, channelID, salesChannelID,
              userID, tokenCode,
              presentationStrategyID, transactionDurationMs,
              controlGroupState, offerID, fulfilledDate, position, actionCall, moduleID, featureID, tokenTypeID);

          //
          //  submit to kafka
          //

          {
            String topic = Deployment.getAcceptanceLogTopic();
            Serializer<StringKey> keySerializer = StringKey.serde().serializer();
            Serializer<AcceptanceLog> valueSerializer = AcceptanceLog.serde().serializer();
            kafkaProducer.send(new ProducerRecord<byte[],byte[]>(
                topic,
                keySerializer.serialize(topic, new StringKey(subscriberID)),
                valueSerializer.serialize(topic, acceptanceLog)
                ));
          }

          //
          // trigger event (for campaigns)
          //

          {
            TokenRedeemed tokenRedeemed = new TokenRedeemed(subscriberID, now, subscriberStoredToken.getTokenTypeID(), offerID);
            String topic = Deployment.getTokenRedeemedTopic();
            Serializer<StringKey> keySerializer = StringKey.serde().serializer();
            Serializer<TokenRedeemed> valueSerializer = TokenRedeemed.serde().serializer();
            kafkaProducer.send(new ProducerRecord<byte[],byte[]>(
                topic,
                keySerializer.serialize(topic, new StringKey(subscriberID)),
                valueSerializer.serialize(topic, tokenRedeemed)
                ));
          }
          response.put("responseCode", "ok");
        }
    }

    catch (GUIManagerException e)
      {
        response.put("responseMessage", e.getMessage());
        response.put("responseCode", e.getResponseParameter());
        return JSONUtilities.encodeObject(response);

      }
    catch (SubscriberProfileServiceException e) 
    {
      throw new GUIManagerException(e);
    } 

    /*****************************************
     *
     *  decorate and response
     *
     *****************************************/
    response.put("deliveryRequestID", deliveryRequestID);
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processPurchaseOffer
  *
  *****************************************/

 private JSONObject processPurchaseOffer(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
 {
   
   boolean sync = true; // always sync today
   /****************************************
   *
   *  response
   *
   ****************************************/

   HashMap<String,Object> response = new HashMap<String,Object>();
   Date now = SystemTime.getCurrentTime();

   String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);

   /*****************************************
    *
    *  resolve subscriberID
    *
    *****************************************/

   String subscriberID = resolveSubscriberID(customerID, tenantID);
   if (subscriberID == null)
     {
       log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
       response.put("responseCode", "CustomerNotFound");
       return JSONUtilities.encodeObject(response);
     }
 
   String offerID = JSONUtilities.decodeString(jsonRoot, "offerID", true);
   String salesChannelID = JSONUtilities.decodeString(jsonRoot, "salesChannelID", true);
   Integer quantity = JSONUtilities.decodeInteger(jsonRoot, "quantity", true);
   String origin = JSONUtilities.decodeString(jsonRoot, "origin", false);

   /*****************************************
    *
    * getSubscriberProfile - no history
    *
    *****************************************/
   PurchaseFulfillmentRequest purchaseResponse=null;

  /*****************************************
   *
   *  getSubscriberProfile
   *
   *****************************************/
  String deliveryRequestID = "";

  try
  {
    SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
    if (subscriberProfile == null)
      {
        response.put("responseCode", "CustomerNotFound");
      } 
    else
      {
        Offer offer = offerService.getActiveOffer(offerID, now);
        if (offer == null)
          {
            String str = "Invalid Offer";
            log.error(str);
            response.put("responseCode", str);
            return JSONUtilities.encodeObject(response);
          }
        SalesChannel salesChannel = salesChannelService.getActiveSalesChannel(salesChannelID, now);
        if (salesChannel == null)
          {
            String str = "Invalid SalesChannel";
            log.error(str);
            response.put("responseCode", str);
            return JSONUtilities.encodeObject(response);
          }

        String userName = JSONUtilities.decodeString(jsonRoot, "userName", false);
        String featureID = (userName != null) ? userName : "administrator"; // for PTT tests, never happens when called by browser
        
        String moduleID = DeliveryRequest.Module.Customer_Care.getExternalRepresentation(); 
        String resellerID = "";
        if(!sync)
          {
            purchaseResponse = purchaseOffer(subscriberProfile,false,subscriberID, offerID, salesChannelID, quantity, moduleID, featureID, origin, resellerID, kafkaProducer);
          }
        else
          {
            purchaseResponse = purchaseOffer(subscriberProfile,true,subscriberID, offerID, salesChannelID, quantity, moduleID, featureID, origin, resellerID, kafkaProducer);
            response.put("offer",purchaseResponse.getGUIPresentationMap(subscriberMessageTemplateService,salesChannelService,journeyService,offerService,loyaltyProgramService,productService,voucherService,deliverableService,paymentMeanService, resellerService, tenantID));
          }
      }
   }

    catch (GUIManagerException e)
      {
        response.put("responseMessage", e.getMessage());
        response.put("responseCode", e.getResponseParameter());
        return JSONUtilities.encodeObject(response);

      }
   catch (SubscriberProfileServiceException e) 
   {
     String str = "unable to process request purchaseOffer " + e.getLocalizedMessage();
     log.error(str);
     response.put("responseCode", str);
     return JSONUtilities.encodeObject(response);
   } 

   /*****************************************
    *
    *  decorate and response
    *
    *****************************************/
   response.put("deliveryRequestID", purchaseResponse.getDeliveryRequestID());
   if(purchaseResponse==null){
     String str = "System error";
     log.error(str);
     response.put("responseCode", str);
     return JSONUtilities.encodeObject(response);
   }else{
     response.put("responseCode", "ok");
   }
   return JSONUtilities.encodeObject(response);
 }

 /*****************************************
 *
 *  processGetOffersList
 *
 *****************************************/

private JSONObject processGetOffersList(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
{

  /****************************************
   *
   *  response
   *
   ****************************************/

  Map<String,Object> response = new HashMap<String,Object>();

  /****************************************
   *
   *  argument
   *
   ****************************************/
  String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);

  /*****************************************
   *
   *  resolve subscriberID
   *
   *****************************************/

  String subscriberID = resolveSubscriberID(customerID, tenantID);
  if (subscriberID == null)
    {
      log.info("unable to resolve SubscriberID for getCustomerAlternateID {} and customerID ", getCustomerAlternateID, customerID);
      response.put("responseCode", "CustomerNotFound");
      return JSONUtilities.encodeObject(response);
    }

  String offerState = JSONUtilities.decodeString(jsonRoot, "state", false);
  String startDateString = JSONUtilities.decodeString(jsonRoot, "startDate", false);
  String endDateString = JSONUtilities.decodeString(jsonRoot, "endDate", false);
  String offerObjective = JSONUtilities.decodeString(jsonRoot, "objective", false);
      
  try
  {
    String timeZone = Deployment.getDeployment(tenantID).getTimeZone();
    Date offerStartDate = prepareStartDate(RLMDateUtils.parseDateFromDay(startDateString, timeZone), timeZone);
    Date offerEndDate = prepareEndDate(RLMDateUtils.parseDateFromDay(endDateString, timeZone), timeZone);
    
    SubscriberProfile subscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
    if (subscriberProfile == null)
      {
        response.put("responseCode", "CustomerNotFound");
      } 
    else if (offerState != null && !offerState.isEmpty() && !offerState.equalsIgnoreCase("ACTIVE"))
      {
        response.put("responseCode", "Bad Field Value " + offerState);
      }
    else
      {
        Collection<Offer> offers = new ArrayList<>();
        if (offerState == null || offerState.isEmpty())
          {
            //
            // retrieve stored offers
            //

            for (GUIManagedObject ofr : offerService.getStoredOffers(tenantID))
              {
                if (ofr instanceof Offer) offers.add( (Offer) ofr);
              }
          }
        else
          {
            //
            // retrieve active offers
            //

            offers = offerService.getActiveOffers(SystemTime.getCurrentTime(), tenantID);
          }

        //
        // filter using subscriberID
        //

        if (subscriberID != null)
          {
            SubscriberEvaluationRequest evaluationRequest = new SubscriberEvaluationRequest(subscriberProfile, subscriberGroupEpochReader, SystemTime.getCurrentTime(), tenantID);
            offers = offers.stream().filter(offer -> offer.evaluateProfileCriteria(evaluationRequest)).collect(Collectors.toList());
          }

        //
        // filter using startDate
        //

        if (offerStartDate != null)
          {
            offers = offers.stream().filter(offer -> (offer.getEffectiveStartDate() == null || offer.getEffectiveStartDate().compareTo(offerStartDate) >= 0)).collect(Collectors.toList()); 
          }

        //
        // filter using endDate
        //

        if (offerEndDate != null)
          {
            offers = offers.stream().filter(campaign -> (campaign.getEffectiveEndDate() == null || campaign.getEffectiveEndDate().compareTo(offerEndDate) <= 0)).collect(Collectors.toList());
          }


        if (offerObjective != null && !offerObjective.isEmpty())
          {

            //
            //  read objective
            //

            Collection<OfferObjective> activeOfferObjectives = offerObjectiveService.getActiveOfferObjectives(SystemTime.getCurrentTime(), tenantID);

            //
            //  filter activejourneyObjective by name
            //

            List<OfferObjective> offerObjectives = activeOfferObjectives.stream().filter(offerObj -> offerObj.getOfferObjectiveDisplay().equals(offerObjective)).collect(Collectors.toList());
            OfferObjective exactOfferObjectives = offerObjectives.size() > 0 ? offerObjectives.get(0) : null;

            //
            //  filter
            //

            if (exactOfferObjectives == null)
              offers = new ArrayList<Offer>();
            else
              offers = offers.stream().filter(offer -> (offer.getOfferObjectives() != null && (offer.getOfferObjectives().stream().filter(obj -> obj.getOfferObjectiveID().equals(exactOfferObjectives.getOfferObjectiveID())).count() > 0L))).collect(Collectors.toList());

          }

        /*****************************************
         *
         *  decorate offers response
         *
         *****************************************/

        List<JSONObject> offersJson = offers.stream().map(offer -> ThirdPartyJSONGenerator.generateOfferJSONForThirdParty(offer, offerService, offerObjectiveService, productService, voucherService, salesChannelService, catalogCharacteristicService
            )).collect(Collectors.toList());
        response.put("offers", JSONUtilities.encodeArray(offersJson));
        response.put("responseCode", "ok");
      }
  }
  catch(SubscriberProfileServiceException | java.text.ParseException spe)
  {
    String str = "unable to process request getOffersList " + spe.getLocalizedMessage();
    log.error(str);
    response.put("responseCode", str);
    return JSONUtilities.encodeObject(response);
  }
  return JSONUtilities.encodeObject(response);
}

  /*****************************************
  *
  *  processGetTokenEventDetails
  *
  *****************************************/

 private JSONObject processGetTokenEventDetails(String userID, JSONObject jsonRoot, int tenantID) throws GUIManagerException
 {
   /****************************************
    *
    *  response
    *
    ****************************************/

   HashMap<String,Object> response = new HashMap<String,Object>();
   Date now = SystemTime.getCurrentTime();

   /****************************************
    *
    *  argument
    *
    ****************************************/
   String customerID = JSONUtilities.decodeString(jsonRoot, "customerID", true);
   String tokenCode  = JSONUtilities.decodeString(jsonRoot, "tokenCode",  true);
   List<Object> res = new ArrayList<>();
   try
   {
     // (subscriberID:"106") AND (tokenCode:"YCWXT")
     String queryString = "("+TokenChangeESSinkConnector.TokenChangeESSinkTask.ES_FIELD_SUBSCRIBER_ID+":\""+customerID+"\") AND ("+TokenChangeESSinkConnector.TokenChangeESSinkTask.ES_FIELD_TOKEN_CODE+":\""+tokenCode+"\")";
     QueryBuilder query = QueryBuilders.queryStringQuery(queryString);
     SearchRequest searchRequest = new SearchRequest("detailedrecords_tokens-*").source(new SearchSourceBuilder().query(query)); 
     Scroll scroll = new Scroll(TimeValue.timeValueSeconds(10L));
     searchRequest.scroll(scroll);
     searchRequest.source().size(1000);
     SearchResponse searchResponse = elasticsearch.search(searchRequest, RequestOptions.DEFAULT);
     String scrollId = searchResponse.getScrollId(); // always null
     SearchHit[] searchHits = searchResponse.getHits().getHits();
     while (searchHits != null && searchHits.length > 0)
       {
         for (SearchHit searchHit : searchHits)
           {
             Map<String, Object> map = searchHit.getSourceAsMap();
             map.remove("subscriberID");
             map.remove("tokenCode");
             res.add(JSONUtilities.encodeObject(map));
           }
         SearchScrollRequest scrollRequest = new SearchScrollRequest(scrollId); 
         scrollRequest.scroll(scroll);
         searchResponse = elasticsearch.searchScroll(scrollRequest, RequestOptions.DEFAULT);
         scrollId = searchResponse.getScrollId();
         searchHits = searchResponse.getHits().getHits();
       }
   }
   catch (IOException e)
     {
       String str = "Error when searching ElasticSearch";
       log.error(str);
       response.put("responseCode", str);
       response.put("responseMessage", e.getMessage());
       response.put("responseParameter", null);
       return JSONUtilities.encodeObject(response);
     }
   response.put("customerID", customerID);
   response.put("tokenCode", tokenCode);
   response.put("events", JSONUtilities.encodeArray(res));
   response.put("responseCode", "ok");
   
   /*****************************************
    *
    *  decorate and response
    *
    *****************************************/
   return JSONUtilities.encodeObject(response);
 }
 
  /*****************************************
   *
   * processGetSourceAddressList
   *
   *****************************************/

  private JSONObject processGetSourceAddressList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID) throws GUIManagerException
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    List<JSONObject> sourceAddresses = new ArrayList<JSONObject>(); 
    HashMap<String,Object> response = new HashMap<String,Object>();
    Collection <GUIManagedObject> sourceAddressObjects = new ArrayList<GUIManagedObject>();
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray sourceAddressIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < sourceAddressIDs.size(); i++)
          {
            String sourceAddressID = sourceAddressIDs.get(i).toString();
            GUIManagedObject sourceAddress = sourceAddressService.getStoredSourceAddress(sourceAddressID, includeArchived);
            if (sourceAddress != null && sourceAddress.getTenantID() == tenantID)
              {
                sourceAddressObjects.add(sourceAddress);
              }
          }
      }
    else
      {
        sourceAddressObjects = sourceAddressService.getStoredSourceAddresses(includeArchived, tenantID);
      }
    
    /*****************************************
    *
    *  retrieve
    *
    *****************************************/
    Date now = SystemTime.getCurrentTime();
    
    for (GUIManagedObject sourceAddress : sourceAddressObjects)
      {
        JSONObject sourceAddressJSON = sourceAddressService.generateResponseJSON(sourceAddress, fullDetails, now); 
        sourceAddresses.add(sourceAddressJSON);
      }

    /*****************************************
    *
    * decorate and response
    *
    *****************************************/
    
    response.put("responseCode", "ok" );    
    response.put("sourceAddresses", JSONUtilities.encodeArray(sourceAddresses));  
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processGetSourceAddress
  *
  *****************************************/

  private JSONObject processGetSourceAddress(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String sourceAddressID = JSONUtilities.decodeString(jsonRoot, "id", true);

    /*****************************************
    *
    *  retrieve and decorate scoring strategy
    *
    *****************************************/

    GUIManagedObject sourceAddress = sourceAddressService.getStoredSourceAddress(sourceAddressID, includeArchived);
    JSONObject sourceAddressJSON = sourceAddressService.generateResponseJSON(sourceAddress, true, SystemTime.getCurrentTime());

    /*****************************************
    *
    *  response
    *
    *****************************************/

    response.put("responseCode", (sourceAddress != null) ? "ok" : "sourceAddressNotFound");
    if (sourceAddress != null) response.put("sourceAddress", sourceAddressJSON);
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processPutSourceAddress
  *
  *****************************************/

  private JSONObject processPutSourceAddress(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String,Object> response = new HashMap<String,Object>();
    Boolean dryRun = false;
    

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    /*****************************************
    *
    *  sourceAddressID
    *
    *****************************************/

    String sourceAddressID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (sourceAddressID == null)
      {
        sourceAddressID = sourceAddressService.generateSourceAddressID();
        jsonRoot.put("id", sourceAddressID);
      }

    /*****************************************
    *
    *  existing sourceAddress
    *
    *****************************************/

    GUIManagedObject existingSourceAddress = sourceAddressService.getStoredSourceAddress(sourceAddressID);

    /*****************************************
    *
    *  read-only
    *
    *****************************************/

    if (existingSourceAddress != null && existingSourceAddress.getReadOnly())
      {
        response.put("id", existingSourceAddress.getGUIManagedObjectID());
        response.put("accepted", existingSourceAddress.getAccepted());
        response.put("valid", existingSourceAddress.getAccepted());
        response.put("processing", sourceAddressService.isActiveSourceAddress(existingSourceAddress, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
    *
    *  process sourceAddress
    *
    *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        //
        //  isDefault
        //
        
        boolean isDefault = JSONUtilities.decodeBoolean(jsonRoot, "default", Boolean.FALSE);
        if (!isDefault) jsonRoot.put("default", isDefault);
        
        /****************************************
        *
        *  instantiate sourceAddress
        *
        ****************************************/
        
        SourceAddress sourceAddress = new SourceAddress(jsonRoot, epoch, existingSourceAddress, tenantID);
        
        /*****************************************
        *
        *  store
        *
        *****************************************/
        if (!dryRun)
          {

            sourceAddressService.putSourceAddress(sourceAddress, (existingSourceAddress == null), userID);
          }
        /*****************************************
        *
        *  response
        *
        *****************************************/

        response.put("id", sourceAddress.getSourceAddressId());
        response.put("accepted", sourceAddress.getAccepted());
        response.put("valid", sourceAddress.getAccepted());
        response.put("processing", sourceAddressService.isActiveSourceAddress(sourceAddress, now));
        response.put("responseCode", "ok");
        return JSONUtilities.encodeObject(response);
      }
    catch (JSONUtilitiesException|GUIManagerException e)
      {
        //
        //  incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        //  store
        //
        if (!dryRun)
          {
            sourceAddressService.putSourceAddress(incompleteObject, (existingSourceAddress == null), userID);
          }
        //
        //  log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        //  response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "sourceAddressNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter", (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }
  
  /*****************************************
  *
  *  processRemoveSourceAddress
  *
  *****************************************/

  private JSONObject processRemoveSourceAddress(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /*****************************************
    *
    *  now
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();

    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> sourceAddresses = new ArrayList<>();
    JSONArray sourceAddressIDs = new JSONArray();
    List<String> validIDs = new ArrayList<>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    //
    //remove single sourceAddress
    //
    if (jsonRoot.containsKey("id"))
      {
        String sourceAddressID = JSONUtilities.decodeString(jsonRoot, "id", false);
        sourceAddressIDs.add(sourceAddressID);
        GUIManagedObject sourceAddress = sourceAddressService.getStoredSourceAddress(sourceAddressID);
        if (sourceAddress != null && (force || !sourceAddress.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (sourceAddress != null)
          singleIDresponseCode = "failedReadOnly";
        else singleIDresponseCode = "sourceAddressNotFound";
      }
    //
    // multiple deletion
    //
    
    if (jsonRoot.containsKey("ids"))
      {
        sourceAddressIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }
   
    for (int i = 0; i < sourceAddressIDs.size(); i++)
      {
        String sourceAddressID = sourceAddressIDs.get(i).toString();
        GUIManagedObject sourceAddress = sourceAddressService.getStoredSourceAddress(sourceAddressID);
        
        if (sourceAddress != null && (force || !sourceAddress.getReadOnly()))
          {
            sourceAddresses.add(sourceAddress);
            validIDs.add(sourceAddressID);
          }
      }
        
  

    /*****************************************
    *
    *  remove
    *
    *****************************************/
    for (int i = 0; i < sourceAddresses.size(); i++)
      {

        GUIManagedObject sourceAddress = sourceAddresses.get(i);

        sourceAddressService.removeSourceAddress(sourceAddress.getGUIManagedObjectID(), userID, tenantID);
      }
    
    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }
    /*****************************************
     *
     * response
     *
     *****************************************/

    response.put("removedSourceAddressIDS", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
   *
   * processSetStatusSourceAddress
   *
   *****************************************/

  private JSONObject processSetStatusSourceAddress(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();
    JSONArray sourceAddressIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
    List<String> statusSetIDs = new ArrayList<>();
    Boolean status = JSONUtilities.decodeBoolean(jsonRoot, "active");
    long epoch = epochServer.getKey();

    for (int i = 0; i < sourceAddressIDs.size(); i++)
      {

        String sourceAddressID = sourceAddressIDs.get(i).toString();
        GUIManagedObject existingElement = sourceAddressService.getStoredSourceAddress(sourceAddressID);
        if (existingElement != null && !(existingElement.getReadOnly()))
          {
            statusSetIDs.add(sourceAddressID);
            JSONObject elementRoot = (JSONObject) existingElement.getJSONRepresentation().clone();
            elementRoot.put("active", status);
            try
              {
                //
                // isDefault
                //

                /****************************************
                 *
                 * instantiate sourceAddress
                 *
                 ****************************************/

                SourceAddress sourceAddress = new SourceAddress(elementRoot, epoch, existingElement, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/
                sourceAddressService.putSourceAddress(sourceAddress, (existingElement == null), userID);

              }
            catch (JSONUtilitiesException | GUIManagerException e)
              {
                //
                // incompleteObject
                //

                IncompleteObject incompleteObject = new IncompleteObject(elementRoot, epoch, tenantID);

                //
                // store
                //

                sourceAddressService.putSourceAddress(incompleteObject, (existingElement == null), userID);

                //
                // log
                //

                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                if (log.isWarnEnabled())
                  {
                    log.warn("Exception processing REST api: {}", stackTraceWriter.toString());
                  }

              }
          }
      }
    response.put("responseCode", "ok");
    response.put("statusSetIds", statusSetIDs);
    return JSONUtilities.encodeObject(response);
  }  
    
  /*****************************************
  *
  *  processPutSimpleOfferThirdParty
  *
  *****************************************/
  
  private JSONObject processPutSimpleOfferThirdParty(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>(); 
    String user = JSONUtilities.decodeString(jsonRoot, "loginID", false);
   
    String activeSupplier = activeSupplierAndParentSupplierIDs(user, tenantID).get("activeSupplierID");
    boolean offerCanBeModified = true;
    String existingproductID = null;
    String existingVoucherID = null;
    String existingSupplierID = null;
    
    /*****************************************
     *
     * offerID
     *
     *****************************************/

    String offerID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (offerID == null)
      {
        offerID = offerService.generateOfferID();
        jsonRoot.put("id", offerID);
      }

    /*****************************************
     *
     * existing offer
     *
     *****************************************/

    GUIManagedObject existingOffer = offerService.getStoredOffer(offerID);
    
    
    /**********************************************************************************************
     * 
     * The existing product or voucher ID
     * 
     * 
     **********************************************************************************************/
    if (existingOffer != null)
      {
        if (existingOffer instanceof Offer)
          {
            Map<String, Object> OfferProductVoucherAndSupplierIDs = OfferProductVoucherAndSupplierIDs(
                (Offer) existingOffer, tenantID);
            existingSupplierID = (String) OfferProductVoucherAndSupplierIDs.get("supplierID");
            OfferProduct product = (OfferProduct) OfferProductVoucherAndSupplierIDs.get("offerProduct");
            OfferVoucher voucher = (OfferVoucher) OfferProductVoucherAndSupplierIDs.get("offerVoucher");
            if (product != null)
              {
                existingproductID = product.getProductID();
              }
            if (voucher != null)
              {
                existingVoucherID = voucher.getVoucherID();
              }
          }
      }
    

    /*****************************************
     *
     * read-only
     *
     *****************************************/

    if (existingOffer != null  && existingOffer.getReadOnly()) 
      {
        response.put("id", existingOffer.getGUIManagedObjectID());
        response.put("accepted", existingOffer.getAccepted());
        response.put("valid", existingOffer.getAccepted());
        response.put("processing", offerService.isActiveOffer(existingOffer, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }
    
    if (existingOffer != null && !(activeSupplier.equals(existingSupplierID)))
      {
        if (existingOffer instanceof Offer) {

        response.put("responseCode", RESTAPIGenericReturnCodes.OFFER_SUPPLIER_MISMATCH.getGenericResponseCode());
        response.put("responseMessage",
            RESTAPIGenericReturnCodes.OFFER_SUPPLIER_MISMATCH.getGenericResponseMessage());
        return JSONUtilities.encodeObject(response);
        }

      }

    /*****************************************
     *
     * process offer
     *
     *****************************************/

    long epoch = epochServer.getKey();
    try
      {
        /*********************************************
         * store offer for active supplier
         * 
         * 
         **********************************************/

        if (activeSupplier != null && activeSupplier.equals("InactiveReseller"))
          {

            response.put("responseCode", RESTAPIGenericReturnCodes.INACTIVE_SUPPLIER.getGenericResponseCode());
            response.put("responseMessage", RESTAPIGenericReturnCodes.INACTIVE_SUPPLIER.getGenericResponseMessage());
            return JSONUtilities.encodeObject(response);
          }

        else if (activeSupplier != null && activeSupplier != "InactiveReseller")
          {

            JSONArray productJSONArray = JSONUtilities.decodeJSONArray(jsonRoot, "products", false); // to separate the products from the input json
            JSONArray voucherJSONArray = JSONUtilities.decodeJSONArray(jsonRoot, "vouchers", false); // to separate the voucher from the input json
            
            Map<String, JSONObject> OfferProductAndVoucher = splitOfferProductAndVoucher(productJSONArray, voucherJSONArray,
                jsonRoot, existingproductID, existingVoucherID, tenantID);
            
            JSONObject productJSON = OfferProductAndVoucher.get("productJSON"); // JSONObject to create a new product with offer name
            JSONObject voucherJSON = OfferProductAndVoucher.get("voucherJSON"); // JSONObject to create a new voucher with offer name

            JSONObject productsJSONObject = (JSONObject) (OfferProductAndVoucher.get("productJSONObject")); // to get the product quantity                                                                                                            
            JSONObject vouchersJSONObject = (JSONObject) (OfferProductAndVoucher.get("voucherJSONObject")); // to get the voucher quantity                                                                                                          

            JSONObject result = new JSONObject();

            /***********************************
             * 
             * create Offer with product *
             * 
             ********************************/

            if (productJSON != null && !(productJSON.isEmpty()))
              {
                /*****************************************
                *
                *  existing product
                *
                *****************************************/


                GUIManagedObject existingVoucher = null;
                GUIManagedObject existingProduct = null;

                if (existingVoucherID != null)
                  {
                    existingVoucher = voucherService.getStoredVoucher(existingVoucherID);
                  }
                if (existingproductID != null)
                  {
                    existingProduct = productService.getStoredProduct(existingproductID);
                  }

                if (existingVoucher != null)
                  {
                    voucherService.removeVoucher(existingVoucherID, userID, uploadedFileService, tenantID);
                  }
                

                Product product = new Product(productJSON, epoch, existingProduct, deliverableService,
                    catalogCharacteristicService, tenantID);
                /*****************************************
                 *
                 * store product
                 *
                 *****************************************/

                productService.putProduct(product, supplierService, productTypeService, deliverableService, (existingProduct == null),
                    userID);
                
                
                /************************************************
                 * 
                 * store offer with the new product embedded
                 * 
                 ***********************************************/
                JSONObject newProductJSONObject = new JSONObject();
                newProductJSONObject.put("quantity", productsJSONObject.get("quantity"));              
                newProductJSONObject.put("productID", productJSON.get("id"));
                JSONArray newProductJSONArray = new JSONArray();
                newProductJSONArray.add(newProductJSONObject);                
                jsonRoot.replace("products", newProductJSONArray);
                jsonRoot.put("simpleOffer", true);

                Offer productOffer = new Offer(jsonRoot, epoch, existingOffer, catalogCharacteristicService, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/

                offerService.putOffer(productOffer, callingChannelService, salesChannelService, productService,
                    voucherService, (existingOffer == null), userID);

                /*****************************************
                 *
                 * response
                 *
                 *****************************************/

                response.put("id", productOffer.getOfferID());
                response.put("accepted", productOffer.getAccepted());
                response.put("valid", productOffer.getAccepted());
                response.put("processing", offerService.isActiveOffer(productOffer, now));
                response.put("responseCode", "ok");
              }
            

            /*******************************
             * 
             * create Offer with voucher
             * 
             * 
             ******************************/

            if (voucherJSON != null && !(voucherJSON.isEmpty()))
              {
                /*****************************************
                 *
                 * existing voucher
                 *
                 *****************************************/

                GUIManagedObject existingVoucher = null;
                GUIManagedObject existingProduct = null;

                if (existingVoucherID != null)
                  {
                    existingVoucher = voucherService.getStoredVoucher(existingVoucherID);
                  }
                if (existingproductID != null)
                  {
                    existingProduct = productService.getStoredProduct(existingproductID);
                  }
                if (existingProduct != null) {
                  productService.removeProduct(existingproductID, userID, tenantID);
                }

                /**
                 * ********************************
                 * 
                 * create a voucher with offer name
                 * 
                 * 
                 **************************************/

                VoucherType voucherType = voucherTypeService
                    .getActiveVoucherType(JSONUtilities.decodeString(voucherJSON, "voucherTypeId", true), now);
                if (log.isDebugEnabled())
                  log.debug("will use voucherType " + voucherType);

                // voucherType issue
                if (voucherType == null || voucherType.getCodeType() == VoucherType.CodeType.Unknown)
                  {
                    response.put("responseCode", "voucherTypeNotFound");
                    return JSONUtilities.encodeObject(response);
                  }

                Voucher voucher = null;
                if (voucherType.getCodeType() == VoucherType.CodeType.Shared)
                  {
                    voucher = new VoucherShared(voucherJSON, epoch, existingVoucher, tenantID);
                    if (log.isDebugEnabled())
                      log.debug("will put shared voucher " + voucher);
                  }
                if (voucher == null && voucherType.getCodeType() == VoucherType.CodeType.Personal)
                  {
                    voucher = new VoucherPersonal(voucherJSON, epoch, existingVoucher, voucherType, tenantID);
                    if (log.isDebugEnabled())
                      log.debug("will put personal voucher " + voucher);
                  }

                voucher.validate(voucherTypeService, uploadedFileService, now);

                /**
                 * **********************
                 * 
                 * store voucher
                 * 
                 **********************/
                voucherService.putVoucher(voucher, (existingVoucher == null), userID);

                /************************************************
                 * 
                 * store offer with the new voucher embedded
                 * 
                 ***********************************************/

                JSONObject newVoucherJSONObject = new JSONObject();
                newVoucherJSONObject.put("quantity", vouchersJSONObject.get("quantity"));
                newVoucherJSONObject.put("voucherID", voucherJSON.get("id"));
                JSONArray newVoucherJSONArray = new JSONArray();
                newVoucherJSONArray.add(newVoucherJSONObject);
                jsonRoot.replace("vouchers", newVoucherJSONArray);
                jsonRoot.put("simpleOffer", true);

                Offer voucherOffer = new Offer(jsonRoot, epoch, existingOffer, catalogCharacteristicService, tenantID);

                /*****************************************
                 *
                 * store
                 *
                 *****************************************/

                offerService.putOffer(voucherOffer, callingChannelService, salesChannelService, productService,
                    voucherService, (existingOffer == null), userID);

                /*****************************************
                 *
                 * response
                 *
                 *****************************************/

                response.put("id", voucherOffer.getOfferID());
                response.put("accepted", voucherOffer.getAccepted());
                response.put("valid", voucherOffer.getAccepted());
                response.put("processing", offerService.isActiveOffer(voucherOffer, now));
                response.put("responseCode", "ok");

              }

            return JSONUtilities.encodeObject(response);

          }

        else
          {
            response.put("responseCode", RESTAPIGenericReturnCodes.USER_NOT_SUPPLIER.getGenericResponseCode());
            response.put("responseMessage", RESTAPIGenericReturnCodes.USER_NOT_SUPPLIER.getGenericResponseMessage());
            return JSONUtilities.encodeObject(response);
          }
      }
    catch (JSONUtilitiesException | GUIManagerException e)
      {
        //
        // incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);

        //
        // store
        //

        offerService.putOffer(incompleteObject, callingChannelService, salesChannelService, productService,
            voucherService, (existingOffer == null), userID);

        //
        // log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        // response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "offerNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter",
            (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }


  /*****************************************
  *
  *  processGetSimpleOfferListThirdParty
  *
  *****************************************/
  private JSONObject processGetSimpleOfferListThirdParty(String userID, JSONObject jsonRoot, int tenantID)
  {

    /****************************************
     *
     * response
     *
     ****************************************/

    Map<String, Object> response = new HashMap<String, Object>();
    List<Offer> offers = new ArrayList<>();
    List<OfferProduct> products = new ArrayList<>();
    List<OfferVoucher> vouchers = new ArrayList<>();
    String user = JSONUtilities.decodeString(jsonRoot, "loginID", false);
    Date now = SystemTime.getCurrentTime();
    String activeSupplier = activeSupplierAndParentSupplierIDs(user, tenantID).get("activeSupplierID");
 

    if (activeSupplier != null && activeSupplier.equals("InactiveReseller"))
      {

        response.put("responseCode", RESTAPIGenericReturnCodes.INACTIVE_SUPPLIER.getGenericResponseCode());
        response.put("responseMessage", RESTAPIGenericReturnCodes.INACTIVE_SUPPLIER.getGenericResponseMessage());
        return JSONUtilities.encodeObject(response);
      }

    else if (activeSupplier != null && activeSupplier != "InactiveReseller")
      {
        for (GUIManagedObject offerObject : offerService.getStoredOffers(tenantID))
          {
            if (offerObject instanceof Offer)
              {
                Map<String, Object> OfferProductVoucherAndSupplierIDs = OfferProductVoucherAndSupplierIDs(
                    (Offer) offerObject, tenantID);
                String supplierID = (String) OfferProductVoucherAndSupplierIDs.get("supplierID");
                OfferProduct product = (OfferProduct) OfferProductVoucherAndSupplierIDs.get("offerProduct");
                OfferVoucher voucher = (OfferVoucher) OfferProductVoucherAndSupplierIDs.get("offerVoucher");                
                
                Offer offer = (Offer) offerObject;
                String offerName = offer.getGUIManagedObjectName();                               
                if (product != null)
                  {
                    String productID = product.getProductID();
                    String productName = (productService.getStoredProduct(productID)).getGUIManagedObjectName();

                    if (activeSupplier.equals(supplierID) && offerName.equals(productName) && offer.getSimpleOffer())
                      {
                        // products.add(product);
                        offers.add(offer);
                      }
                    else if (offerName.equals(productName) && offer.getSimpleOffer() && !(activeSupplier.equals(supplierID)))
                      {

                        if (log.isDebugEnabled())
                          log.debug(offer + "- supplier mismatch");

                      }
                    else
                      {
                        if (log.isDebugEnabled())
                          log.debug(offer + " is not supplierOffer");
                      }
                  }
                if (voucher != null)
                  {
                    String voucherID = voucher.getVoucherID();
                    String voucherName = (voucherService.getStoredVoucher(voucherID)).getGUIManagedObjectName();

                    if (activeSupplier.equals(supplierID) && offerName.equals(voucherName) && offer.getSimpleOffer())
                      {
                        vouchers.add(voucher);
                        offers.add(offer);
                      }
                    else if (offerName.equals(voucherName) && offer.getSimpleOffer() && !(activeSupplier.equals(supplierID)))
                      {

                        if (log.isDebugEnabled())
                          log.debug(offer + "- supplier mismatch");

                      }
                    else
                      {
                        if (log.isDebugEnabled())
                          log.debug(offer + " is not supplierOffer");
                      }

                  }

              }
          }

        /*****************************************
         *
         * decorate offers response
         *
         *****************************************/

        List<JSONObject> offersJson = offers.stream()
            .map(offer -> ThirdPartyJSONGenerator.generateOfferJSONForThirdParty(offer, offerService,
                offerObjectiveService, productService, voucherService, salesChannelService, catalogCharacteristicService))
            .collect(Collectors.toList());

        response.put("simpleOffers", JSONUtilities.encodeArray(offersJson));
        response.put("responseCode", RESTAPIGenericReturnCodes.SUCCESS.getGenericResponseCode());
        response.put("responseMessage", RESTAPIGenericReturnCodes.SUCCESS.getGenericResponseMessage());

      }

    else
      {
        response.put("responseCode", RESTAPIGenericReturnCodes.USER_NOT_SUPPLIER.getGenericResponseCode());
        response.put("responseMessage", RESTAPIGenericReturnCodes.USER_NOT_SUPPLIER.getGenericResponseMessage());
        return JSONUtilities.encodeObject(response);

      }

    return JSONUtilities.encodeObject(response);
  }

  /*****************************************
  *
  *  processRemoveSimpleOfferThirdParty
  *
  *****************************************/

  private JSONObject processRemoveSimpleOfferThirdParty(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    HashMap<String, Object> response = new HashMap<String, Object>();

    /****************************************
     *
     * argument
     *
     ****************************************/

    String offerID = JSONUtilities.decodeString(jsonRoot, "id", false);
    String offerDisplay = JSONUtilities.decodeString(jsonRoot, "offerName", false);
    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    String user = JSONUtilities.decodeString(jsonRoot, "loginID", false);
    String activeSupplier = activeSupplierAndParentSupplierIDs(user, tenantID).get("activeSupplierID");
    Date now = SystemTime.getCurrentTime();
    Offer offer = null;

    /*****************************************
     *
     * remove
     *
     *****************************************/
    if (jsonRoot.containsKey("id") && offerID != null)
      {
        GUIManagedObject offerObject = offerService.getStoredOffer(offerID);
        offer = (Offer) offerObject;
      }
    else if (jsonRoot.containsKey("offerName") && offerDisplay != null)
      {
        Collection<GUIManagedObject> offers = offerService.getStoredOffers(tenantID);
        for (GUIManagedObject offerObject : offers)
          {
            Offer currentOffer = (Offer) offerObject;
            if (currentOffer.getGUIManagedObjectDisplay().equals(offerDisplay))
              {
                offer = currentOffer;
                break;
              }
          }
      }
    else
      {
        response.put("responseCode", RESTAPIGenericReturnCodes.MISSING_PARAMETERS.getGenericResponseCode());
        response.put("responseMessage", RESTAPIGenericReturnCodes.MISSING_PARAMETERS.getGenericResponseMessage());
        return JSONUtilities.encodeObject(response);
      }
    
    String responseCode = null;

    if (offer != null)
      {
        if (activeSupplier != null && activeSupplier.equals("InactiveReseller"))
          {

            response.put("responseCode", RESTAPIGenericReturnCodes.INACTIVE_SUPPLIER.getGenericResponseCode());
            response.put("responseMessage", RESTAPIGenericReturnCodes.INACTIVE_SUPPLIER.getGenericResponseMessage());
            return JSONUtilities.encodeObject(response);
          }

        else if (activeSupplier != null && activeSupplier != "InactiveReseller")
          {
            String offerName = offer.getGUIManagedObjectName();
            Map<String, Object> OfferProductVoucherAndSupplierIDs = OfferProductVoucherAndSupplierIDs(offer, tenantID);
            String supplierID = (String) OfferProductVoucherAndSupplierIDs.get("supplierID");
            OfferProduct product = (OfferProduct) OfferProductVoucherAndSupplierIDs.get("offerProduct");
            OfferVoucher voucher = (OfferVoucher) OfferProductVoucherAndSupplierIDs.get("offerVoucher");                   
            
            if (product != null)
              {
                String productID = product.getProductID();
                String productName = (productService.getStoredProduct(productID)).getGUIManagedObjectName();
                if (activeSupplier.equals(supplierID) && offerName.equals(productName) && offer.getSimpleOffer() )
                  {
                    String productId = product.getProductID();
                    productService.removeProduct(productId, userID, tenantID);
                    offerService.removeOffer(offer.getOfferID(), userID, tenantID);

                    responseCode = "ok";

                    response.put("responseCode", responseCode);
                  }

                else if (offerName.equals(productName) && offer.getSimpleOffer() && !(activeSupplier.equals(supplierID)))

                  {

                    response.put("responseCode",
                        RESTAPIGenericReturnCodes.OFFER_SUPPLIER_MISMATCH.getGenericResponseCode());
                    response.put("responseMessage",
                        RESTAPIGenericReturnCodes.OFFER_SUPPLIER_MISMATCH.getGenericResponseMessage());
                    return JSONUtilities.encodeObject(response);

                  }
                else
                  {
                    response.put("responseCode", RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseCode());
                    response.put("responseMessage", RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseMessage());
                    return JSONUtilities.encodeObject(response);
                  }
              }
            if (voucher != null)
              {
                String voucherID = voucher.getVoucherID();
                String voucherName = (voucherService.getStoredVoucher(voucherID)).getGUIManagedObjectName();

                if (activeSupplier.equals(supplierID) && offerName.equals(voucherName) && offer.getSimpleOffer())
                  {
                    String voucherId = voucher.getVoucherID();
                    voucherService.removeVoucher(voucherId, userID, uploadedFileService, tenantID);
                    offerService.removeOffer(offer.getOfferID(), userID, tenantID);

                    responseCode = "ok";

                    response.put("responseCode", responseCode);
                  }

                else if (offerName.equals(voucherName) && offer.getSimpleOffer() && !(activeSupplier.equals(supplierID)))

                  {

                    response.put("responseCode",
                        RESTAPIGenericReturnCodes.OFFER_SUPPLIER_MISMATCH.getGenericResponseCode());
                    response.put("responseMessage",
                        RESTAPIGenericReturnCodes.OFFER_SUPPLIER_MISMATCH.getGenericResponseMessage());
                    return JSONUtilities.encodeObject(response);

                  }
                else
                  {
                    if (log.isInfoEnabled())
                    log.info("offer is not supplierOffer");
                    response.put("responseCode", RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseCode());
                    response.put("responseMessage", RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseMessage());
                    return JSONUtilities.encodeObject(response);
                  }
              }         

          }
        else
          {
            response.put("responseCode", RESTAPIGenericReturnCodes.USER_NOT_SUPPLIER.getGenericResponseCode());
            response.put("responseMessage", RESTAPIGenericReturnCodes.USER_NOT_SUPPLIER.getGenericResponseMessage());
            return JSONUtilities.encodeObject(response);
          }

      }
    else
      {
        responseCode = "offerNotFound";
        response.put("responseCode", responseCode);
      }

    /*****************************************
     *
     * response
     *
     *****************************************/

    return JSONUtilities.encodeObject(response);

  }
  
  private static final Class<?> PURCHASE_FULFILLMENT_REQUEST_CLASS = com.evolving.nglm.evolution.PurchaseFulfillmentManager.PurchaseFulfillmentRequest.class;

  /*****************************************
   *
   *  purchaseOffer
   *
   *****************************************/
  
  private PurchaseFulfillmentRequest purchaseOffer(SubscriberProfile subscriberProfile, boolean sync, String subscriberID, String offerID, String salesChannelID, int quantity, String moduleID, String featureID, String origin, String resellerID, KafkaProducer<byte[],byte[]> kafkaProducer) throws GUIManagerException
  {
    DeliveryManagerDeclaration deliveryManagerDeclaration = null;
    for (DeliveryManagerDeclaration dmd : Deployment.getDeliveryManagers().values())
      {
        String className = dmd.getRequestClassName();
        try
        {
          if (PURCHASE_FULFILLMENT_REQUEST_CLASS.isAssignableFrom(Class.forName(className)))
            {
              deliveryManagerDeclaration = dmd;
              // TODO : if we have multiple delivery managers of the right class, we should not always take the first one (for load balancing)
              break;
            }
        }
        catch (ClassNotFoundException e) {
          log.warn("DeliveryManager with wrong classname, skip it : "+className);
        }
      }
    if (deliveryManagerDeclaration == null)
      {
        String str = "Internal error, cannot find a deliveryManager with a RequestClassName as com.evolving.nglm.evolution.PurchaseFulfillmentManager.PurchaseFulfillmentRequest"; 
        log.error(str);
        throw new GUIManagerException("Internal error", str);
      }

    Serializer<StringKey> keySerializer = StringKey.serde().serializer();
    Serializer<PurchaseFulfillmentRequest> valueSerializer = ((ConnectSerde<PurchaseFulfillmentRequest>) deliveryManagerDeclaration.getRequestSerde()).serializer();
    
    String deliveryRequestID = zuks.getStringKey();
    // Build a json doc to create the PurchaseFulfillmentRequest
    HashMap<String,Object> request = new HashMap<String,Object>();
    request.put("subscriberID", subscriberID);
    request.put("offerID", offerID);
    request.put("quantity", quantity);
    request.put("salesChannelID", salesChannelID); 
    request.put("deliveryRequestID", deliveryRequestID);
    request.put("eventID", "event from " + Module.fromExternalRepresentation(moduleID).toString()); // No event here
    request.put("moduleID", moduleID);
    request.put("featureID", featureID);
    request.put("origin", origin);
    request.put("resellerID", resellerID);
    request.put("deliveryType", deliveryManagerDeclaration.getDeliveryType());
    JSONObject valueRes = JSONUtilities.encodeObject(request);
    
    PurchaseFulfillmentRequest purchaseRequest = new PurchaseFulfillmentRequest(subscriberProfile,subscriberGroupEpochReader,valueRes, deliveryManagerDeclaration, offerService, paymentMeanService, resellerService, productService, supplierService, voucherService, SystemTime.getCurrentTime(), subscriberProfile.getTenantID());
    purchaseRequest.forceDeliveryPriority(DELIVERY_REQUEST_PRIORITY);
    String topic = deliveryManagerDeclaration.getRequestTopic(purchaseRequest.getDeliveryPriority());

    Future<PurchaseFulfillmentRequest> waitingResponse=null;
    if(sync){
      waitingResponse = purchaseResponseListenerService.addWithOnValueFilter(purchaseResponse->!purchaseResponse.isPending()&&purchaseResponse.getDeliveryRequestID().equals(deliveryRequestID));
    }

    kafkaProducer.send(new ProducerRecord<byte[],byte[]>(
        topic,
        keySerializer.serialize(topic, new StringKey(deliveryRequestID)),
        valueSerializer.serialize(topic, purchaseRequest)
        ));

    if (sync) {
      PurchaseFulfillmentRequest result =  handleWaitingResponse(waitingResponse);
        if (result != null)
          {
            if (result.getStatus().getReturnCode() == ((PurchaseFulfillmentStatus.PURCHASED).getReturnCode()))
              {
                return handleWaitingResponse(waitingResponse);
              }
            else
              {
                String returnCode = (result.getStatus().getReturnCode()).toString();
                String returnMessage = result.getStatus().name();
                throw new GUIManagerException(returnMessage, returnCode);
              }
          }
    }
    return purchaseRequest;
  }

  private <T> T handleWaitingResponse(Future<T> waitingResponse) throws GUIManagerException {
    try {
      T response = waitingResponse.get(httpTimeout, TimeUnit.MILLISECONDS);
      if(log.isDebugEnabled()) log.debug("response processed : "+response);
      return response;
    } catch (InterruptedException|ExecutionException e) {
      String str = "Error waiting response";
      log.warn(str);
      throw new GUIManagerException("Internal error", str);
    } catch (TimeoutException e) {
      String str = "Timeout waiting response";
      log.info(str);
      throw new GUIManagerException("Internal error", str);
    }
  }

  /*****************************************
  *
  *  processCriterionFields
  *
  *****************************************/
  protected List<JSONObject> processCriterionFields(Map<String,CriterionField> baseCriterionFields, boolean tagsOnly, int tenantID)
  {
    return processCriterionFields(baseCriterionFields, tagsOnly, null, tenantID);
  }
  private List<JSONObject> processCriterionFields(Map<String,CriterionField> baseCriterionFields, boolean tagsOnly, Map<String, List<JSONObject>> currentGroups, int tenantID)
  {
    return processCriterionFields(baseCriterionFields, tagsOnly, currentGroups, null, tenantID);
  }
  private List<JSONObject> processCriterionFields(Map<String,CriterionField> baseCriterionFields, boolean tagsOnly, Map<String, List<JSONObject>> currentGroups, CriterionDataType expectedDataType, int tenantID)
  {
    /*****************************************
    *
    *  filter out parameter-only and tag-only data types
    *
    *****************************************/

    Date now = SystemTime.getCurrentTime();
    Map<String,CriterionField> criterionFields = new LinkedHashMap<String,CriterionField>();
    for (CriterionField criterionField : baseCriterionFields.values())
      {
        if (expectedDataType == null || expectedDataType.equals(criterionField.getFieldDataType()))
          {
            switch (criterionField.getFieldDataType())
            {
              case IntegerCriterion:
              case DoubleCriterion:
              case StringCriterion:
              case BooleanCriterion:
              case TimeCriterion:
              case DateCriterion:
                criterionFields.put(criterionField.getID(), criterionField);
                break;
                
              case AniversaryCriterion:
                JSONObject tempCriterionFieldJSON = (JSONObject) criterionField.getJSONRepresentation().clone();
                tempCriterionFieldJSON.put("dataType", CriterionDataType.DateCriterion.getExternalRepresentation());
                try
                  {
                    CriterionField dateCriterionField = new CriterionField(tempCriterionFieldJSON);
                    criterionFields.put(dateCriterionField.getID(), dateCriterionField);
                  } 
                catch (GUIManagerException e)
                  {
                    e.printStackTrace();
                  }
                break;

              case StringSetCriterion:
                if (! tagsOnly) criterionFields.put(criterionField.getID(), criterionField);
                break;
            }
          }
      }

    /****************************************
    *
    *  resolve field data types
    *
    ****************************************/

    Map<String, ResolvedFieldType> resolvedFieldTypes = new LinkedHashMap<String, ResolvedFieldType>();
    Map<String, List<JSONObject>> resolvedAvailableValues = new LinkedHashMap<String, List<JSONObject>>();
    Map<ResolvedFieldType, ResolvedFieldType> resolvedFieldsTypesMap = new HashMap<>(); // no this is not rubish, this is to ensure we play always with the same instance...
    for (CriterionField criterionField : criterionFields.values())
      {
        List<JSONObject> availableValues = evaluateAvailableValues(criterionField, now, true, tenantID);
        ResolvedFieldType resolvedFieldTypeInstance = resolvedFieldsTypesMap.get(new ResolvedFieldType(criterionField.getFieldDataType(), availableValues));
        if(resolvedFieldTypeInstance == null) {
          resolvedFieldTypeInstance = new ResolvedFieldType(criterionField.getFieldDataType(), availableValues);
          resolvedFieldsTypesMap.put(resolvedFieldTypeInstance, resolvedFieldTypeInstance);
        }
        resolvedFieldTypes.put(criterionField.getID(), resolvedFieldTypeInstance);
        resolvedAvailableValues.put(criterionField.getID(), availableValues);
      }

    /****************************************
    *
    *  default list of fields for each field data type
    *
    ****************************************/

    Map<ResolvedFieldType, List<CriterionField>> defaultFieldsForResolvedType = new LinkedHashMap<ResolvedFieldType, List<CriterionField>>();
    for (CriterionField criterionField : criterionFields.values())
      {
        if (! criterionField.getID().equals(CriterionField.EvaluationDateField))
          {
            ResolvedFieldType resolvedFieldType = resolvedFieldTypes.get(criterionField.getID());
            List<CriterionField> fields = defaultFieldsForResolvedType.get(resolvedFieldType);
            if (fields == null)
              {
                fields = new ArrayList<CriterionField>();
                defaultFieldsForResolvedType.put(resolvedFieldType, fields);
              }
            fields.add(criterionField);
          }
      }

    /****************************************
    *
    *  process
    *
    ****************************************/

    int nextGroupID = 1;
    
    List<JSONObject> result = new ArrayList<JSONObject>();
    for (CriterionField criterionField : criterionFields.values())
      {
        if (! criterionField.getInternalOnly())
          {
            //
            //  remove server-side fields
            //
            
            JSONObject criterionFieldJSON = (JSONObject) criterionField.getJSONRepresentation().clone();
            criterionFieldJSON.remove("esField");
            criterionFieldJSON.remove("retriever");

            //
            //  evaluate operators
            //

            List<JSONObject> fieldAvailableValues = resolvedAvailableValues.get(criterionField.getID());
            List<JSONObject> operators = evaluateOperators(criterionFieldJSON, fieldAvailableValues, tenantID);
            criterionFieldJSON.put("operators", operators);
            criterionFieldJSON.remove("includedOperators");
            criterionFieldJSON.remove("excludedOperators");

            //
            //  evaluate comparable fields
            //

           
            if (currentGroups != null)
              {

                ResolvedFieldType resolvedFieldType = resolvedFieldsTypesMap.get(resolvedFieldTypes.get(criterionField.getID()));
                List<JSONObject> singleton = resolvedFieldType.getAssociatedGroup();
                List<CriterionField> defaultComparableFields = defaultFieldsForResolvedType.get(resolvedFieldTypes.get(criterionField.getID()));
                if(singleton == null)
                  {
                    // create the group for this ResolvedFieldType
                    singleton = new ArrayList<>();
                    resolvedFieldType.setAssociatedGroup(singleton);
                    resolvedFieldType.setAssociatedGroupID(nextGroupID);
                    currentGroups.put(""+nextGroupID, singleton);
                    nextGroupID++;
                    for(CriterionField comparableField : defaultComparableFields)
                      {
                        JSONObject j = new JSONObject();
                        j.put("id", comparableField.getID());
                        j.put("display", comparableField.getDisplay());
                        singleton.add(j);
                      }
                  }
                criterionFieldJSON.put("singletonComparableFieldsGroup", ""+resolvedFieldType.getAssociatedGroupID());
              }
            
            criterionFieldJSON.remove("includedComparableFields");
            criterionFieldJSON.remove("excludedComparableFields");
            criterionFieldJSON.remove("epoch");
            criterionFieldJSON.remove("updatedDate");
            criterionFieldJSON.remove("createdDate");

            //
            //  evaluate available values for reference data
            //

            criterionFieldJSON.put("availableValues", resolvedAvailableValues.get(criterionField.getID()));

            //
            //  resolve maxTagLength
            //

            criterionFieldJSON.put("tagMaxLength", criterionField.resolveTagMaxLength());

            //
            //  normalize set-valued dataTypes to singleton-valued dataTypes (required by GUI)
            //  normalize AniversaryCriterion dataTypes to DateCriterion dataTypes (required by GUI)
            //

            switch (criterionField.getFieldDataType())
              {
                case StringSetCriterion:
                  criterionFieldJSON.put("dataType", CriterionDataType.StringCriterion.getExternalRepresentation());
                  break;
              }

            //
            //  rename fields
            //

            RenamedProfileCriterionField renamedProfileCriterionField = renamedProfileCriterionFieldReader.get(criterionField.getID());
            if (renamedProfileCriterionField != null) 
              {
                criterionFieldJSON.put("display", renamedProfileCriterionField.getDisplay());
              }
            
            //
            //  add
            //

            result.add(criterionFieldJSON);
          }
      }

    //
    //  return
    //

    return result;
  }

  /****************************************
  *
  *  evaluateOperators
  *
  ****************************************/

  private List<JSONObject> evaluateOperators(JSONObject criterionFieldJSON, List<JSONObject> fieldAvailableValues, int tenantID)
  {
    //
    //  all operators
    //

    Map<String,SupportedOperator> supportedOperatorsForType = Deployment.getDeployment(tenantID).getSupportedDataTypes().get(criterionFieldJSON.get("dataType")).getOperators();

    //
    //  remove set operators for non-enumerated types
    //

    List<String> supportedOperators = new ArrayList<String>();
    for (String supportedOperatorID : supportedOperatorsForType.keySet())
      {
        SupportedOperator supportedOperator = supportedOperatorsForType.get(supportedOperatorID);
        if (! supportedOperator.getArgumentSet())
          supportedOperators.add(supportedOperatorID);
        else if (supportedOperator.getArgumentSet() && fieldAvailableValues != null)
          supportedOperators.add(supportedOperatorID);
      }

    //
    //  find list of explicitly included operators
    //

    List<String> requestedIncludedOperatorIDs = null;
    if (criterionFieldJSON.get("includedOperators") != null)
      {
        requestedIncludedOperatorIDs = new ArrayList<String>();
        for (String operator : supportedOperators)
          {
            for (String operatorRegex : (List<String>) criterionFieldJSON.get("includedOperators"))
              {
                Pattern pattern = Pattern.compile("^" + operatorRegex + "$");
                if (pattern.matcher(operator).matches())
                  {
                    requestedIncludedOperatorIDs.add(operator);
                    break;
                  }
              }
          }
      }

    //
    //  find list of explicitly excluded operators
    //

    List<String> requestedExcludedOperatorIDs = null;
    if (criterionFieldJSON.get("excludedOperators") != null)
      {
        requestedExcludedOperatorIDs = new ArrayList<String>();
        for (String operator : supportedOperators)
          {
            for (String operatorRegex : (List<String>) criterionFieldJSON.get("excludedOperators"))
              {
                Pattern pattern = Pattern.compile("^" + operatorRegex + "$");
                if (pattern.matcher(operator).matches())
                  {
                    requestedExcludedOperatorIDs.add(operator);
                    break;
                  }
              }
          }
      }

    //
    //  resolve included/excluded operators
    //

    List<String> includedOperatorIDs = requestedIncludedOperatorIDs != null ? requestedIncludedOperatorIDs : supportedOperators;
    Set<String> excludedOperatorIDs = requestedExcludedOperatorIDs != null ? new LinkedHashSet<String>(requestedExcludedOperatorIDs) : Collections.<String>emptySet();

    //
    //  evaluate
    //

    List<JSONObject> result = new ArrayList<JSONObject>();
    for (String operatorID : includedOperatorIDs)
      {
        SupportedOperator operator = supportedOperatorsForType.get(operatorID);
        if (! excludedOperatorIDs.contains(operatorID))
          {
            result.add(operator.getJSONRepresentation());
          }
      }

    //
    //  return
    //

    return result;
  }

  /****************************************
  *
  *  evaluateComparableFields
  *
  ****************************************/

  private List<JSONObject> evaluateComparableFields(String criterionFieldID, JSONObject criterionFieldJSON, Collection<CriterionField> allFields, boolean singleton)
  {
    //
    //  all fields
    //

    Map<String, CriterionField> comparableFields = new LinkedHashMap<String, CriterionField>();
    for (CriterionField criterionField : allFields)
      {
        comparableFields.put(criterionField.getID(), criterionField);
      }

    //
    //  resolve included/excluded fields
    //

    List<String> includedComparableFieldIDs = new ArrayList<String>(comparableFields.keySet());

    //
    //  evaluate
    //

    List<JSONObject> result = new ArrayList<JSONObject>();
    for (String comparableFieldID : includedComparableFieldIDs)
      {
        CriterionField criterionField = comparableFields.get(comparableFieldID);
        if (singleton == criterionField.getFieldDataType().getSingletonType())
          {
            HashMap<String,Object> comparableFieldJSON = new HashMap<String,Object>();
            comparableFieldJSON.put("id", criterionField.getID());
            comparableFieldJSON.put("display", criterionField.getDisplay());
            result.add(JSONUtilities.encodeObject(comparableFieldJSON));
          }
      }
    return result;
  }

  /*****************************************
  *
  *  processNodeTypes
  *
  *****************************************/

  protected List<JSONObject> processNodeTypes(Map<String,NodeType> nodeTypes, Map<String,CriterionField> journeyParameters, Map<String,CriterionField> contextVariables, int tenantID) throws GUIManagerException
  {
    Date now = SystemTime.getCurrentTime();
    List<JSONObject> result = new ArrayList<JSONObject>();
    for (NodeType nodeType : nodeTypes.values())
      {
        //
        //  clone
        //

        JSONObject resolvedNodeTypeJSON = (JSONObject) nodeType.getJSONRepresentation().clone();

        //
        //  parameters
        //

        List<JSONObject>  resolvedParameters = new ArrayList<JSONObject>();
        JSONArray parameters = JSONUtilities.decodeJSONArray(resolvedNodeTypeJSON, "parameters", true);
        for (int i=0; i<parameters.size(); i++)
          {
            //
            //  clone (so we can modify the result)
            //

            JSONObject parameterJSON = (JSONObject) ((JSONObject) parameters.get(i)).clone();

            //
            //  availableValues
            //

            List<JSONObject> availableValues = evaluateAvailableValues(JSONUtilities.decodeJSONArray(parameterJSON, "availableValues", false), now, tenantID);
            parameterJSON.put("availableValues", (availableValues != null) ? JSONUtilities.encodeArray(availableValues) : null);

            //
            //  expressionFields
            //

            CriterionField parameter = nodeType.getParameters().get(JSONUtilities.decodeString(parameterJSON, "id", true));
            if (parameter != null && parameter.getExpressionValuedParameter())
              {
                JSONArray expressionFieldsArray = JSONUtilities.decodeJSONArray(parameterJSON, "expressionFields", false);
                if (expressionFieldsArray != null)
                  {
                    //
                    // hard coded fields
                    //
                    
                    List<JSONObject> expressionFields = evaluateAvailableValues(expressionFieldsArray, now, tenantID);
                    parameterJSON.put("expressionFields", JSONUtilities.encodeArray(expressionFields));
                  }
                else
                  {
                    //
                    //  default list of fields for parameter data type
                    //

                    CriterionContext criterionContext = new CriterionContext(journeyParameters, contextVariables, nodeType, (EvolutionEngineEventDeclaration) null, (Journey) null, tenantID);
                    List<CriterionField> defaultFields = new ArrayList<CriterionField>();
                    for (CriterionField criterionField : criterionContext.getCriterionFields(tenantID).values())
                      {
                        if (! criterionField.getID().equals(CriterionField.EvaluationDateField) && criterionField.getFieldDataType() == parameter.getFieldDataType())
                          {
                            defaultFields.add(criterionField);
                          }
                      }

                    //
                    //  evaluate comparable fields
                    //

                    List<JSONObject> expressionFields = evaluateComparableFields(parameter.getID(), parameter.getJSONRepresentation(), defaultFields, true);
                    parameterJSON.put("expressionFields", JSONUtilities.encodeArray(expressionFields));
                  }
              }

            //
            //  result
            //

            resolvedParameters.add(parameterJSON);
          }
        resolvedNodeTypeJSON.put("parameters", JSONUtilities.encodeArray(resolvedParameters));

        //
        //  dynamic output connector
        //

        JSONObject dynamicOutputConnectorJSON = JSONUtilities.decodeJSONObject(resolvedNodeTypeJSON, "dynamicOutputConnector", false);
        if (dynamicOutputConnectorJSON != null)
          {
            JSONObject resolvedDynamicOutputConnectorJSON = (JSONObject) dynamicOutputConnectorJSON.clone();
            List<JSONObject>  resolvedDynamicOutputConnectorParameters = new ArrayList<JSONObject>();
            JSONArray dynamicOutputConnectorParameters = JSONUtilities.decodeJSONArray(resolvedDynamicOutputConnectorJSON, "parameters", true);
            for (int i=0; i<dynamicOutputConnectorParameters.size(); i++)
              {
                JSONObject parameterJSON = (JSONObject) ((JSONObject) dynamicOutputConnectorParameters.get(i)).clone();
                List<JSONObject> availableValues = evaluateAvailableValues(JSONUtilities.decodeJSONArray(parameterJSON, "availableValues", false), now, tenantID);
                parameterJSON.put("availableValues", (availableValues != null) ? JSONUtilities.encodeArray(availableValues) : null);
                resolvedDynamicOutputConnectorParameters.add(parameterJSON);
              }
            resolvedDynamicOutputConnectorJSON.put("parameters", JSONUtilities.encodeArray(resolvedDynamicOutputConnectorParameters));
            resolvedNodeTypeJSON.put("dynamicOutputConnector", resolvedDynamicOutputConnectorJSON);
          }

        //
        //  result
        //

        result.add(resolvedNodeTypeJSON);
      }

    //
    //  return
    //

    return result;
  }

  /*****************************************
  *
  *  evaluateAvailableValues
  *
  *****************************************/

  private List<JSONObject> evaluateAvailableValues(CriterionField criterionField, Date now, boolean includeDynamic, int tenantID)
  {
    JSONObject criterionFieldJSON = (JSONObject) criterionField.getJSONRepresentation();
    List<JSONObject> availableValues = evaluateAvailableValues(JSONUtilities.decodeJSONArray(criterionFieldJSON, "availableValues", false), now, includeDynamic, tenantID);
    return availableValues;
  }

  /*****************************************
  *
  *  evaluateAvailableValues
  *
  *****************************************/

  private List<JSONObject> evaluateAvailableValues(JSONArray availableValues, Date now, int tenantID)
  {
    return evaluateAvailableValues(availableValues, now, true, tenantID);
  }

  /****************************************
  *
  *  evaluateAvailableValues
  *
  ****************************************/

  private List<JSONObject> evaluateAvailableValues(JSONArray availableValues, Date now, boolean includeDynamic, int tenantID)
  {
    List<JSONObject> result = null;
    if (availableValues != null)
      {
        result = new ArrayList<JSONObject>();
        Pattern enumeratedValuesPattern = Pattern.compile("^#(.*?)#$");
        for (Object availableValueUnchecked : availableValues)
          {
            if (availableValueUnchecked instanceof String)
              {
                String availableValue = (String) availableValueUnchecked;
                Matcher matcher = enumeratedValuesPattern.matcher(availableValue);
                if (matcher.matches())
                  {
                    result.addAll(evaluateEnumeratedValues(matcher.group(1), now, includeDynamic, tenantID));
                  }
                else
                  {
                    HashMap<String,Object> availableValueJSON = new HashMap<String,Object>();
                    availableValueJSON.put("id", availableValue);
                    availableValueJSON.put("display", availableValue);
                    result.add(JSONUtilities.encodeObject(availableValueJSON));
                  }
              }
            else if (availableValueUnchecked instanceof JSONObject)
              {
                JSONObject availableValue = (JSONObject) availableValueUnchecked;
                result.add(availableValue);
              }
            else
              {
                Object availableValue = (Object) availableValueUnchecked;
                HashMap<String,Object> availableValueJSON = new HashMap<String,Object>();
                availableValueJSON.put("id", availableValue);
                availableValueJSON.put("display", availableValue.toString());
                result.add(JSONUtilities.encodeObject(availableValueJSON));
              }
          }
      }
    return result;
  }

  /****************************************
  *
  *  evaluateEnumeratedValues
  *
  ****************************************/

  protected List<JSONObject> evaluateEnumeratedValues(String reference, Date now, boolean includeDynamic, int tenantID)
  {
    List<JSONObject> result = new ArrayList<JSONObject>();
    switch (reference)
      {
        
        case "suppliersDisplayExp":
          if (includeDynamic)
            {
              for (GUIManagedObject supplierUnchecked : supplierService.getStoredSuppliers(tenantID))
                {
                  if (supplierUnchecked.getAccepted())
                    {
                      Supplier supplier = (Supplier) supplierUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", "'" + supplier.getGUIManagedObjectDisplay() + "'");
                      availableValue.put("display", supplier.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "callableCampaigns":
          if (includeDynamic)
            {
              for (GUIManagedObject campaignUnchecked : journeyService.getStoredJourneys(tenantID))
                {
                  if (campaignUnchecked.getAccepted())
                    {
                      Journey campaign = (Journey) campaignUnchecked;
                      switch (campaign.getTargetingType())
                        {
                          case Manual:
                            switch (campaign.getGUIManagedObjectType())
                              {
                                case Campaign:
                                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                                  availableValue.put("id", campaign.getJourneyID());
                                  availableValue.put("display", campaign.getGUIManagedObjectDisplay());
                                  result.add(JSONUtilities.encodeObject(availableValue));
                                  break;
                              }
                            break;
                        }
                    }
                }
            }
          break;

        case "callableWorkflows":
          if (includeDynamic)
            {
              for (GUIManagedObject workflowUnchecked : journeyService.getStoredJourneys(tenantID))
                {
                  if (workflowUnchecked.getAccepted())
                    {
                      Journey workflow = (Journey) workflowUnchecked;
                      switch (workflow.getTargetingType())
                        {
                          case Manual:
                            switch (workflow.getGUIManagedObjectType())
                              {
                                case Workflow:
                                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                                  availableValue.put("id", workflow.getJourneyID());
                                  availableValue.put("display", workflow.getGUIManagedObjectDisplay());
                                  result.add(JSONUtilities.encodeObject(availableValue));
                                  break;
                              }
                            break;
                        }
                    }
                }
            }
          break;

        case "callableLoyaltyPrograms":
          if (includeDynamic)
            {
              for (GUIManagedObject loyaltyProgramUnchecked : loyaltyProgramService.getStoredLoyaltyPrograms(tenantID))
                {
                  if (loyaltyProgramUnchecked.getAccepted())
                    {
                      LoyaltyProgram loyaltyProgram = (LoyaltyProgram) loyaltyProgramUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", loyaltyProgram.getLoyaltyProgramID());
                      availableValue.put("display", loyaltyProgram.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "callableJourneys":
          if (includeDynamic)
            {
              for (GUIManagedObject journeyUnchecked : journeyService.getStoredJourneys(tenantID))
                {
                  if (journeyUnchecked.getAccepted())
                    {
                      Journey journey = (Journey) journeyUnchecked;
                      switch (journey.getTargetingType())
                        {
                          case Manual:
                            switch (journey.getGUIManagedObjectType())
                              {
                                case Journey:
                                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                                  availableValue.put("id", journey.getJourneyID());
                                  availableValue.put("display", journey.getGUIManagedObjectDisplay());
                                  result.add(JSONUtilities.encodeObject(availableValue));
                                  break;
                              }
                            break;
                        }
                    }
                }
            }
          break;

        case "deliverableIds":
          if (includeDynamic)
            {
              for (GUIManagedObject deliverablesUnchecked : deliverableService.getStoredDeliverables(tenantID))
                {
                  if (deliverablesUnchecked.getAccepted())
                    {
                      Deliverable deliverable = (Deliverable) deliverablesUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", deliverable.getGUIManagedObjectID());
                      availableValue.put("display", deliverable.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "deliverableNames":
          if (includeDynamic)
            {
              for (GUIManagedObject deliverablesUnchecked : deliverableService.getStoredDeliverables(tenantID))
                {
                  if (deliverablesUnchecked.getAccepted())
                    {
                      Deliverable deliverable = (Deliverable) deliverablesUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", deliverable.getDeliverableName());
                      availableValue.put("display", deliverable.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;
          
        case "deliveryStatuses":
          if (includeDynamic)
            {
              for (DeliveryStatus deliveryStatus : DeliveryManager.DeliveryStatus.values())
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", deliveryStatus.getExternalRepresentation());
                  availableValue.put("display", deliveryStatus.name());
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;

        case "eventNames":
          for (EvolutionEngineEventDeclaration evolutionEngineEventDeclaration : dynamicEventDeclarationsService.getStaticAndDynamicEvolutionEventDeclarations().values())
            {
              HashMap<String,Object> availableValue = new HashMap<String,Object>();
              availableValue.put("id", evolutionEngineEventDeclaration.getName());
              availableValue.put("display", evolutionEngineEventDeclaration.getName());
              result.add(JSONUtilities.encodeObject(availableValue));
            }
          break;

        case "historicalBulkCampaigns":
          if (includeDynamic)
            {
              for (GUIManagedObject journeyUnchecked : journeyService.getStoredJourneys(false, tenantID))
                {
                  if (journeyUnchecked.getAccepted() && journeyUnchecked.getGUIManagedObjectType() == GUIManagedObjectType.BulkCampaign)
                    {
                      Journey journey = (Journey) journeyUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", journey.getJourneyID());
                      availableValue.put("display", journey.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "historicalCampaigns":
          if (includeDynamic)
            {
              for (GUIManagedObject journeyUnchecked : journeyService.getStoredJourneys(false, tenantID))
                {
                  if (journeyUnchecked.getAccepted() && journeyUnchecked.getGUIManagedObjectType() == GUIManagedObjectType.Campaign)
                    {
                      Journey journey = (Journey) journeyUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", journey.getJourneyID());
                      availableValue.put("display", journey.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "historicalJourneys":
          if (includeDynamic)
            {
              for (GUIManagedObject journeyUnchecked : journeyService.getStoredJourneys(false, tenantID))
                {
                  if (journeyUnchecked.getAccepted() && journeyUnchecked.getGUIManagedObjectType() == GUIManagedObjectType.Journey)
                    {
                      Journey journey = (Journey) journeyUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", journey.getJourneyID());
                      availableValue.put("display", journey.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "loyaltyPrograms":
          if (includeDynamic)
            {
              for (GUIManagedObject loyaltyProgramsUnchecked : loyaltyProgramService.getStoredLoyaltyPrograms(tenantID))
                {
                  if (loyaltyProgramsUnchecked.getAccepted())
                    {
                      LoyaltyProgram loyaltyProgram = (LoyaltyProgram) loyaltyProgramsUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", loyaltyProgram.getLoyaltyProgramName());
                      availableValue.put("display", loyaltyProgram.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "loyaltyProgramPointsEventNames":
          for (EvolutionEngineEventDeclaration evolutionEngineEventDeclaration : Deployment.getEvolutionEngineEvents().values())
            {
              try
                {
                  Class eventClass = Class.forName(evolutionEngineEventDeclaration.getEventClassName());
                  for(Class currentInterface : eventClass.getInterfaces()){
                    if(currentInterface.equals(LoyaltyProgramPointsEvent.class)){
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", evolutionEngineEventDeclaration.getName());
                      availableValue.put("display", evolutionEngineEventDeclaration.getName());
                      result.add(JSONUtilities.encodeObject(availableValue));
                      break;
                    }
                  }
                } catch (Exception e)
                {
                }
            }
          break;
          
        case "moduleIds":
          if (includeDynamic)
            {
              for (Module module : DeliveryRequest.Module.values())
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", module.getExternalRepresentation());
                  availableValue.put("display", module.name());
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;

        case "offers":
          if (includeDynamic)
            {
              for (GUIManagedObject offerUnchecked : offerService.getStoredOffers(tenantID))
                {
                  if (offerUnchecked.getAccepted())
                    {
                      Offer offer = (Offer) offerUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", offer.getOfferID());
                      availableValue.put("display", offer.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "offerIDs":
          if (includeDynamic)
            {
              for (GUIManagedObject offerUnchecked : offerService.getStoredOffers(tenantID))
                {
                  if (offerUnchecked.getAccepted())
                    {
                      Offer offer = (Offer) offerUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", offer.getOfferID());
                      availableValue.put("display", offer.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "saleschannels":
          if (includeDynamic)
            {
              for (GUIManagedObject salesChannelUnchecked : salesChannelService.getStoredSalesChannels(tenantID))
                {
                  if (salesChannelUnchecked.getAccepted())
                    {
                      SalesChannel salesChannel = (SalesChannel) salesChannelUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", salesChannel.getSalesChannelID());
                      availableValue.put("display", salesChannel.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "saleschannelsDisplayExp":
          if (includeDynamic)
            {
              for (GUIManagedObject salesChannelUnchecked : salesChannelService.getStoredSalesChannels(tenantID))
                {
                  if (salesChannelUnchecked.getAccepted())
                    {
					  SalesChannel salesChannel = (SalesChannel) salesChannelUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", "'" + salesChannel.getGUIManagedObjectDisplay() + "'");
                      availableValue.put("display", salesChannel.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "offerObjectives":
          if (includeDynamic)
            {
              for (GUIManagedObject offerObjectiveUnchecked : offerObjectiveService.getStoredOfferObjectives(tenantID))
                {
                  if (offerObjectiveUnchecked.getAccepted())
                    {
                      OfferObjective offerObjective = (OfferObjective) offerObjectiveUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", offerObjective.getOfferObjectiveID());
                      availableValue.put("display", offerObjective.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "offersPresentationTokenTypes":
          if (includeDynamic)
            {
              for (GUIManagedObject tokenTypeUnchecked : tokenTypeService.getStoredTokenTypes(tenantID))
                {
                  if (tokenTypeUnchecked.getAccepted())
                    {
                      TokenType tokenType = (TokenType) tokenTypeUnchecked;
                      switch (tokenType.getTokenTypeKind())
                        {
                          case OffersPresentation:
                            HashMap<String,Object> availableValue = new HashMap<String,Object>();
                            availableValue.put("id", tokenType.getTokenTypeID());
                            availableValue.put("display", tokenType.getGUIManagedObjectDisplay());
                            result.add(JSONUtilities.encodeObject(availableValue));
                            break;
                        }
                    }
                }
            }
          break;

        case "paymentMeans":
          if (includeDynamic)
            {
              for (GUIManagedObject paymentMeanUnchecked : paymentMeanService.getStoredPaymentMeans(tenantID))
                {
                  if (paymentMeanUnchecked.getAccepted())
                    {
                      PaymentMean paymentMean = (PaymentMean) paymentMeanUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", paymentMean.getPaymentMeanID());
                      availableValue.put("display", paymentMean.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "pointDeliverables":
          if (includeDynamic)
            {
              DeliveryManagerDeclaration deliveryManager = Deployment.getDeliveryManagers().get("pointFulfillment");
              JSONObject deliveryManagerJSON = (deliveryManager != null) ? deliveryManager.getJSONRepresentation() : null;
              String providerID = (deliveryManagerJSON != null) ? (String) deliveryManagerJSON.get("providerID") : null;
              if (providerID != null)
                {
                  for (GUIManagedObject deliverableUnchecked : deliverableService.getStoredDeliverables(tenantID))
                    {
                      if (deliverableUnchecked.getAccepted())
                        {
                          Deliverable deliverable = (Deliverable) deliverableUnchecked;
                          if(deliverable.getFulfillmentProviderID().equals(providerID)){
                            HashMap<String,Object> availableValue = new HashMap<String,Object>();
                            availableValue.put("id", deliverable.getDeliverableID());
                            availableValue.put("display", deliverable.getGUIManagedObjectDisplay());
                            result.add(JSONUtilities.encodeObject(availableValue));
                          }
                        }
                    }
               }
            }
          break;

        case "pointPaymentMeans":
          if (includeDynamic)
            {
              DeliveryManagerDeclaration deliveryManager = Deployment.getDeliveryManagers().get("pointFulfillment");
              JSONObject deliveryManagerJSON = (deliveryManager != null) ? deliveryManager.getJSONRepresentation() : null;
              String providerID = (deliveryManagerJSON != null) ? (String) deliveryManagerJSON.get("providerID") : null;
              if (providerID != null)
                {
                  for (GUIManagedObject paymentMeanUnchecked : paymentMeanService.getStoredPaymentMeans(tenantID))
                    {
                      if (paymentMeanUnchecked.getAccepted())
                        {
                          PaymentMean paymentMean = (PaymentMean) paymentMeanUnchecked;
                          if(paymentMean.getFulfillmentProviderID().equals(providerID)){
                            HashMap<String,Object> availableValue = new HashMap<String,Object>();
                            availableValue.put("id", paymentMean.getPaymentMeanID());
                            availableValue.put("display", paymentMean.getGUIManagedObjectDisplay());
                            result.add(JSONUtilities.encodeObject(availableValue));
                          }
                        }
                    }
               }
            }
          break;

        case "presentationStrategies":
          if (includeDynamic)
            {
              for (GUIManagedObject presentationStrategyUnchecked : presentationStrategyService.getStoredPresentationStrategies(tenantID))
                {
                  if (presentationStrategyUnchecked.getAccepted())
                    {
                      PresentationStrategy presentationStrategy = (PresentationStrategy) presentationStrategyUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", presentationStrategy.getPresentationStrategyID());
                      availableValue.put("display", presentationStrategy.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "products":
          if (includeDynamic)
            {
              for (GUIManagedObject productUnchecked : productService.getStoredProducts(tenantID))
                {
                  if (productUnchecked.getAccepted())
                    {
                      Product product = (Product) productUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", product.getProductID());
                      availableValue.put("display", product.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "productTypes":
          if (includeDynamic)
            {
              for (GUIManagedObject productTypeUnchecked : productTypeService.getStoredProductTypes(tenantID))
                {
                  if (productTypeUnchecked.getAccepted())
                    {
                      ProductType productType = (ProductType) productTypeUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", productType.getID());
                      availableValue.put("display", productType.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "vouchers":
          if (includeDynamic)
          {
            for (GUIManagedObject voucherUnchecked : voucherService.getStoredVouchers(tenantID))
            {
              if (voucherUnchecked.getAccepted())
              {
                Voucher voucher = (Voucher) voucherUnchecked;
                HashMap<String,Object> availableValue = new HashMap<String,Object>();
                availableValue.put("id", voucher.getVoucherID());
                availableValue.put("display", voucher.getGUIManagedObjectDisplay());
                result.add(JSONUtilities.encodeObject(availableValue));
              }
            }
          }
          break;

        case "voucherTypes":
          if (includeDynamic)
          {
            for (GUIManagedObject voucherTypeUnchecked : voucherTypeService.getStoredVoucherTypes(tenantID))
            {
              if (voucherTypeUnchecked.getAccepted())
              {
                VoucherType voucherType = (VoucherType) voucherTypeUnchecked;
                HashMap<String,Object> availableValue = new HashMap<String,Object>();
                availableValue.put("id", voucherType.getID());
                availableValue.put("display", voucherType.getGUIManagedObjectDisplay());
                result.add(JSONUtilities.encodeObject(availableValue));
              }
            }
          }
          break;


        case "providerIds":
          if (includeDynamic)
            {
              for(DeliveryManagerDeclaration deliveryManager : Deployment.getDeployment(tenantID).getFulfillmentProviders().values())
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", deliveryManager.getProviderID());
                  availableValue.put("display", deliveryManager.getProviderName());
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;

        case "pushTemplates_app":
          if (includeDynamic)
            {
              filterPushTemplates("3", result, now, tenantID);  //Note : "3" is the id of the communication channel (defined in deployment.json)
            }
          break;
          
        case "pushTemplates_USSD":
          if (includeDynamic)
            {
              filterPushTemplates("4", result, now, tenantID);  //Note : "4" is the id of the communication channel (defined in deployment.json)
            }
          break;

        case "scoringStrategies":
          if (includeDynamic)
            {
              for (GUIManagedObject scoringStrategyUnchecked : scoringStrategyService.getStoredScoringStrategies(tenantID))
                {
                  if (scoringStrategyUnchecked.getAccepted())
                    {
                      ScoringStrategy scoringStrategy = (ScoringStrategy) scoringStrategyUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", scoringStrategy.getScoringStrategyID());
                      availableValue.put("display", scoringStrategy.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "segments":
          if (includeDynamic)
            {
              for (SegmentationDimension dimension : segmentationDimensionService.getActiveSegmentationDimensions(now, tenantID))
                {
                  for (Segment segment : dimension.getSegments())
                    {
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", segment.getID());
                      availableValue.put("display", dimension.getGUIManagedObjectDisplay() + ":" + segment.getName());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;
          
        case "smsTemplates":
          if (includeDynamic)
            {
              for (GUIManagedObject messageTemplateUnchecked : subscriberMessageTemplateService.getStoredSMSTemplates(true, false, tenantID))
                {
                  if (messageTemplateUnchecked.getAccepted())
                    {
                      SMSTemplate messageTemplate = (SMSTemplate) messageTemplateUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", messageTemplate.getSubscriberMessageTemplateID());
                      availableValue.put("display", messageTemplate.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;

        case "subscriberJourneyStatuses":
          if (includeDynamic)
            {
              for (SubscriberJourneyStatus subscriberJourneyStatus : Journey.SubscriberJourneyStatus.values())
                {
                  switch (subscriberJourneyStatus)
                    {
                      case Unknown:
                        break;
                        
                      case NotEligible:
                          break;

                      default:
                        HashMap<String,Object> availableValue = new HashMap<String,Object>();
                        availableValue.put("id", subscriberJourneyStatus.getExternalRepresentation());
                        availableValue.put("display", subscriberJourneyStatus.getDisplay());
                        result.add(JSONUtilities.encodeObject(availableValue));
                        break;
                    }
                }
            }
          break;

        case "sourceAddressesEmail":
          
          //
          //  communicationChannelesEmail
          //
          
          Collection<CommunicationChannel> communicationChannelesEmail = Deployment.getDeployment(tenantID).getCommunicationChannels().values().stream().filter(communicationChannel -> "email".equalsIgnoreCase(communicationChannel.getName())).collect(Collectors.toList());
          if (communicationChannelesEmail.size() > 0)
            {
              CommunicationChannel communicationChannelEmail = communicationChannelesEmail.iterator().next();
              for (GUIManagedObject sourceAddressUnchecked : sourceAddressService.getStoredGUIManagedObjects(tenantID))
                {
                  if (sourceAddressUnchecked.getAccepted())
                    {
                      SourceAddress sourceAddress = (SourceAddress) sourceAddressUnchecked;
                      if (sourceAddress.getCommunicationChannelId().equals(communicationChannelEmail.getID()))
                        {
                          HashMap<String,Object> availableValue = new HashMap<String,Object>();
                          availableValue.put("id", sourceAddress.getSourceAddressId());
                          availableValue.put("display", sourceAddress.getGUIManagedObjectDisplay());
                          result.add(JSONUtilities.encodeObject(availableValue));
                        }
                    }
                }
            }
          break;

        case "supportedLanguages":
          for (SupportedLanguage supportedLanguage : Deployment.getDeployment(tenantID).getSupportedLanguages().values())
            {
              HashMap<String,Object> availableValue = new HashMap<String,Object>();
              availableValue.put("id", supportedLanguage.getID());
              availableValue.put("display", supportedLanguage.getDisplay());
              result.add(JSONUtilities.encodeObject(availableValue));
            }
          break;
          
        case "sourceAddressesSMS":
          
          //
          //  communicationChannelesSMS
          //
          
          Collection<CommunicationChannel> communicationChannelesSMS = Deployment.getDeployment(tenantID).getCommunicationChannels().values().stream().filter(communicationChannel -> "SMS".equalsIgnoreCase(communicationChannel.getName())).collect(Collectors.toList());
          if (communicationChannelesSMS.size() > 0)
            {
              CommunicationChannel communicationChannelSMS = communicationChannelesSMS.iterator().next();
              for (GUIManagedObject sourceAddressUnchecked : sourceAddressService.getStoredGUIManagedObjects(tenantID))
                {
                  if (sourceAddressUnchecked.getAccepted())
                    {
                      SourceAddress sourceAddress = (SourceAddress) sourceAddressUnchecked;
                      if (sourceAddress.getCommunicationChannelId().equals(communicationChannelSMS.getID()))
                        {
                          HashMap<String,Object> availableValue = new HashMap<String,Object>();
                          availableValue.put("id", sourceAddress.getSourceAddressId());
                          availableValue.put("display", sourceAddress.getGUIManagedObjectDisplay());
                          result.add(JSONUtilities.encodeObject(availableValue));
                        }
                    }
                }
            }
          break;
          
       case "sourceAddressesFlashSMS":
          
          //
          //  communicationChannelesFlashSMS
          //
          
          Collection<CommunicationChannel> communicationChannelesFlashSMS = Deployment.getDeployment(tenantID).getCommunicationChannels().values().stream().filter(communicationChannel -> "flashsms".equalsIgnoreCase(communicationChannel.getName())).collect(Collectors.toList());
          if (communicationChannelesFlashSMS.size() > 0)
            {
              CommunicationChannel communicationChannelSMS = communicationChannelesFlashSMS.iterator().next();
              for (GUIManagedObject sourceAddressUnchecked : sourceAddressService.getStoredGUIManagedObjects(tenantID))
                {
                  if (sourceAddressUnchecked.getAccepted())
                    {
                      SourceAddress sourceAddress = (SourceAddress) sourceAddressUnchecked;
                      if (sourceAddress.getCommunicationChannelId().equals(communicationChannelSMS.getID()))
                        {
                          HashMap<String,Object> availableValue = new HashMap<String,Object>();
                          availableValue.put("id", sourceAddress.getSourceAddressId());
                          availableValue.put("display", sourceAddress.getSourceAddressDisplay());
                          result.add(JSONUtilities.encodeObject(availableValue));
                        }
                    }
                }
            }
          break;

        case "tokenTypes":
          if (includeDynamic)
            {
              for (GUIManagedObject tokenTypesUnchecked : tokenTypeService.getStoredTokenTypes(tenantID))
                {
                  if (tokenTypesUnchecked.getAccepted())
                    {
                      TokenType tokenType = (TokenType) tokenTypesUnchecked;
                      HashMap<String,Object> availableValue = new HashMap<String,Object>();
                      availableValue.put("id", tokenType.getGUIManagedObjectID());
                      availableValue.put("display", tokenType.getGUIManagedObjectDisplay());
                      result.add(JSONUtilities.encodeObject(availableValue));
                    }
                }
            }
          break;
          
        case "targets":
          if (includeDynamic)
            {
              for (Target target : targetService.getActiveTargets(now, tenantID))
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", target.getGUIManagedObjectID());
                  availableValue.put("display", target.getGUIManagedObjectDisplay());
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;
          
        case "resellers":
          if (includeDynamic)
            {
              for (Reseller reseller : resellerService.getActiveResellers(now, tenantID))
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", reseller.getGUIManagedObjectID());
                  availableValue.put("display", reseller.getGUIManagedObjectDisplay());
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;
          
        case "suppliers":
          if (includeDynamic)
            {
              for (Supplier supplier : supplierService.getActiveSuppliers(now, tenantID))
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", supplier.getGUIManagedObjectID());
                  availableValue.put("display", supplier.getGUIManagedObjectDisplay());
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;
          
        case "weekDays":
          if (includeDynamic)
            {
              List<String> weekDays = new LinkedList<String>();
              weekDays.add("Sunday"); weekDays.add("Monday"); weekDays.add("Tuesday"); weekDays.add("Wednesday"); weekDays.add("Thursday"); weekDays.add("Friday"); weekDays.add("Saturday");
              for (String weekDay : weekDays)
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", weekDay.toLowerCase());
                  availableValue.put("display", weekDay);
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;
        case "months":
          if (includeDynamic)
            {
              List<String> months = new LinkedList<String>();
              months.add("January"); months.add("February"); months.add("March"); months.add("April"); months.add("May"); months.add("June"); months.add("July"); months.add("August"); months.add("September"); months.add("October"); months.add("November"); months.add("December");
              for (String month : months)
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", month.toLowerCase());
                  availableValue.put("display", month);
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;
          
        case "returnCodesBDR":
          if (includeDynamic)
            {
              for (CommodityDeliveryStatus returnCode : CommodityDeliveryStatus.values())
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", returnCode.getReturnCode());
                  availableValue.put("display", RESTAPIGenericReturnCodes.fromGenericResponseCode(returnCode.getReturnCode()).getGenericResponseMessage());
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;
          
        case "returnCodesODR":
          if (includeDynamic)
            {
              for (PurchaseFulfillmentStatus returnCode : PurchaseFulfillmentStatus.values())
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", returnCode.getReturnCode());
                  availableValue.put("display", RESTAPIGenericReturnCodes.fromGenericResponseCode(returnCode.getReturnCode()).getGenericResponseMessage());
                  result.add(JSONUtilities.encodeObject(availableValue));
                }
            }
          break;
          
        case "returnCodesMDR":
          if (includeDynamic)
            {
              for (MessageStatus returnCode : MessageStatus.values())
                {
                  HashMap<String,Object> availableValue = new HashMap<String,Object>();
                  availableValue.put("id", returnCode.getReturnCode());
                  availableValue.put("display", RESTAPIGenericReturnCodes.fromGenericResponseCode(returnCode.getReturnCode()).getGenericResponseMessage());
                  result.add(JSONUtilities.encodeObject(availableValue));
              }
          }
        break;

        case "supportedRelationships":
          HashMap<String, Object> availableValue = new HashMap<String, Object>();
          availableValue.put("id", "customer");
          availableValue.put("display", "Customer");
          result.add(JSONUtilities.encodeObject(availableValue));
          
          for (SupportedRelationship supportedRelationship : Deployment.getDeployment(tenantID).getSupportedRelationships().values())
            {
              availableValue = new HashMap<String, Object>();
              availableValue.put("id", supportedRelationship.getID());
              availableValue.put("display", supportedRelationship.getDisplay());
              result.add(JSONUtilities.encodeObject(availableValue));
            }
          break;

        case "subscriberAttributes":
          for (MetaData metaData : Deployment.getDeployment(tenantID).getCustomerMetaData().getGeneralDetailsMetaData())
            {
              Object value = null; // TODO : do we need to select only fields that are not ReadOnly ?
              switch (metaData.getDataType())
              {
                case StringCriterion:
                case IntegerCriterion:
                case BooleanCriterion:
                  // We don't support Double fields, because they are normalized at custo level (and we have no access to this in EvolutionEngine)
                  availableValue = new HashMap<String, Object>();
                  availableValue.put("id", metaData.getName() + EvolutionEngine.DELIMITER + metaData.getDataType().getExternalRepresentation()); // name -X- dataType
                  availableValue.put("display", metaData.getDisplay());
                  result.add(JSONUtilities.encodeObject(availableValue));
                  break;
              }
            }
          result.sort((m1, m2) -> ((String) m1.get("display")).compareTo((String) m2.get("display")));
          break;
          
        case "supportedRelationshipsAndPartners":
          availableValue = new HashMap<String, Object>();
          availableValue.put("id", "customer");
          availableValue.put("display", "Customer");
          result.add(JSONUtilities.encodeObject(availableValue));
          for (SupportedRelationship supportedRelationship : Deployment.getDeployment(tenantID).getSupportedRelationships().values())
            {
              availableValue = new HashMap<String, Object>();
              availableValue.put("id", "hierarchy_" + supportedRelationship.getID());
              availableValue.put("display", supportedRelationship.getDisplay());
              result.add(JSONUtilities.encodeObject(availableValue));
            }
          
          availableValue = new HashMap<String, Object>();
          availableValue.put("id", EvolutionEngine.INTERNAL_ID_SUPPLIER);
          availableValue.put("display", "Supplier");
          
          result.add(JSONUtilities.encodeObject(availableValue));
          availableValue.put("id", EvolutionEngine.INTERNAL_ID_RESELLER);
          availableValue.put("display", "Reseller");
          result.add(JSONUtilities.encodeObject(availableValue));
          break;

      default:
          
          if(reference.startsWith("dialog_template_")) {
            // retrieve templates for the template id dialog_template_<template_id>
            // TODO EVPRO-146
              for (SubscriberMessageTemplate messageTemplate : subscriberMessageTemplateService
                  .getActiveSubscriberMessageTemplates(now, tenantID))
                {
                  if (messageTemplate.getAccepted() && !messageTemplate.getInternalOnly())
                    {
                      if (messageTemplate instanceof DialogTemplate)
                        {
                          DialogTemplate dialogTemplate = (DialogTemplate) messageTemplate;
                          String[] referenceSplit = reference.split("_");
                          String communicationChannelID = referenceSplit[(referenceSplit.length)-1];
                          if (dialogTemplate.getCommunicationChannelID().equals(communicationChannelID))
                            {
                              availableValue = new HashMap<String,Object>();
                              availableValue.put("id", messageTemplate.getSubscriberMessageTemplateID());                              
                              availableValue.put("display", ((messageTemplate.getSubscriberMessageTemplateDisplay() != null && !messageTemplate.getSubscriberMessageTemplateDisplay().isEmpty()) ? messageTemplate.getSubscriberMessageTemplateDisplay() : messageTemplate.getSubscriberMessageTemplateName()));
                              result.add(JSONUtilities.encodeObject(availableValue));
                            }

                        }
                    }
                }       
            
          }
          if(reference.startsWith("dialog_source_address_")) 
            {
              String[] referenceSplit = reference.split("_");
              String communicationChannelID = referenceSplit[(referenceSplit.length)-1];
              CommunicationChannel communicationChannel = Deployment.getDeployment(tenantID).getCommunicationChannels().get(communicationChannelID);
              for (GUIManagedObject sourceAddressUnchecked : sourceAddressService.getStoredGUIManagedObjects(tenantID))
                {
                  if (sourceAddressUnchecked.getAccepted())
                    {
                      SourceAddress sourceAddress = (SourceAddress) sourceAddressUnchecked;
                      if (sourceAddress.getCommunicationChannelId().equals(communicationChannel.getID()))
                        {
                          availableValue = new HashMap<String,Object>();
                          availableValue.put("id", sourceAddress.getSourceAddressId());
                          availableValue.put("display", sourceAddress.getGUIManagedObjectDisplay());
                          result.add(JSONUtilities.encodeObject(availableValue));
                        }
                    }
                }   
            }
          
          boolean foundValue = false;
          if(includeDynamic)
            {
              for(CriterionFieldAvailableValues availableValues : criterionFieldAvailableValuesService.getActiveCriterionFieldAvailableValues(now, tenantID))
                {
                  if(availableValues.getGUIManagedObjectID().equals(reference))
                    {
                      availableValue = new HashMap<String,Object>();
                      if(availableValues.getAvailableValues() != null)
                        {
                          for(Pair<String, String> pair : availableValues.getAvailableValues())
                            {
                              availableValue.put("id", pair.getFirstElement());
                              availableValue.put("display", pair.getSecondElement());
                              result.add(JSONUtilities.encodeObject(availableValue));
                              foundValue = true;
                            }
                        }
                    }
                }
            }
          if (guiManagerExtensionEvaluateEnumeratedValuesMethod != null && !foundValue)
            {
              try
              {
                result.addAll((List<JSONObject>) guiManagerExtensionEvaluateEnumeratedValuesMethod.invoke(null, guiManagerContext, reference, now, includeDynamic));
              }
              catch (IllegalAccessException|InvocationTargetException|RuntimeException e)
              {
                log.error("failed deployment evaluate enumerated values for reference {}", reference);
                StringWriter stackTraceWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(stackTraceWriter, true));
                log.error(stackTraceWriter.toString());
              }
            }
          break;
      }
    return result;
  }

  @Deprecated
  private void filterPushTemplates(String communicationChannelID, List<JSONObject> result, Date now, int tenantID){
    for (SubscriberMessageTemplate messageTemplate : subscriberMessageTemplateService.getActiveSubscriberMessageTemplates(now, tenantID))
      {
        if (messageTemplate.getAccepted() && !messageTemplate.getInternalOnly())
          {
            switch (messageTemplate.getTemplateType())
            {
            case "push":
              PushTemplate pushTemplate = (PushTemplate) messageTemplate;
              if(pushTemplate.getCommunicationChannelID().equals(communicationChannelID)){
                HashMap<String,Object> availableValue = new HashMap<String,Object>();
                availableValue.put("id", messageTemplate.getSubscriberMessageTemplateID());
                //TODO : Gui is not sending the display field yet. Change this when GUI will be updated ...
                //availableValue.put("display", messageTemplate.getSubscriberMessageTemplateDisplay());
                availableValue.put("display", ((messageTemplate.getSubscriberMessageTemplateDisplay() != null && !messageTemplate.getSubscriberMessageTemplateDisplay().isEmpty()) ? messageTemplate.getSubscriberMessageTemplateDisplay() : messageTemplate.getSubscriberMessageTemplateName()));
                result.add(JSONUtilities.encodeObject(availableValue));
                break;
              }
            }
          }
      }
  }
 

  /*****************************************
  *
  *  revalidateTargets
  *
  *****************************************/

  protected void revalidateTargets(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedTargets = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingTarget : targetService.getStoredTargets(tenantID))
      {
        //
        //  modifiedScoringStrategy
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedTarget;
        try
          {
            Target target = new Target(existingTarget.getJSONRepresentation(), epoch, existingTarget, tenantID);
            target.validate(uploadedFileService, date);
            modifiedTarget = target;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedTarget = new IncompleteObject(existingTarget.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingTarget.getAccepted() != modifiedTarget.getAccepted())
          {
            modifiedTargets.add(modifiedTarget);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedTarget : modifiedTargets)
      {
        targetService.putGUIManagedObject(modifiedTarget, date, false, null);
      }

    /****************************************
    *
    *  revalidate journeys
    *
    ****************************************/

    revalidateJourneys(date, tenantID);
  }

  /*****************************************
  *
  *  revalidateScoringStrategies
  *
  *****************************************/

  private void revalidateScoringStrategies(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedScoringStrategies = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingScoringStrategy : scoringStrategyService.getStoredScoringStrategies(tenantID))
      {
        //
        //  modifiedScoringStrategy
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedScoringStrategy;
        try
          {
            ScoringStrategy scoringStrategy = new ScoringStrategy(existingScoringStrategy.getJSONRepresentation(), epoch, existingScoringStrategy, tenantID);
            scoringStrategy.validate(offerObjectiveService, date);
            modifiedScoringStrategy = scoringStrategy;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedScoringStrategy = new IncompleteObject(existingScoringStrategy.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingScoringStrategy.getAccepted() != modifiedScoringStrategy.getAccepted())
          {
            modifiedScoringStrategies.add(modifiedScoringStrategy);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedScoringStrategy : modifiedScoringStrategies)
      {
        scoringStrategyService.putGUIManagedObject(modifiedScoringStrategy, date, false, null);
      }

    /****************************************
    *
    *  revalidate presentation strategies
    *
    ****************************************/

    revalidatePresentationStrategies(date, tenantID);
  }

  /*****************************************
  *
  *  revalidatePresentationStrategies
  *
  *****************************************/

  private void revalidatePresentationStrategies(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedPresentationStrategies = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingPresentationStrategy : presentationStrategyService.getStoredPresentationStrategies(tenantID))
      {
        //
        //  modifiedPresentationStrategy
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedPresentationStrategy;
        try
          {
            PresentationStrategy presentationStrategy = new PresentationStrategy(existingPresentationStrategy.getJSONRepresentation(), epoch, existingPresentationStrategy, tenantID);
            presentationStrategy.validate(scoringStrategyService, date);
            modifiedPresentationStrategy = presentationStrategy;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedPresentationStrategy = new IncompleteObject(existingPresentationStrategy.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingPresentationStrategy.getAccepted() != modifiedPresentationStrategy.getAccepted())
          {
            modifiedPresentationStrategies.add(modifiedPresentationStrategy);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedPresentationStrategy : modifiedPresentationStrategies)
      {
        presentationStrategyService.putGUIManagedObject(modifiedPresentationStrategy, date, false, null);
      }
  }

  /*****************************************
  *
  *  revalidateJourneys
  *
  *****************************************/

  protected void revalidateJourneys(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedJourneys = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingJourney : journeyService.getStoredJourneys(tenantID))
      {
        //
        //  modifiedJourney
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedJourney;
        try
          {
            Journey journey = new Journey(existingJourney.getJSONRepresentation(), existingJourney.getGUIManagedObjectType(), epoch, existingJourney, journeyService, catalogCharacteristicService, subscriberMessageTemplateService, dynamicEventDeclarationsService, journeyTemplateService, tenantID);
            journey.validate(journeyObjectiveService, catalogCharacteristicService, targetService, date);
            modifiedJourney = journey;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedJourney = new IncompleteObject(existingJourney.getJSONRepresentation(), existingJourney.getGUIManagedObjectType(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingJourney.getAccepted() != modifiedJourney.getAccepted())
          {
            modifiedJourneys.add(modifiedJourney);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedJourney : modifiedJourneys)
      {
        if (modifiedJourney instanceof Journey)
          {
            try
              {
                journeyService.putJourney(modifiedJourney, journeyObjectiveService, catalogCharacteristicService, targetService, subscriberMessageTemplateService, false, null);
              }
            catch (JSONUtilitiesException|GUIManagerException e)
              {
                  log.warn(e.getLocalizedMessage());
              }
          }
        else
          {
            journeyService.putGUIManagedObject(modifiedJourney, date, false, null);
          }
      }
  }

  /*****************************************
  *
  *  revalidateSubscriberMessageTemplates
  *
  *****************************************/

  protected void revalidateSubscriberMessageTemplates(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedSubscriberMessageTemplates = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingSubscriberMessageTemplate : subscriberMessageTemplateService.getStoredSubscriberMessageTemplates(tenantID))
      {
        //
        //  modifiedSubscriberMessageTemplate
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedSubscriberMessageTemplate;
        try
          {
            SubscriberMessageTemplate subscriberMessageTemplate = null;
            if (existingSubscriberMessageTemplate instanceof SMSTemplate) subscriberMessageTemplate = new SMSTemplate(existingSubscriberMessageTemplate.getJSONRepresentation(), epoch, existingSubscriberMessageTemplate, tenantID);
            if (existingSubscriberMessageTemplate instanceof MailTemplate) subscriberMessageTemplate = new MailTemplate(existingSubscriberMessageTemplate.getJSONRepresentation(), epoch, existingSubscriberMessageTemplate, tenantID);
            if (existingSubscriberMessageTemplate instanceof PushTemplate) subscriberMessageTemplate = new PushTemplate(existingSubscriberMessageTemplate.getJSONRepresentation(), epoch, existingSubscriberMessageTemplate, tenantID);
            if (existingSubscriberMessageTemplate instanceof DialogTemplate) subscriberMessageTemplate = new DialogTemplate(existingSubscriberMessageTemplate.getJSONRepresentation(), epoch, existingSubscriberMessageTemplate, tenantID);
            if ( !(existingSubscriberMessageTemplate instanceof IncompleteObject) && subscriberMessageTemplate == null) throw new ServerRuntimeException("illegal subscriberMessageTemplate");            
            modifiedSubscriberMessageTemplate = subscriberMessageTemplate;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedSubscriberMessageTemplate = new IncompleteObject(existingSubscriberMessageTemplate.getJSONRepresentation(), existingSubscriberMessageTemplate.getGUIManagedObjectType(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (modifiedSubscriberMessageTemplate != null && existingSubscriberMessageTemplate.getAccepted() != modifiedSubscriberMessageTemplate.getAccepted())
          {
            modifiedSubscriberMessageTemplates.add(modifiedSubscriberMessageTemplate);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedSubscriberMessageTemplate : modifiedSubscriberMessageTemplates)
      {
        subscriberMessageTemplateService.putGUIManagedObject(modifiedSubscriberMessageTemplate, date, false, null);
      }
  }

  /*****************************************
  *
  *  revalidateOffers
  *
  *****************************************/

  protected void revalidateOffers(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedOffers = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingOffer : offerService.getStoredOffers(tenantID))
      {
        //
        //  modifiedOffer
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedOffer;
        try
          {
            Offer offer = new Offer(existingOffer.getJSONRepresentation(), epoch, existingOffer, catalogCharacteristicService, tenantID);
            offer.validate(callingChannelService, salesChannelService, productService, voucherService, date);
            modifiedOffer = offer;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedOffer = new IncompleteObject(existingOffer.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingOffer.getAccepted() != modifiedOffer.getAccepted())
          {
            modifiedOffers.add(modifiedOffer);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedOffer : modifiedOffers)
      {
        offerService.putGUIManagedObject(modifiedOffer, date, false, null);
      }
  }

  /*****************************************
  *
  *  revalidateProducts
  *
  *****************************************/

  protected void revalidateProducts(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedProducts = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingProduct : productService.getStoredProducts(tenantID))
      {
        //
        //  modifiedProduct
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedProduct;
        try
          {
            Product product = new Product(existingProduct.getJSONRepresentation(), epoch, existingProduct, deliverableService, catalogCharacteristicService, tenantID);
            product.validate(supplierService, productTypeService, deliverableService, date);
            modifiedProduct = product;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedProduct = new IncompleteObject(existingProduct.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingProduct.getAccepted() != modifiedProduct.getAccepted())
          {
            modifiedProducts.add(modifiedProduct);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedProduct : modifiedProducts)
      {
        productService.putGUIManagedObject(modifiedProduct, date, false, null);
      }

    /****************************************
    *
    *  revalidate offers
    *
    ****************************************/

    revalidateOffers(date, tenantID);
  }

  /*****************************************
   *
   *  revalidateVouchers
   *
   *****************************************/

  protected void revalidateVouchers(Date date, int tenantID)
  {
    /****************************************
     *
     *  identify
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();

    Set<GUIManagedObject> modifiedVouchers = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingVoucher : voucherService.getStoredVouchers(tenantID))
    {
      //
      //  modifiedVoucher
      //

      long epoch = epochServer.getKey();
      GUIManagedObject modifiedVoucher;
      try
      {
        Voucher voucher=null;
        if (existingVoucher instanceof VoucherShared) {
          voucher = new VoucherShared(existingVoucher.getJSONRepresentation(), epoch, existingVoucher, tenantID);
          voucher.validate(voucherTypeService,uploadedFileService,date);
        }
        if (voucher == null && existingVoucher instanceof VoucherPersonal) {
          VoucherType voucherType = voucherTypeService.getActiveVoucherType(((VoucherPersonal)existingVoucher).getVoucherTypeId(),now);
          voucher = new VoucherPersonal(existingVoucher.getJSONRepresentation(), epoch, existingVoucher,voucherType, tenantID);
          voucher.validate(voucherTypeService,uploadedFileService,date);
        }
        modifiedVoucher = voucher;
      }
      catch (JSONUtilitiesException|GUIManagerException e)
      {
        modifiedVoucher = new IncompleteObject(existingVoucher.getJSONRepresentation(), epoch, tenantID);
      }

      //
      //  changed?
      //

      if (existingVoucher.getAccepted() != modifiedVoucher.getAccepted())
      {
        modifiedVouchers.add(modifiedVoucher);
      }
    }

    /****************************************
     *
     *  update
     *
     ****************************************/

    for (GUIManagedObject modifiedVoucher : modifiedVouchers)
    {
      voucherService.putGUIManagedObject(modifiedVoucher, date, false, null);
    }

    /****************************************
     *
     *  revalidate offers
     *
     ****************************************/

    revalidateOffers(date, tenantID);
  }

  /*****************************************
  *
  *  revalidateCatalogCharacteristics
  *
  *****************************************/

  private void revalidateCatalogCharacteristics(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedCatalogCharacteristics = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingCatalogCharacteristic : catalogCharacteristicService.getStoredCatalogCharacteristics(tenantID))
      {
        //
        //  modifiedCatalogCharacteristic
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedCatalogCharacteristic;
        try
          {
            CatalogCharacteristic catalogCharacteristic = new CatalogCharacteristic(existingCatalogCharacteristic.getJSONRepresentation(), epoch, existingCatalogCharacteristic, tenantID);
            modifiedCatalogCharacteristic = catalogCharacteristic;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedCatalogCharacteristic = new IncompleteObject(existingCatalogCharacteristic.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingCatalogCharacteristic.getAccepted() != modifiedCatalogCharacteristic.getAccepted())
          {
            modifiedCatalogCharacteristics.add(modifiedCatalogCharacteristic);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedCatalogCharacteristic : modifiedCatalogCharacteristics)
      {
        catalogCharacteristicService.putGUIManagedObject(modifiedCatalogCharacteristic, date, false, null);
      }

    /****************************************
    *
    *  revalidate dependent objects
    *
    ****************************************/

    revalidateOffers(date, tenantID);
    revalidateJourneyObjectives(date, tenantID);
    revalidateOfferObjectives(date, tenantID);
    revalidateProductTypes(date, tenantID);
    revalidateProducts(date, tenantID);
    revalidateVoucherTypes(date, tenantID);
    revalidateVouchers(date, tenantID);
  }

  /*****************************************
  *
  *  revalidateJourneyObjectives
  *
  *****************************************/

  protected void revalidateJourneyObjectives(Date date, int tenantID)
  {
    /****************************************
    *
    *  identifyten
    *
    ****************************************/

    Set<GUIManagedObject> modifiedJourneyObjectives = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingJourneyObjective : journeyObjectiveService.getStoredJourneyObjectives(tenantID))
      {
        //
        //  modifiedJourneyObjective
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedJourneyObjective;
        try
          {
            JourneyObjective journeyObjective = new JourneyObjective(existingJourneyObjective.getJSONRepresentation(), epoch, existingJourneyObjective, tenantID);
            journeyObjective.validate(journeyObjectiveService, contactPolicyService, catalogCharacteristicService, date);
            modifiedJourneyObjective = journeyObjective;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedJourneyObjective = new IncompleteObject(existingJourneyObjective.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingJourneyObjective.getAccepted() != modifiedJourneyObjective.getAccepted())
          {
            modifiedJourneyObjectives.add(modifiedJourneyObjective);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedJourneyObjective : modifiedJourneyObjectives)
      {
        journeyObjectiveService.putGUIManagedObject(modifiedJourneyObjective, date, false, null);
      }

    /****************************************
    *
    *  revalidate dependent objects
    *
    ****************************************/

    revalidateJourneys(date, tenantID);
    if (modifiedJourneyObjectives.size() > 0)
      {
        revalidateJourneyObjectives(date, tenantID);
      }
  }

  /*****************************************
  *
  *  revalidateSalesChannels
  *
  *****************************************/

  private void revalidateSalesChannels(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedSalesChannels = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingSalesChannel : salesChannelService.getStoredSalesChannels(tenantID))
      {
        //
        //  modifiedsalesChannel
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedSalesChannel;
        try
          {
            SalesChannel salesChannel = new SalesChannel(existingSalesChannel.getJSONRepresentation(), epoch, existingSalesChannel, tenantID);
            salesChannel.validate(callingChannelService, resellerService, date);
            modifiedSalesChannel = salesChannel;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedSalesChannel = new IncompleteObject(existingSalesChannel.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingSalesChannel.getAccepted() != modifiedSalesChannel.getAccepted())
          {
            modifiedSalesChannels.add(modifiedSalesChannel);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedSalesChannel : modifiedSalesChannels)
      {
        salesChannelService.putGUIManagedObject(modifiedSalesChannel, date, false, null);
      }

    /****************************************
    *
    *  revalidate dependent objects
    *
    ****************************************/

    revalidateOffers(date, tenantID);
  }

  /*****************************************
  *
  *  revalidateOfferObjectives
  *
  *****************************************/

  protected void revalidateOfferObjectives(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedOfferObjectives = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingOfferObjective : offerObjectiveService.getStoredOfferObjectives(tenantID))
      {
        //
        //  modifiedOfferObjective
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedOfferObjective;
        try
          {
            OfferObjective offerObjective = new OfferObjective(existingOfferObjective.getJSONRepresentation(), epoch, existingOfferObjective, tenantID);
            offerObjective.validate(catalogCharacteristicService, date);
            modifiedOfferObjective = offerObjective;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedOfferObjective = new IncompleteObject(existingOfferObjective.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingOfferObjective.getAccepted() != modifiedOfferObjective.getAccepted())
          {
            modifiedOfferObjectives.add(modifiedOfferObjective);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedOfferObjective : modifiedOfferObjectives)
      {
        offerObjectiveService.putGUIManagedObject(modifiedOfferObjective, date, false, null);
      }

    /****************************************
    *
    *  revalidate dependent objects
    *
    ****************************************/

    revalidateOffers(date, tenantID);
    revalidateScoringStrategies(date, tenantID);
  }

  /*****************************************
  *
  *  revalidateProductTypes
  *
  *****************************************/

  protected void revalidateProductTypes(Date date, int tenantID)
  {
    /****************************************
    *
    *  identify
    *
    ****************************************/

    Set<GUIManagedObject> modifiedProductTypes = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingProductType : productTypeService.getStoredProductTypes(tenantID))
      {
        //
        //  modifiedProductType
        //

        long epoch = epochServer.getKey();
        GUIManagedObject modifiedProductType;
        try
          {
            ProductType productType = new ProductType(existingProductType.getJSONRepresentation(), epoch, existingProductType, tenantID);
            productType.validate(catalogCharacteristicService, date);
            modifiedProductType = productType;
          }
        catch (JSONUtilitiesException|GUIManagerException e)
          {
            modifiedProductType = new IncompleteObject(existingProductType.getJSONRepresentation(), epoch, tenantID);
          }

        //
        //  changed?
        //

        if (existingProductType.getAccepted() != modifiedProductType.getAccepted())
          {
            modifiedProductTypes.add(modifiedProductType);
          }
      }

    /****************************************
    *
    *  update
    *
    ****************************************/

    for (GUIManagedObject modifiedProductType : modifiedProductTypes)
      {
        productTypeService.putGUIManagedObject(modifiedProductType, date, false, null);
      }

    /****************************************
    *
    *  revalidate dependent objects
    *
    ****************************************/

    revalidateProducts(date, tenantID);
  }

  /*****************************************
   *
   *  revalidateVoucherTypes
   *
   *****************************************/

  protected void revalidateVoucherTypes(Date date, int tenantID)
  {
    /****************************************
     *
     *  identify
     *
     ****************************************/

    Set<GUIManagedObject> modifiedVoucherTypes = new HashSet<GUIManagedObject>();
    for (GUIManagedObject existingVoucherType : voucherTypeService.getStoredVoucherTypes(tenantID))
    {
      //
      //  modifiedVoucherType
      //

      long epoch = epochServer.getKey();
      GUIManagedObject modifiedVoucherType;
      try
      {
        VoucherType voucherType = new VoucherType(existingVoucherType.getJSONRepresentation(), epoch, existingVoucherType, tenantID);
        voucherType.validate(catalogCharacteristicService, date);
        modifiedVoucherType = voucherType;
      }
      catch (JSONUtilitiesException|GUIManagerException e)
      {
        modifiedVoucherType = new IncompleteObject(existingVoucherType.getJSONRepresentation(), epoch, tenantID);
      }

      //
      //  changed?
      //

      if (existingVoucherType.getAccepted() != modifiedVoucherType.getAccepted())
      {
        modifiedVoucherTypes.add(modifiedVoucherType);
      }
    }

    /****************************************
     *
     *  update
     *
     ****************************************/

    for (GUIManagedObject modifiedVoucherType : modifiedVoucherTypes)
    {
      voucherTypeService.putGUIManagedObject(modifiedVoucherType, date, false, null);
    }

    /****************************************
     *
     *  revalidate dependent objects
     *
     ****************************************/

    revalidateVouchers(date, tenantID);
  }
  
  /****************************************
  *
  *  resolveSubscriberID
  *
  ****************************************/

  protected String resolveSubscriberID(String customerID, int tenantID)
  {
    try
      {
        Pair<String, Integer> s = subscriberIDService.getSubscriberIDAndTenantID(getCustomerAlternateID, customerID);
        if(s != null && s.getSecondElement().intValue() == tenantID)
          {            
            return s.getFirstElement();
          }
      }
    catch (SubscriberIDServiceException e)
      {
        log.error("SubscriberIDServiceException can not resolve subscriberID for {} error is {}", customerID, e.getMessage());
      }
    return null; // in case the subscriber does not exist or the tenantID is not coherent
  }

  /****************************************
  *
  *  resolveSubscriberID
  *
  ****************************************/

  protected String resolveSubscriberID(String alternateID, String alternateIDValue)
  {
    String result = null;
    try
      {
        result = subscriberIDService.getSubscriberID(alternateID, alternateIDValue);
      }
    catch (SubscriberIDServiceException e)
      {
        log.error("SubscriberIDServiceException can not resolve subscriberID for {} error is {}", alternateIDValue, e.getMessage());
      }
    return result;
  }
  
  /*****************************************
  *
  *  prepareEndDate
  *
  *****************************************/

  public static Date prepareEndDate(Date endDate, String timeZone)
  {
    Date result = null;
    if (endDate != null)
      {
        Calendar cal = Calendar.getInstance();
        cal.setTimeZone(TimeZone.getTimeZone(timeZone));
        cal.setTime(endDate);
        cal.set(Calendar.HOUR_OF_DAY, 23);
        cal.set(Calendar.MINUTE, 59);
        cal.set(Calendar.SECOND, 59);
        result = cal.getTime();
      }
    return result;
  }
  
  /*****************************************
  *
  *  prepareStartDate
  *
  *****************************************/

  public static Date prepareStartDate(Date startDate, String timeZone)
  {
    Date result = null;
    if (startDate != null)
      {
        Calendar cal = Calendar.getInstance();
        cal.setTimeZone(TimeZone.getTimeZone(timeZone));
        cal.setTime(startDate);
        cal.set(Calendar.HOUR_OF_DAY, 00);
        cal.set(Calendar.MINUTE, 00);
        cal.set(Calendar.SECOND, 00);
        result = cal.getTime();
      }
    return result;
  }

  /*****************************************
  *
  *  resolveJourneyParameters
  *
  *****************************************/

  private JSONObject resolveJourneyParameters(JSONObject journeyJSON, Date now, int tenantID)
  {
    //
    //  resolve
    //

    List<JSONObject>  resolvedParameters = new LinkedList<>();
    JSONArray parameters = JSONUtilities.decodeJSONArray(journeyJSON, "journeyParameters", new JSONArray());
    for (int i=0; i<parameters.size(); i++)
      {
        //
        //  clone (so we can modify the result)
        //

        JSONObject parameterJSON = (JSONObject) ((JSONObject) parameters.get(i)).clone();

        //
        //  availableValues
        //

        List<JSONObject> availableValues = evaluateAvailableValues(JSONUtilities.decodeJSONArray(parameterJSON, "availableValues", false), now, tenantID);
        parameterJSON.put("availableValues", (availableValues != null) ? JSONUtilities.encodeArray(availableValues) : null);

        //
        //  result
        //

        resolvedParameters.add(parameterJSON);
      }

    //
    //  replace
    //

    journeyJSON.put("journeyParameters", JSONUtilities.encodeArray(resolvedParameters));

    //
    //  return
    //

    return journeyJSON;
  }

  /*****************************************
  *
  *  class APISimpleHandler
  *
  *****************************************/

  private class APISimpleHandler implements HttpHandler
  {
    /*****************************************
    *
    *  data
    *
    *****************************************/

    private API api;

    /*****************************************
    *
    *  constructor
    *
    *****************************************/

    private APISimpleHandler(API api)
    {
      this.api = api;
    }

    /*****************************************
    *
    *  handle -- HttpHandler
    *
    *****************************************/

    public void handle(HttpExchange exchange) throws IOException
    {
      handleSimpleHandler(api, exchange);
    }
  }

  /*****************************************
  *
  *  class APIComplexHandler
  *
  *****************************************/

  private class APIComplexHandler implements HttpHandler
  {
    /*****************************************
    *
    *  data
    *
    *****************************************/

    private API api;

    /*****************************************
    *
    *  constructor
    *
    *****************************************/

    private APIComplexHandler(API api)
    {
      this.api = api;
    }

    /*****************************************
    *
    *  handle -- HttpHandler
    *
    *****************************************/

    public void handle(HttpExchange exchange) throws IOException
    {
      handleComplexAPI(api, exchange);
    }
  }

  /*****************************************
  *
  *  class SharedIDService
  *
  *****************************************/

  public static class SharedIDService
  {
    /*****************************************
    *
    *  data
    *
    *****************************************/

    private int lastGeneratedObjectID = 0;
    private Set<GUIService> baseServices;

    /*****************************************
    *
    *  constructor
    *
    *****************************************/

    public SharedIDService(GUIService... baseServices)
    {
      this.baseServices = new HashSet<GUIService>();
      for (GUIService guiService : baseServices)
        {
          this.baseServices.add(guiService);
          lastGeneratedObjectID = Math.max(lastGeneratedObjectID, guiService.getLastGeneratedObjectID());
        }
    }

    /*****************************************
    *
    *  generateGUIManagedObjectID
    *
    *****************************************/

    public String generateID()
    {
      synchronized (this)
        {
          //
          //  update lastGeneratedObjectID
          //

          for (GUIService guiService : baseServices)
            {
              lastGeneratedObjectID = Math.max(lastGeneratedObjectID, guiService.getLastGeneratedObjectID());
            }

          //
          //  generate
          //

          lastGeneratedObjectID += 1;
          return Long.toString(lastGeneratedObjectID);
        }
    }
  }

  /*****************************************
  *
  *  class ResolvedFieldType
  *
  *****************************************/

  private class ResolvedFieldType
  {
    //
    //  attributes
    //

    private CriterionDataType dataType;
    private Set<JSONObject> availableValues;
    private List<JSONObject> associatedGroup;
    private int associatedGroupID;

    //
    //  accessors
    //

    CriterionDataType getDataType() { return dataType; }
    Set<JSONObject> getAvailableValues() { return availableValues; }
    List<JSONObject> getAssociatedGroup() { return associatedGroup; }
    int getAssociatedGroupID() { return associatedGroupID; }

    void setAssociatedGroup(List<JSONObject> associatedGroup) { this.associatedGroup = associatedGroup; }
    void setAssociatedGroupID(int associatedGroupID) { this.associatedGroupID = associatedGroupID; }

    //
    //  constructor
    //

    ResolvedFieldType(CriterionDataType dataType, List<JSONObject> availableValues)
    {
      this.dataType = dataType.getBaseType();
      this.availableValues = availableValues != null ? new HashSet<JSONObject>(availableValues) : null;
    }

    /*****************************************
    *
    *  equals
    *
    *****************************************/

    public boolean equals(Object obj)
    {
      boolean result = false;
      if (obj instanceof ResolvedFieldType)
        {
          ResolvedFieldType resolvedFieldType = (ResolvedFieldType) obj;
          result = true;
          result = result && Objects.equals(dataType, resolvedFieldType.getDataType());
          result = result && Objects.equals(availableValues, resolvedFieldType.getAvailableValues());
        }
      return result;
    }

    /*****************************************
    *
    *  hashCode
    *
    *****************************************/

    public int hashCode()
    {
      return dataType.hashCode() + (availableValues != null ? availableValues.hashCode() : 0);
    }
  }

  /*****************************************
  *
  *  class RenamedProfileCriterionField
  *
  *****************************************/

  public static class RenamedProfileCriterionField implements ReferenceDataValue<String>
  {
    /****************************************
    *
    *  data
    *
    ****************************************/

    private String criterionFieldID;
    private String display;
    private boolean deleted;

    /****************************************
    *
    *  accessors - basic
    *
    ****************************************/

    public String getCriterionFieldID() { return criterionFieldID; }
    public String getDisplay() { return display; }
    public boolean getDeleted() { return deleted; }

    //
    //  ReferenceDataValue
    //

    @Override public String getKey() { return criterionFieldID; }

    /*****************************************
    *
    *  constructor (unpack)
    *
    *****************************************/

    private RenamedProfileCriterionField(String criterionFieldID, String display, boolean deleted)
    {
      this.criterionFieldID = criterionFieldID;
      this.display = display;
      this.deleted = deleted;
    }

    /*****************************************
    *
    *  unpack
    *
    *****************************************/

    public static RenamedProfileCriterionField unpack(org.apache.kafka.connect.data.SchemaAndValue schemaAndValue)
    {
      //
      //  data
      //

      org.apache.kafka.connect.data.Schema schema = schemaAndValue.schema();
      Object value = schemaAndValue.value();
      Integer schemaVersion = (schema != null) ? com.evolving.nglm.core.SchemaUtilities.unpackSchemaVersion0(schema.version()) : null;

      //
      //  unpack
      //

      org.apache.kafka.connect.data.Struct valueStruct = (org.apache.kafka.connect.data.Struct) value;

      String criterionFieldID = valueStruct.getString("criterion_field_id");
      String display = valueStruct.getString("display");
      boolean deleted = valueStruct.getInt8("deleted").intValue() != 0;

      //
      //  return
      //

      return new RenamedProfileCriterionField(criterionFieldID, display, deleted);
    }

    @Override
    public String toString() {
      return "RenamedProfileCriterionField{" +
          "criterionFieldID='" + criterionFieldID + '\'' +
          ", display='" + display + '\'' +
          ", deleted=" + deleted +
          '}';
    }

  }
  
  /*****************************************
  *
  *  class GUIManagerContext
  *
  *****************************************/

  public static class GUIManagerContext
  {
    /*****************************************
    *
    *  data
    *
    *****************************************/

    private JourneyService journeyService;
    private SegmentationDimensionService segmentationDimensionService;
    private PointService pointService;
    private ComplexObjectTypeService complexObjectTypeService;
    private OfferService offerService;
    private ReportService reportService;
    private PaymentMeanService paymentMeanService;
    private ScoringStrategyService scoringStrategyService;
    private PresentationStrategyService presentationStrategyService;
    private CallingChannelService callingChannelService;
    private SalesChannelService salesChannelService;
    private SourceAddressService sourceAddressService;
    private SupplierService supplierService;
    private ProductService productService;
    private CatalogCharacteristicService catalogCharacteristicService;
    private ContactPolicyService contactPolicyService;
    private JourneyObjectiveService journeyObjectiveService;
    private OfferObjectiveService offerObjectiveService;
    private ProductTypeService productTypeService;
    private UCGRuleService ucgRuleService;
    private DeliverableService deliverableService;
    private TokenTypeService tokenTypeService;
    private VoucherTypeService voucherTypeService;
    private VoucherService voucherService;
    private SubscriberMessageTemplateService subscriberMessageTemplateService;
    private SubscriberProfileService subscriberProfileService;
    private SubscriberIDService subscriberIDService;
    private UploadedFileService uploadedFileService;
    private TargetService targetService;
    private CommunicationChannelBlackoutService communicationChannelBlackoutService;
    private LoyaltyProgramService loyaltyProgramService;
    private ExclusionInclusionTargetService exclusionInclusionTargetService;
    private ResellerService resellerService;
    private SegmentContactPolicyService segmentContactPolicyService;
    private CriterionFieldAvailableValuesService criterionFieldAvailableValuesService;

    /*****************************************
    *
    *  accessors
    *
    *****************************************/

    public JourneyService getJourneyService() { return journeyService; }
    public SegmentationDimensionService getSegmentationDimensionService() { return segmentationDimensionService; }
    public PointService getPointService() { return pointService; }
    public ComplexObjectTypeService getComplexObjectTypeService() { return complexObjectTypeService; }
    public OfferService getOfferService() { return offerService; }
    public ReportService getReportService() { return reportService; }
    public PaymentMeanService getPaymentMeanService() { return paymentMeanService; }
    public ScoringStrategyService getScoringStrategyService() { return scoringStrategyService; }
    public PresentationStrategyService getPresentationStrategyService() { return presentationStrategyService; }
    public CallingChannelService getCallingChannelService() { return callingChannelService; }
    public SalesChannelService getSalesChannelService() { return salesChannelService; }
    public SourceAddressService getSourceAddressService() { return sourceAddressService; }
    public SupplierService getSupplierService() { return supplierService; }
    public ProductService getProductService() { return productService; }
    public CatalogCharacteristicService getCatalogCharacteristicService() { return catalogCharacteristicService; }
    public ContactPolicyService getContactPolicyService() { return contactPolicyService; }
    public JourneyObjectiveService getJourneyObjectiveService() { return journeyObjectiveService; }
    public OfferObjectiveService getOfferObjectiveService() { return offerObjectiveService; }
    public ProductTypeService getProductTypeService() { return productTypeService; }
    public UCGRuleService getUcgRuleService() { return ucgRuleService; }
    public DeliverableService getDeliverableService() { return deliverableService; }
    public TokenTypeService getTokenTypeService() { return tokenTypeService; }
    public VoucherTypeService getVoucherTypeService() { return voucherTypeService; }
    public VoucherService getVoucherService() { return voucherService; }
    public SubscriberMessageTemplateService getSubscriberMessageTemplateService() { return subscriberMessageTemplateService; }
    public SubscriberProfileService getSubscriberProfileService() { return subscriberProfileService; }
    public SubscriberIDService getSubscriberIDService() { return subscriberIDService; }
    public UploadedFileService getUploadFileService() { return uploadedFileService; }
    public TargetService getTargetService() { return targetService; }
    public CommunicationChannelBlackoutService getCommunicationChannelBlackoutService() { return communicationChannelBlackoutService; }
    public LoyaltyProgramService getLoyaltyProgramService() { return loyaltyProgramService; }
    public ExclusionInclusionTargetService getExclusionInclusionTargetService() { return exclusionInclusionTargetService; }
    public ResellerService getPartnerService() { return resellerService; }
    public SegmentContactPolicyService getSegmentContactPolicyService() { return segmentContactPolicyService; }
    public CriterionFieldAvailableValuesService getCriterionFieldAvailableValuesService() { return criterionFieldAvailableValuesService; }
    

    /*****************************************
    *
    *  constructor
    *
    *****************************************/

    public GUIManagerContext(JourneyService journeyService, SegmentationDimensionService segmentationDimensionService, PointService pointService, ComplexObjectTypeService complexObjectTypeService, OfferService offerService, ReportService reportService, PaymentMeanService paymentMeanService, ScoringStrategyService scoringStrategyService, PresentationStrategyService presentationStrategyService, CallingChannelService callingChannelService, SalesChannelService salesChannelService, SourceAddressService sourceAddressService, SupplierService supplierService, ProductService productService, CatalogCharacteristicService catalogCharacteristicService, ContactPolicyService contactPolicyService, JourneyObjectiveService journeyObjectiveService, OfferObjectiveService offerObjectiveService, ProductTypeService productTypeService, UCGRuleService ucgRuleService, DeliverableService deliverableService, TokenTypeService tokenTypeService, VoucherTypeService voucherTypeService, VoucherService voucherService, SubscriberMessageTemplateService subscriberTemplateService, SubscriberProfileService subscriberProfileService, SubscriberIDService subscriberIDService, UploadedFileService uploadedFileService, TargetService targetService, CommunicationChannelBlackoutService communicationChannelBlackoutService, LoyaltyProgramService loyaltyProgramService, ResellerService resellerService, ExclusionInclusionTargetService exclusionInclusionTargetService, SegmentContactPolicyService segmentContactPolicyService, CriterionFieldAvailableValuesService criterionFieldAvailableValuesService)
    {
      this.journeyService = journeyService;
      this.segmentationDimensionService = segmentationDimensionService;
      this.pointService = pointService;
      this.complexObjectTypeService = complexObjectTypeService;
      this.offerService = offerService;
      this.reportService = reportService;
      this.paymentMeanService = paymentMeanService;
      this.scoringStrategyService = scoringStrategyService;
      this.presentationStrategyService = presentationStrategyService;
      this.callingChannelService = callingChannelService;
      this.salesChannelService = salesChannelService;
      this.sourceAddressService = sourceAddressService;
      this.supplierService = supplierService;
      this.productService = productService;
      this.catalogCharacteristicService = catalogCharacteristicService;
      this.contactPolicyService = contactPolicyService;
      this.journeyObjectiveService = journeyObjectiveService;
      this.offerObjectiveService = offerObjectiveService;
      this.productTypeService = productTypeService;
      this.ucgRuleService = ucgRuleService;
      this.deliverableService = deliverableService;
      this.tokenTypeService = tokenTypeService;
      this.voucherTypeService = voucherTypeService;
      this.voucherService = voucherService;
      this.subscriberMessageTemplateService = subscriberMessageTemplateService;
      this.subscriberProfileService = subscriberProfileService;
      this.subscriberIDService = subscriberIDService;
      this.uploadedFileService = uploadedFileService;
      this.targetService = targetService;
      this.communicationChannelBlackoutService = communicationChannelBlackoutService;
      this.loyaltyProgramService = loyaltyProgramService;
      this.exclusionInclusionTargetService = exclusionInclusionTargetService;
      this.resellerService = resellerService;
      this.segmentContactPolicyService = segmentContactPolicyService;
      this.criterionFieldAvailableValuesService = criterionFieldAvailableValuesService;
    }
  }

  /*****************************************
  *
  *  class GUIManagerException
  *
  *****************************************/

  public static class GUIManagerException extends Exception
  {
    /*****************************************
    *
    *  data
    *
    *****************************************/

    private String responseParameter;

    /*****************************************
    *
    *  accessors
    *
    *****************************************/

    public String getResponseParameter() { return responseParameter; }

    /*****************************************
    *
    *  constructor
    *
    *****************************************/

    public GUIManagerException(String responseMessage, String responseParameter)
    {
      super(responseMessage);
      this.responseParameter = responseParameter;
    }

    /*****************************************
    *
    *  constructor - exception
    *
    *****************************************/

    public GUIManagerException(Throwable e)
    {
      super(e.getMessage(), e);
      this.responseParameter = null;
    }

    /*****************************************
    *
    *  toString
    *
    *****************************************/

    public String toString()
    {
      return super.toString() + " (" + responseParameter + ")";
    }
  }

  /*****************************************
  *
  *  normalizeSegmentName
  *
  *****************************************/

  public static String normalizeSegmentName(String segmentName)
  {
    return segmentName.replace(" ",".").toLowerCase();
  }

  /*****************************************
  *
  *  validateURIandContext
  *
  *****************************************/

  private void validateURIandContext(HttpExchange exchange) throws GUIManagerException
  {
    String path = exchange.getRequestURI().getPath();
    if (path.endsWith("/")) path = path.substring(0, path.length()-1);

    //
    //  validate
    //

    if (! path.equals(exchange.getHttpContext().getPath()))
      {
        log.warn("invalid url {} should be {}", path, exchange.getHttpContext().getPath());
        throw new GUIManagerException("invalid URL", "404");
      }
  }

  /*****************************************
  *
  *  getDateString
  *
  *****************************************/
  @Deprecated // TODO EVPRO-99 TO BE REMOVED
  private String getDateString(Date date, int tenantID)
  {
    String result = null;
    if (date == null) return result;
    try
      {
        SimpleDateFormat dateFormat = new SimpleDateFormat(Deployment.getAPIresponseDateFormat());   // TODO EVPRO-99
        dateFormat.setTimeZone(TimeZone.getTimeZone(Deployment.getDeployment(tenantID).getTimeZone()));
        result = dateFormat.format(date);
      }
    catch (Exception e)
      {
        log.warn(e.getMessage());
      }
    return result;
  }
  
  /*****************************************
  *
  *  checkDeliverableIDs
  *
  *****************************************/

  public static boolean checkDeliverableIDs(JSONArray deliverableIDs, String idToCheck)
  {
    if(deliverableIDs != null)
      {
        for(int i=0; i<deliverableIDs.size(); i++)
          {
            if(deliverableIDs.get(i).toString().equals(idToCheck))
              {
                return true;
              }
          }
      }
    return false;
  }  

  /*****************************************
  *
  *  generateTokenChange
  *
  *****************************************/

  private void generateTokenChange(String subscriberID, Date now, String tokenCode, String userID, String action, String str, int tenantID)
  {
    if (tokenCode != null) {
      String topic = Deployment.getTokenChangeTopic();
      Serializer<StringKey> keySerializer = StringKey.serde().serializer();
      Serializer<TokenChange> valueSerializer = TokenChange.serde().serializer();
      TokenChange tokenChange = new TokenChange(subscriberID, now, "event from ".concat(Module.Customer_Care.toString()), tokenCode, action, str, "CC", Module.Customer_Care, userID, tenantID);
      kafkaProducer.send(new ProducerRecord<byte[],byte[]>(
          topic,
          keySerializer.serialize(topic, new StringKey(subscriberID)),
          valueSerializer.serialize(topic, tokenChange)
          ));
    }
  } 
  
 /************************************************************************
 *
 *  separate product and voucher  from offer json and 
 *  form a new json to create new product and new voucher with offer name.
 *
 ************************************************************************/
  public Map<String, JSONObject> splitOfferProductAndVoucher (JSONArray productJSONArray, JSONArray voucherJSONArray, JSONObject jsonRoot, String existingProductID, String existingVoucherID, int tenantID) {
    HashMap<String, JSONObject> response = new HashMap<String,JSONObject>();
    JSONObject productJSONObject = new JSONObject();
    JSONObject voucherJSONObject = new JSONObject();
    JSONObject productJSON = new JSONObject();
    JSONObject voucherJSON = new JSONObject();
    String activeSupplier = null;
    if (jsonRoot.containsKey("loginID"))
      {
        String userID = JSONUtilities.decodeString(jsonRoot, "loginID", true);
        activeSupplier = activeSupplierAndParentSupplierIDs(userID, tenantID).get("activeSupplierID");
      }
    if (productJSONArray != null &&!(productJSONArray.isEmpty()))
      {
        productJSONObject = ((JSONObject) productJSONArray.get(0));
        productJSON = JSONUtilities.decodeJSONObject(productJSONObject, "product", false);
        if (existingProductID == null) {
        String productID = productService.generateProductID();
        existingProductID = productID;
        }
        productJSON.put("id", existingProductID);
        if (jsonRoot.containsKey("loginID"))
          {
            productJSON.put("supplierID", activeSupplier);
          }
        productJSON.put("apiVersion", 1);
        productJSON.put("name", JSONUtilities.decodeString(jsonRoot, "name"));
        productJSON.put("display", JSONUtilities.decodeString(jsonRoot, "display"));
        productJSON.put("processing", JSONUtilities.decodeBoolean(jsonRoot, "processing"));
        productJSON.put("accepted", JSONUtilities.decodeBoolean(jsonRoot, "accepted"));
        productJSON.put("active", true);
        productJSON.put("readOnly", JSONUtilities.decodeBoolean(jsonRoot, "readonly"));
        productJSON.put("valid", JSONUtilities.decodeBoolean(jsonRoot, "valid"));
        productJSON.put("effectiveStartDate", JSONUtilities.decodeString(jsonRoot, "effectiveStartDate"));
        productJSON.put("effectiveEndDate", JSONUtilities.decodeString(jsonRoot, "effectiveEndDate"));
        productJSON.put("imageURL", JSONUtilities.decodeString(jsonRoot, "imageURL"));
        productJSON.put("simpleOffer", true);

      }
    if (voucherJSONArray != null && !(voucherJSONArray.isEmpty()))
      {
        voucherJSONObject = ((JSONObject) voucherJSONArray.get(0));
        voucherJSON = JSONUtilities.decodeJSONObject(voucherJSONObject, "voucher", false); 
        if (existingVoucherID == null) {
        String voucherID = voucherService.generateVoucherID();
        existingVoucherID = voucherID;
        }
        voucherJSON.put("id", existingVoucherID);
        if (jsonRoot.containsKey("loginID"))
          {
            voucherJSON.put("supplierID", activeSupplier);
          }
        voucherJSON.put("apiVersion", 1);
        voucherJSON.put("name", JSONUtilities.decodeString(jsonRoot, "name"));
        voucherJSON.put("display", JSONUtilities.decodeString(jsonRoot, "display"));
        voucherJSON.put("processing", JSONUtilities.decodeBoolean(jsonRoot, "processing"));
        voucherJSON.put("accepted", JSONUtilities.decodeBoolean(jsonRoot, "accepted"));
        voucherJSON.put("active", true);
        voucherJSON.put("readOnly", JSONUtilities.decodeBoolean(jsonRoot, "readonly"));
        voucherJSON.put("valid", JSONUtilities.decodeBoolean(jsonRoot, "valid"));
        voucherJSON.put("effectiveStartDate", JSONUtilities.decodeString(jsonRoot, "effectiveStartDate"));
        voucherJSON.put("effectiveEndDate", JSONUtilities.decodeString(jsonRoot, "effectiveEndDate"));
        voucherJSON.put("imageURL", JSONUtilities.decodeString(jsonRoot, "imageURL"));
        voucherJSON.put("simpleOffer", true);

      }
    
    response.put("productJSONObject", productJSONObject);
    response.put("productJSON",productJSON);
    response.put("voucherJSONObject", voucherJSONObject);
    response.put("voucherJSON",voucherJSON);   
    
    
    return response;
  }
  
  /************************************************************************
  *
  *  merge product and voucher  from offer json and 
  *
  ************************************************************************/
   public JSONArray mergeOfferProductAndVoucher (String id, String object, JSONObject offer, int tenantID) {
     JSONArray response = new JSONArray();
     JSONArray productJSONArray = new JSONArray();
     JSONArray voucherJSONArray = new JSONArray();
     JSONObject product = new JSONObject();     
     String activeSupplier = null;
     if (id != null && object.equals("product")) {
       JSONArray productOfferArray = (JSONArray) offer.get("products");
       JSONObject productOffer = (JSONObject) productOfferArray.get(0);
       JSONObject productJSONObject = new JSONObject();
       GUIManagedObject productObject = productService.getStoredProduct(id);
        if (productObject != null)
          {
            productJSONObject.put("supplierID", productObject.getJSONRepresentation().get("supplierID"));
            productJSONObject.put("deliverableID", productObject.getJSONRepresentation().get("deliverableID"));
            productJSONObject.put("stock", productObject.getJSONRepresentation().get("stock"));
            productJSONObject.put("unitaryCost", productObject.getJSONRepresentation().get("unitaryCost"));
            productJSONObject.put("recommendedPrice", productObject.getJSONRepresentation().get("recommendedPrice"));
            productJSONObject.put("productTypes", productObject.getJSONRepresentation().get("productTypes"));
            productJSONObject.put("termsAndConditions", productObject.getJSONRepresentation().get("termsAndConditions"));
            product.put("quantity", productOffer.get("quantity"));
            product.put("product", productJSONObject);
          }
       productJSONArray.add(product);
       response = productJSONArray;
     }
     if (id != null && object.equals("voucher")) {
       JSONArray voucherOfferArray = (JSONArray) offer.get("vouchers");
       JSONObject voucherOffer = (JSONObject) voucherOfferArray.get(0);
       JSONObject voucherJSONObject = new JSONObject();
       JSONObject voucher = new JSONObject();
       GUIManagedObject voucherObject = voucherService.getStoredVoucher(id);
        if (voucherObject != null)
          {
            voucherJSONObject.put("supplierID", voucherObject.getJSONRepresentation().get("supplierID"));
            voucherJSONObject.put("voucherTypeId", voucherObject.getJSONRepresentation().get("voucherTypeId"));
            voucherJSONObject.put("codeFormatId", voucherObject.getJSONRepresentation().get("codeFormatId"));
            voucherJSONObject.put("stock", voucherObject.getJSONRepresentation().get("stock"));
            voucherJSONObject.put("recommendedPrice", voucherObject.getJSONRepresentation().get("recommendedPrice"));
            voucherJSONObject.put("sharedCode", voucherObject.getJSONRepresentation().get("sharedCode"));
            voucher.put("quantity", voucherOffer.get("quantity"));
            voucher.put("voucher", voucherJSONObject);
          }
       voucherJSONArray.add(voucher);
       response = voucherJSONArray;
     }
     return response;
   }
  
  /************************************************************************
  *
  * method to get the product , voucher and supplierID of an offer
  *
  ************************************************************************/
  
  public Map<String, Object> OfferProductVoucherAndSupplierIDs(GUIManagedObject offer, int tenantID) {
    
    
    JSONArray offerProducts = new JSONArray();
    JSONArray offerVouchers = new JSONArray();
    
    if (offer != null && offer.getJSONRepresentation().get("products") != null) {
      offerProducts = (JSONArray) offer.getJSONRepresentation().get("products");
    }
    
    if (offer != null && offer.getJSONRepresentation().get("vouchers") != null) {
      offerVouchers = (JSONArray) offer.getJSONRepresentation().get("vouchers");
    }
    
    HashMap<String,Object> response = new HashMap<String,Object>();
    String supplierID = null;
    if (offerProducts != null && offerProducts.size() != 0)
      {
        for (Object offerProduct : offerProducts)
          {
            if (offerProduct != null && ((JSONObject) offerProduct).get("productID") != null)
              {
                String productId = ((((JSONObject) offerProduct).get("productID"))).toString();
                if (productId != null)
                  {
                    GUIManagedObject productObject = productService.getStoredProduct(productId);
                    if (productObject != null && productObject.getJSONRepresentation().get("supplierID") != null)
                      {
                            supplierID = productObject.getJSONRepresentation().get("supplierID").toString();
                            response.put("supplierID", supplierID);
                            response.put("offerProduct", offerProduct);
                            break;
                          
                      }
                  }

              }
          }
      }
    
    if (offerVouchers != null && offerVouchers.size() != 0)
      {
        for (Object offerVoucher : offerVouchers)
          {
            if (offerVoucher != null && ((JSONObject) offerVoucher).get("voucherID") != null)
              {
                String voucherId = ((((JSONObject) offerVoucher).get("voucherID"))).toString();
                if (voucherId != null)
                  {
                    GUIManagedObject voucherObject = voucherService.getStoredVoucher(voucherId);
                    if (voucherObject != null && voucherObject.getJSONRepresentation().get("supplierID") != null)
                      {
                            supplierID = voucherObject.getJSONRepresentation().get("supplierID").toString();
                            response.put("supplierID", supplierID);
                            response.put("offerVoucher", offerVoucher);
                            break;
                          
                      }
                  }
              }
          }
      }
   
    return response;
  }
  
  private boolean IsJourneyScheduleNodeCriteria(JSONObject criteriaFieldJSON)
  {
    boolean result = false;
    String id = JSONUtilities.decodeString(criteriaFieldJSON, "id", true);
    result = id.equals(CriterionContext.EVALUATION_WK_DAY_ID) || id.equals(CriterionContext.EVALUATION_TIME_ID) || id.equals(CriterionContext.EVALUATION_MONTH_ID) || id.equals(CriterionContext.EVALUATION_DAY_OF_MONTH_ID) || id.equals(CriterionContext.EVALUATION_ANIVERSARY_DAY_ID);
    return result;
  }


  /************************************************************************
   *
   * method to get the active suppler id and parentSupplier ID
   *
   ************************************************************************/
  
  public Map<String, String> activeSupplierAndParentSupplierIDs(String userID, int tenantID) {
 
    String activeSupplierID = null;
    String parentSupplierID = null;
    HashMap<String, String> response = new HashMap<String, String>();
    Date now = SystemTime.getCurrentTime();

    for (GUIManagedObject storedSupplierObject : supplierService.getStoredSuppliers(tenantID))
      {
        if (storedSupplierObject instanceof Supplier)
          {
            Supplier storedSupplier = (Supplier) storedSupplierObject;

            if (storedSupplier.getUserIDs() != null && !((storedSupplier.getUserIDs()).isEmpty()))
              {
                List<String> supplierUserIds = storedSupplier.getUserIDs();

                if (supplierUserIds.contains(userID))
                  {
                    if (supplierService.isActiveSupplier(storedSupplier, now))
                      {
                        parentSupplierID = storedSupplier.getParentSupplierID();
                        activeSupplierID = storedSupplier.getSupplierID();
                        response.put("activeSupplierID", activeSupplierID);
                        response.put("parentSupplierID", parentSupplierID);
                        break;

                      }
                    else
                      {
                        activeSupplierID = "InactiveReseller";
                        response.put("activeSupplierID", activeSupplierID);
                        response.put("parentSupplierID", parentSupplierID);
                        log.warn("The reseller is inactive" + storedSupplier.getSupplierID());
                        break;
                      }
                  }
              }

          }
      }

    return response;

  }

  public class RecurrentCampaignCreationJob extends ScheduledJob
  {
    /***********************************
     *
     * constructor
     *
     ************************************/

    public RecurrentCampaignCreationJob(String jobName, String periodicGenerationCronEntry, String baseTimeZone, boolean scheduleAtStart)
    {
      super(jobName, periodicGenerationCronEntry, baseTimeZone, scheduleAtStart);
    }

    /***********************************
     *
     * run
     *
     ************************************/

    @Override protected void run()
    {
      if (log.isDebugEnabled()) log.debug("creating recurrent campaigns");
      String tz = Deployment.getDefault().getTimeZone(); // TODO EVPRO-99 use systemTimeZone instead of baseTimeZone, is it correct ? 
      final Date now = RLMDateUtils.truncate(SystemTime.getCurrentTime(), Calendar.DATE, tz);
      int recurrentCampaignCreationDaysRange = Deployment.getRecurrentCampaignCreationDaysRange();
      Date filterStartDate = RLMDateUtils.addDays(now, -1*recurrentCampaignCreationDaysRange, tz);
      Date filterEndDate = RLMDateUtils.addDays(now, recurrentCampaignCreationDaysRange, tz);
      Collection<Journey> recurrentJourneys = journeyService.getAcceptedAndCompletedRecurrentJourneys(SystemTime.getCurrentTime(), 0);
      if(log.isDebugEnabled()) log.debug("recurrentJourneys {}", recurrentJourneys);
      for (Journey recurrentJourney : recurrentJourneys)
        {
          if (!recurrentJourney.getRecurrenceActive())
            {
              log.debug("recurrence is not active for {} - child will not be created", recurrentJourney.getGUIManagedObjectDisplay());
              continue;
            }
          
          List<Date> journeyCreationDates = new ArrayList<Date>();
          JourneyScheduler journeyScheduler = recurrentJourney.getJourneyScheduler();
          int limitCount = journeyScheduler.getNumberOfOccurrences() - recurrentJourney.getLastCreatedOccurrenceNumber();
          if (log.isDebugEnabled()) log.debug("executing creation for {}, id {}", recurrentJourney.getGUIManagedObjectDisplay(), recurrentJourney.getGUIManagedObjectID());

          //
          // limit reached
          //

          if (limitCount <= 0)
            {
              if (log.isDebugEnabled()) log.debug("limit reached");
              continue;
            }

          //
          // scheduling
          //

          String scheduling = journeyScheduler.getRunEveryUnit().toLowerCase();
          Integer scheduligInterval = journeyScheduler.getRunEveryDuration();
          List<Date> tmpJourneyCreationDates = new ArrayList<Date>();
          if ("week".equalsIgnoreCase(scheduling))
            {
              Date lastDateOfThisWk = getLastDate(now, Calendar.DAY_OF_WEEK, recurrentJourney.getTenantID());
              Date tempStartDate = recurrentJourney.getEffectiveStartDate(); //RLMDateUtils.addWeeks(recurrentJourney.getEffectiveStartDate(), scheduligInterval, tz);
              Date firstDateOfStartDateWk = getFirstDate(tempStartDate, Calendar.DAY_OF_WEEK, recurrentJourney.getTenantID());
              Date lastDateOfStartDateWk = getLastDate(tempStartDate, Calendar.DAY_OF_WEEK, recurrentJourney.getTenantID());
              while(lastDateOfThisWk.compareTo(lastDateOfStartDateWk) >= 0)
                {
                  tmpJourneyCreationDates.addAll(getExpectedCreationDates(firstDateOfStartDateWk, lastDateOfStartDateWk, scheduling, journeyScheduler.getRunEveryWeekDay(), recurrentJourney.getTenantID()));
                  tempStartDate = RLMDateUtils.addWeeks(tempStartDate, scheduligInterval, tz);
                  lastDateOfStartDateWk = getLastDate(tempStartDate, Calendar.DAY_OF_WEEK, recurrentJourney.getTenantID());
                  firstDateOfStartDateWk = getFirstDate(tempStartDate, Calendar.DAY_OF_WEEK, recurrentJourney.getTenantID());
                }
              
              //
              // handle the edge (if start day of next wk)
              //
              
              tmpJourneyCreationDates.addAll(getExpectedCreationDates(firstDateOfStartDateWk, lastDateOfStartDateWk, scheduling, journeyScheduler.getRunEveryWeekDay(), recurrentJourney.getTenantID()));
            } 
          else if ("month".equalsIgnoreCase(scheduling))
            {
              Date lastDateOfThisMonth = getLastDate(now, Calendar.DAY_OF_MONTH, recurrentJourney.getTenantID());
              Date tempStartDate = recurrentJourney.getEffectiveStartDate(); //RLMDateUtils.addMonths(recurrentJourney.getEffectiveStartDate(), scheduligInterval, tz);
              Date firstDateOfStartDateMonth = getFirstDate(tempStartDate, Calendar.DAY_OF_MONTH, recurrentJourney.getTenantID());
              Date lastDateOfStartDateMonth = getLastDate(tempStartDate, Calendar.DAY_OF_MONTH, recurrentJourney.getTenantID());
              while(lastDateOfThisMonth.compareTo(lastDateOfStartDateMonth) >= 0)
                {
                  tmpJourneyCreationDates.addAll(getExpectedCreationDates(firstDateOfStartDateMonth, lastDateOfStartDateMonth, scheduling, journeyScheduler.getRunEveryMonthDay(), recurrentJourney.getTenantID()));
                  tempStartDate = RLMDateUtils.addMonths(tempStartDate, scheduligInterval, tz);
                  firstDateOfStartDateMonth = getFirstDate(tempStartDate, Calendar.DAY_OF_MONTH, recurrentJourney.getTenantID());
                  lastDateOfStartDateMonth = getLastDate(tempStartDate, Calendar.DAY_OF_MONTH, recurrentJourney.getTenantID());
                }
              
              //
              // handle the edge (if 1st day of next month)
              //
              
              tmpJourneyCreationDates.addAll(getExpectedCreationDates(firstDateOfStartDateMonth, lastDateOfStartDateMonth, scheduling, journeyScheduler.getRunEveryMonthDay(), recurrentJourney.getTenantID()));
            }
          else if ("day".equalsIgnoreCase(scheduling))
            {
              Date lastDate = filterEndDate;
              Date tempStartDate = recurrentJourney.getEffectiveStartDate(); //RLMDateUtils.addDays(recurrentJourney.getEffectiveStartDate(), scheduligInterval, tz);
              while(lastDate.compareTo(tempStartDate) >= 0)
                {
                  tmpJourneyCreationDates.add(new Date(tempStartDate.getTime()));
                  tempStartDate = RLMDateUtils.addDays(tempStartDate, scheduligInterval, tz);
                }
            }
          else
            {
              if (log.isErrorEnabled()) log.error("invalid scheduling {}", scheduling);
            }
          
          //
          // filter out if before start date and recurrentCampaignCreationDaysRange (before / after)
          //

		  if(log.isDebugEnabled()) log.debug("before filter tmpJourneyCreationDates {}", tmpJourneyCreationDates);
          tmpJourneyCreationDates = tmpJourneyCreationDates.stream().filter(date -> date.after(recurrentJourney.getEffectiveStartDate())  && date.compareTo(filterStartDate) >= 0 && filterEndDate.compareTo(date) >= 0 ).collect(Collectors.toList());
		  if(log.isDebugEnabled()) log.debug("after filter tmpJourneyCreationDates {}", tmpJourneyCreationDates);
          
          //
          //  exists
          //
          
          Collection<Journey> recurrentSubJourneys = journeyService.getAllRecurrentJourneysByID(recurrentJourney.getJourneyID(), true, 0);
          for (Date expectedDate : tmpJourneyCreationDates)
            {
              boolean exists = false;
              for (Journey subJourney : recurrentSubJourneys)
                {
                  exists = RLMDateUtils.truncatedCompareTo(expectedDate, subJourney.getEffectiveStartDate(), Calendar.DATE, Deployment.getDeployment(subJourney.getTenantID()).getTimeZone()) == 0;
                  if (exists) break;
                }
              if (!exists && limitCount > 0)
                {
                  journeyCreationDates.add(expectedDate);
                  limitCount--;
                }
            }
          

          //
          // createJourneys
          //

          if (!journeyCreationDates.isEmpty()) createJourneys(recurrentJourney, journeyCreationDates, recurrentJourney.getLastCreatedOccurrenceNumber(), recurrentJourney.getTenantID());
        }
      if (log.isInfoEnabled())log.info("created recurrent campaigns");
    }
    
    //
    //  createJourneys
    //
    
    private void createJourneys(Journey recurrentJourney, List<Date> journeyCreationDates, Integer lastCreatedOccurrenceNumber, int tenantID)
    {
      log.info("createingJourneys of {}, for {}", recurrentJourney.getJourneyID(), journeyCreationDates);
      String timeZone = Deployment.getDeployment(tenantID).getTimeZone();
      Date rawEffectiveEntryPeriodEndDate = recurrentJourney.getRawEffectiveEntryPeriodEndDate();
      int daysBetween = RLMDateUtils.daysBetween(RLMDateUtils.truncate(recurrentJourney.getEffectiveStartDate(), Calendar.DATE, timeZone), RLMDateUtils.truncate(recurrentJourney.getEffectiveEndDate(), Calendar.DATE, timeZone), Deployment.getDeployment(tenantID).getTimeZone());
      int occurrenceNumber = lastCreatedOccurrenceNumber;
      boolean active = recurrentJourney.getActive();
      for (Date startDate : journeyCreationDates)
        {
          //
          //  prepare start and end date
          //
          
          Date endDate = RLMDateUtils.addDays(startDate, daysBetween, timeZone);
          endDate = RLMDateUtils.setField(endDate, Calendar.HOUR_OF_DAY, RLMDateUtils.getField(recurrentJourney.getEffectiveEndDate(), Calendar.HOUR_OF_DAY, timeZone), timeZone);
          endDate = RLMDateUtils.setField(endDate, Calendar.MINUTE, RLMDateUtils.getField(recurrentJourney.getEffectiveEndDate(), Calendar.MINUTE, timeZone), timeZone);
          endDate = RLMDateUtils.setField(endDate, Calendar.SECOND, RLMDateUtils.getField(recurrentJourney.getEffectiveEndDate(), Calendar.SECOND, timeZone), timeZone);
          
          startDate = RLMDateUtils.setField(startDate, Calendar.HOUR_OF_DAY, RLMDateUtils.getField(recurrentJourney.getEffectiveStartDate(), Calendar.HOUR_OF_DAY, timeZone), timeZone);
          startDate = RLMDateUtils.setField(startDate, Calendar.MINUTE, RLMDateUtils.getField(recurrentJourney.getEffectiveStartDate(), Calendar.MINUTE, timeZone), timeZone);
          startDate = RLMDateUtils.setField(startDate, Calendar.SECOND, RLMDateUtils.getField(recurrentJourney.getEffectiveStartDate(), Calendar.SECOND, timeZone), timeZone);
          
          //
          //  prepare effectiveEntryPeriodEndDate
          //
          
          Date recRawEffectiveEntryPeriodEndDate = null;
          if (rawEffectiveEntryPeriodEndDate != null)
            {
              int daysBetweenEntryPeriodEndDateAndStartDate = RLMDateUtils.daysBetween(RLMDateUtils.truncate(recurrentJourney.getEffectiveStartDate(), Calendar.DATE, timeZone), RLMDateUtils.truncate(rawEffectiveEntryPeriodEndDate, Calendar.DATE, timeZone), Deployment.getDeployment(tenantID).getTimeZone());
              recRawEffectiveEntryPeriodEndDate = RLMDateUtils.addDays(RLMDateUtils.truncate(startDate, Calendar.DATE, timeZone), daysBetweenEntryPeriodEndDateAndStartDate, timeZone);
              recRawEffectiveEntryPeriodEndDate = RLMDateUtils.setField(recRawEffectiveEntryPeriodEndDate, Calendar.HOUR_OF_DAY, RLMDateUtils.getField(rawEffectiveEntryPeriodEndDate, Calendar.HOUR_OF_DAY, timeZone), timeZone);
              recRawEffectiveEntryPeriodEndDate = RLMDateUtils.setField(recRawEffectiveEntryPeriodEndDate, Calendar.MINUTE, RLMDateUtils.getField(rawEffectiveEntryPeriodEndDate, Calendar.MINUTE, timeZone), timeZone);
              recRawEffectiveEntryPeriodEndDate = RLMDateUtils.setField(recRawEffectiveEntryPeriodEndDate, Calendar.SECOND, RLMDateUtils.getField(rawEffectiveEntryPeriodEndDate, Calendar.SECOND, timeZone), timeZone);
            }
          
          //
          //  journeyJSON
          //
          
          JSONObject journeyJSON = (JSONObject) journeyService.getJSONRepresentation(recurrentJourney).clone();
          journeyJSON.put("apiVersion", 1);
          
          //
          //  remove
          //
          
          journeyJSON.remove("recurrence");
          journeyJSON.remove("scheduler");
          journeyJSON.remove("status");
          journeyJSON.remove("recurrenceActive");
          
          //
          //  add
          //
          
          String journeyID = journeyService.generateJourneyID();
          journeyJSON.put("id", journeyID);
          journeyJSON.put("occurrenceNumber", ++occurrenceNumber);
          journeyJSON.put("name", recurrentJourney.getGUIManagedObjectName() + "_" + occurrenceNumber);
          journeyJSON.put("display", recurrentJourney.getGUIManagedObjectDisplay() + " - " + occurrenceNumber);
          journeyJSON.put("effectiveStartDate", RLMDateUtils.formatDateForREST(startDate, timeZone));
          journeyJSON.put("effectiveEndDate", RLMDateUtils.formatDateForREST(endDate, timeZone));
          journeyJSON.put("effectiveEntryPeriodEndDate", RLMDateUtils.formatDateForREST(recRawEffectiveEntryPeriodEndDate, timeZone));
          
          //
          //  create and activate
          //
          
          if (GUIManagedObjectType.BulkCampaign == recurrentJourney.getGUIManagedObjectType())
            {
              processPutBulkCampaign("0", journeyJSON, tenantID);
              processSetActive("0", journeyJSON, recurrentJourney.getGUIManagedObjectType(), active, tenantID);
              
              //
              //  lastCreatedOccurrenceNumber
              //
              
              JSONObject recJourneyJSON = (JSONObject) journeyService.getJSONRepresentation(recurrentJourney).clone();
              recJourneyJSON.put("lastCreatedOccurrenceNumber", occurrenceNumber);
              processPutBulkCampaign("0", recJourneyJSON, tenantID);
            }
          else
            {
              processPutJourney("0", journeyJSON, recurrentJourney.getGUIManagedObjectType(), tenantID);
              processSetActive("0", journeyJSON, recurrentJourney.getGUIManagedObjectType(), active, tenantID);
              
              //
              //  lastCreatedOccurrenceNumber
              //

              JSONObject recJourneyJSON = (JSONObject) journeyService.getJSONRepresentation(recurrentJourney).clone();
              recJourneyJSON.put("lastCreatedOccurrenceNumber", occurrenceNumber);
              processPutJourney("0", recJourneyJSON, recurrentJourney.getGUIManagedObjectType(), tenantID);
            }

        }
    }

    //
    //  getExpectedCreationDates
    //

    private List<Date> getExpectedCreationDates(Date firstDate, Date lastDate, String scheduling, List<String> runEveryDay, int tenantID)
    {
      List<Date> result = new ArrayList<Date>();
      while (firstDate.before(lastDate) || firstDate.compareTo(lastDate) == 0)
        {
          int day = -1;
          switch (scheduling)
            {
              case "week":
                day = RLMDateUtils.getField(firstDate, Calendar.DAY_OF_WEEK, Deployment.getDeployment(tenantID).getTimeZone());
                break;

              case "month":
                day = RLMDateUtils.getField(firstDate, Calendar.DAY_OF_MONTH, Deployment.getDeployment(tenantID).getTimeZone());
                break;

              default:
                break;
          }
          String dayOf = String.valueOf(day);
          if (runEveryDay.contains(dayOf)) result.add(new Date(firstDate.getTime()));
          firstDate = RLMDateUtils.addDays(firstDate, 1, Deployment.getDeployment(tenantID).getTimeZone());
        }

      //
      //  handle last date of month
      //

      if ("month".equalsIgnoreCase(scheduling))
        {
          int lastDayOfMonth = RLMDateUtils.getField(lastDate, Calendar.DAY_OF_MONTH, Deployment.getDeployment(tenantID).getTimeZone());
          for (String day : runEveryDay)
            {
              if (Integer.parseInt(day) > lastDayOfMonth) result.add(new Date(lastDate.getTime()));
            }
        }
      return result;
    }

    //
    //  getFirstDate
    //

    private Date getFirstDate(Date now, int dayOf, int tenantID)
    {
      if (Calendar.DAY_OF_WEEK == dayOf)
        {
          Date firstDateOfNext = RLMDateUtils.ceiling(now, dayOf, Deployment.getDeployment(tenantID).getTimeZone());
          return RLMDateUtils.addDays(firstDateOfNext, -7, Deployment.getDeployment(tenantID).getTimeZone());
        }
      else
        {
          Calendar c = Calendar.getInstance(TimeZone.getTimeZone(Deployment.getDeployment(tenantID).getTimeZone()));
          c.setTime(now);
          int dayOfMonth = RLMDateUtils.getField(now, Calendar.DAY_OF_MONTH, Deployment.getDeployment(tenantID).getTimeZone());
          Date firstDate = RLMDateUtils.addDays(now, -dayOfMonth+1, Deployment.getDeployment(tenantID).getTimeZone());
          return firstDate;
        }
    }

    //
    //  getLastDate
    //

    private Date getLastDate(Date now, int dayOf, int tenantID)
    {
      Date firstDateOfNext = RLMDateUtils.ceiling(now, dayOf, Deployment.getDeployment(tenantID).getTimeZone());
      if (Calendar.DAY_OF_WEEK == dayOf)
        {
          Date firstDateOfthisWk = RLMDateUtils.addDays(firstDateOfNext, -7, Deployment.getDeployment(tenantID).getTimeZone());
          return RLMDateUtils.addDays(firstDateOfthisWk, 6, Deployment.getDeployment(tenantID).getTimeZone());
        }
      else
        {
          Calendar c = Calendar.getInstance(TimeZone.getTimeZone(Deployment.getDeployment(tenantID).getTimeZone()));
          c.setTime(now);
          int toalNoOfDays = c.getActualMaximum(Calendar.DAY_OF_MONTH);
          int dayOfMonth = RLMDateUtils.getField(now, Calendar.DAY_OF_MONTH, Deployment.getDeployment(tenantID).getTimeZone());
          Date firstDate = RLMDateUtils.addDays(now, -dayOfMonth+1, Deployment.getDeployment(tenantID).getTimeZone());
          Date lastDate = RLMDateUtils.addDays(firstDate, toalNoOfDays-1, Deployment.getDeployment(tenantID).getTimeZone());
          return lastDate;
        }
    }
  }
  
  /*****************************************
  *
  *  ChallengesOccurrenceJob
  *
  *****************************************/
  public class ChallengesOccurrenceJob extends ScheduledJob
  {
    /***********************************
     *
     * constructor
     *
     ************************************/

    public ChallengesOccurrenceJob(String jobName, String periodicGenerationCronEntry, String baseTimeZone, boolean scheduleAtStart)
    {
      super(jobName, periodicGenerationCronEntry, baseTimeZone, scheduleAtStart);
    }

    /***********************************
     *
     * run
     *
     ************************************/

    @Override protected void run()
    {
      if (log.isDebugEnabled()) log.debug("ChallengesOccurrenceJob executing");
      String tz = Deployment.getDefault().getTimeZone(); // TODO EVPRO-99 use systemTimeZone instead of baseTimeZone, is it correct ? 
      final Date now = RLMDateUtils.truncate(SystemTime.getCurrentTime(), Calendar.DATE, tz);
      Collection<LoyaltyProgramChallenge> recurrentLoyaltyProgramChallenges = loyaltyProgramService.getActiveRecurrentChallenges(SystemTime.getCurrentTime(), 0); // tenant ID 0 means from all tenants
      if(log.isDebugEnabled()) log.debug("Challenges with Occurrence {}", recurrentLoyaltyProgramChallenges);
      for (LoyaltyProgramChallenge challenge : recurrentLoyaltyProgramChallenges)
        {
          JourneyScheduler journeyScheduler = challenge.getJourneyScheduler();
          int limitCount = journeyScheduler.getNumberOfOccurrences() - challenge.getLastCreatedOccurrenceNumber();
          
          if (limitCount <= 0)
            {
              if (log.isDebugEnabled()) log.debug("limit reached for recurrentLoyaltyProgramChallenge {}", challenge.getGUIManagedObjectDisplay());
              continue;
            }
          
          //
          //  already done?
          //
          
          if (challenge.getLastOccurrenceCreateDate() != null &&  RLMDateUtils.truncatedCompareTo(challenge.getLastOccurrenceCreateDate(), SystemTime.getCurrentTime(), Calendar.DATE, tz) == 0)
            {
              if (log.isDebugEnabled()) log.debug("ChallengesOccurrenceJob already executed for today for {}", challenge.getGUIManagedObjectDisplay());
              continue;
            }
          
          //
          // scheduling
          //
          
          String scheduling = journeyScheduler.getRunEveryUnit().toLowerCase();
          Integer scheduligInterval = journeyScheduler.getRunEveryDuration();
          List<Date> tmpOccouranceDates = new ArrayList<Date>();
          if ("week".equalsIgnoreCase(scheduling))
            {
              Date lastDateOfThisWk = getLastDate(now, Calendar.DAY_OF_WEEK, challenge.getTenantID());
              Date tempStartDate = RLMDateUtils.addWeeks(challenge.getEffectiveStartDate(), scheduligInterval, tz); //challenge.getEffectiveStartDate(); //RLMDateUtils.addWeeks(recurrentJourney.getEffectiveStartDate(), scheduligInterval, tz);
              Date firstDateOfStartDateWk = getFirstDate(tempStartDate, Calendar.DAY_OF_WEEK, challenge.getTenantID());
              Date lastDateOfStartDateWk = getLastDate(tempStartDate, Calendar.DAY_OF_WEEK, challenge.getTenantID());
              while(RLMDateUtils.truncatedCompareTo(lastDateOfThisWk, lastDateOfStartDateWk, Calendar.DATE, tz) >= 0)
                {
                  tmpOccouranceDates.addAll(getExpectedCreationDates(firstDateOfStartDateWk, lastDateOfStartDateWk, scheduling, journeyScheduler.getRunEveryWeekDay(), challenge.getTenantID()));
                  tempStartDate = RLMDateUtils.addWeeks(tempStartDate, scheduligInterval, tz);
                  lastDateOfStartDateWk = getLastDate(tempStartDate, Calendar.DAY_OF_WEEK, challenge.getTenantID());
                  firstDateOfStartDateWk = getFirstDate(tempStartDate, Calendar.DAY_OF_WEEK, challenge.getTenantID());
                }
            }
          else if ("month".equalsIgnoreCase(scheduling))
            {
              Date lastDateOfThisMonth = getLastDate(now, Calendar.DAY_OF_MONTH, challenge.getTenantID());
              Date tempStartDate = RLMDateUtils.addMonths(challenge.getEffectiveStartDate(), scheduligInterval, tz); //challenge.getEffectiveStartDate(); //RLMDateUtils.addMonths(recurrentJourney.getEffectiveStartDate(), scheduligInterval, tz);
              Date firstDateOfStartDateMonth = getFirstDate(tempStartDate, Calendar.DAY_OF_MONTH, challenge.getTenantID());
              Date lastDateOfStartDateMonth = getLastDate(tempStartDate, Calendar.DAY_OF_MONTH, challenge.getTenantID());
              while(RLMDateUtils.truncatedCompareTo(lastDateOfThisMonth, lastDateOfStartDateMonth, Calendar.DATE, tz) >= 0)
                {
                  tmpOccouranceDates.addAll(getExpectedCreationDates(firstDateOfStartDateMonth, lastDateOfStartDateMonth, scheduling, journeyScheduler.getRunEveryMonthDay(), challenge.getTenantID()));
                  tempStartDate = RLMDateUtils.addMonths(tempStartDate, scheduligInterval, tz);
                  firstDateOfStartDateMonth = getFirstDate(tempStartDate, Calendar.DAY_OF_MONTH, challenge.getTenantID());
                  lastDateOfStartDateMonth = getLastDate(tempStartDate, Calendar.DAY_OF_MONTH, challenge.getTenantID());
                }
            }
          else if ("day".equalsIgnoreCase(scheduling))
            {
              Date lastDate = RLMDateUtils.ceiling(now, Calendar.DATE, tz);
              Date tempStartDate = RLMDateUtils.addDays(challenge.getEffectiveStartDate(), scheduligInterval, tz); //challenge.getEffectiveStartDate(); //RLMDateUtils.addDays(recurrentJourney.getEffectiveStartDate(), scheduligInterval, tz);
              while(RLMDateUtils.truncatedCompareTo(lastDate, tempStartDate, Calendar.DATE, tz) >= 0)
                {
                  tmpOccouranceDates.add(new Date(tempStartDate.getTime()));
                  tempStartDate = RLMDateUtils.addDays(tempStartDate, scheduligInterval, tz);
                }
            }
          else
            {
              if (log.isErrorEnabled()) log.error("invalid scheduling {}", scheduling);
            }
          
          //
          // filter out create dates
          //
          
          tmpOccouranceDates = tmpOccouranceDates.stream().filter(date -> RLMDateUtils.truncatedCompareTo(date, challenge.getEffectiveStartDate(), Calendar.DATE, tz) != 0).collect(Collectors.toList());
          
          //
          // filter out if not today - no adv task
          //
          
          tmpOccouranceDates = tmpOccouranceDates.stream().filter(date -> RLMDateUtils.truncatedCompareTo(date, SystemTime.getCurrentTime(), Calendar.DATE, tz) == 0).collect(Collectors.toList());
          
          //
          // executeOccouranceJob
          //

          if (!tmpOccouranceDates.isEmpty()) executeChallengeOccouranceJob(challenge, tmpOccouranceDates, challenge.getLastCreatedOccurrenceNumber());
        }
      if (log.isDebugEnabled()) log.debug("All ChallengesOccurrenceJob executed");
    }
   
    //
    //  executeChallengeOccouranceJob
    //
    
    private void executeChallengeOccouranceJob(LoyaltyProgramChallenge challenge, List<Date> tmpOccouranceDates, Integer lastCreatedOccurrenceNumber)
    {
      long startTimeMili = SystemTime.getCurrentTime().getTime();
      String timeZone = Deployment.getDeployment(challenge.getTenantID()).getTimeZone();
      if (log.isInfoEnabled())
        {
          StringBuilder dtBuilders = new StringBuilder();
          tmpOccouranceDates.forEach(dt -> dtBuilders.append(RLMDateUtils.formatDateDay(dt, timeZone)).append(" "));
          log.info("execute Challenge OccouranceJob for challenge {}, for date(s) {}", challenge.getLoyaltyProgramDisplay(), dtBuilders.toString());
        }
      
      ChallengeLevel firstLevel = challenge.getFirstLevel();
      
      
      for (Date recDate : tmpOccouranceDates)
        {
          JSONObject jsonRoot = (JSONObject) challenge.getJSONRepresentation().clone();
          try
            {
              //
              //  subscriber present in this prog
              //
              
              List<String> alreadyOptInSubscriberIDs = elasticsearch.getAlreadyOptInSubscriberIDs(challenge.getLoyaltyProgramID());
              
              //
              //  update challenge for next occurrence
              //
              
              lastCreatedOccurrenceNumber++;
              jsonRoot.put("occurrenceNumber", lastCreatedOccurrenceNumber);
              jsonRoot.put("lastCreatedOccurrenceNumber", lastCreatedOccurrenceNumber);
              jsonRoot.put("name", challenge.getGUIManagedObjectName() + "_" + lastCreatedOccurrenceNumber);
              jsonRoot.put("display", challenge.getGUIManagedObjectDisplay() + " - " + lastCreatedOccurrenceNumber);
              jsonRoot.put("previousPeriodStartDate", RLMDateUtils.formatDateForREST(challenge.getLastOccurrenceCreateDate(), timeZone));
              jsonRoot.put("lastOccurrenceCreateDate", RLMDateUtils.formatDateForREST(recDate, timeZone));
              guiManagerLoyaltyReporting.processPutLoyaltyProgram("0", jsonRoot, LoyaltyProgramType.CHALLENGE, challenge.getTenantID());
              
              //
              //  execute change event for all the optin - sub
              //
              
              for (String subscriberID : alreadyOptInSubscriberIDs)
                {
                  try
                    {
                      SubscriberProfile baseSubscriberProfile = subscriberProfileService.getSubscriberProfile(subscriberID, false);
                      if (firstLevel != null)
                        {
                          String deliveryRequestID = zuks.getStringKey();
                          //int firstLevelScore = firstLevel.getScoreLevel();
                          Integer subscriberCurrnetScore = baseSubscriberProfile.getScore(challenge.getGUIManagedObjectID());
                          int scoreToDebit = subscriberCurrnetScore != null ?  subscriberCurrnetScore.intValue() : Integer.valueOf(0); //(subscriberCurrnetScore == null ? Integer.valueOf(0) :  subscriberCurrnetScore) - firstLevelScore;
                          if (scoreToDebit >= 0)
                            {
                              //
                              // SubscriberProfileForceUpdate
                              //
                              
                              SubscriberProfileForceUpdate subscriberProfileForceUpdate = new SubscriberProfileForceUpdate(baseSubscriberProfile.getSubscriberID(), SystemTime.getCurrentTime(), new ParameterMap());
                              subscriberProfileForceUpdate.getParameterMap().put("score", scoreToDebit*-1);
                              subscriberProfileForceUpdate.getParameterMap().put("challengeID", challenge.getGUIManagedObjectID());
                              subscriberProfileForceUpdate.getParameterMap().put("isPeriodChange", Boolean.TRUE);
                              
                              //
                              //  send
                              //
                              
                              kafkaProducer.send(new ProducerRecord<byte[], byte[]>(Deployment.getSubscriberProfileForceUpdateTopic(), StringKey.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), new StringKey(subscriberProfileForceUpdate.getSubscriberID())), SubscriberProfileForceUpdate.serde().serializer().serialize(Deployment.getSubscriberProfileForceUpdateTopic(), subscriberProfileForceUpdate)));
                            }
                          }
                    } 
                  catch (SubscriberProfileServiceException e)
                    {
                      log.error("SubscriberProfileServiceException {}", e.getMessage());
                    }
                }
            } 
          catch (ElasticsearchClientException e)
            {
              e.printStackTrace();
              if (log.isErrorEnabled()) log.error("for this exception {} challenge job failed - will retry next if scheduled", e.getMessage());
            }
        }
      if(log.isInfoEnabled()) log.info("executed Challenge OccouranceJob for challenge {}, time taken {} milisec", challenge.getLoyaltyProgramDisplay(), SystemTime.getCurrentTime().getTime() - startTimeMili);
    }

    //
    //  getExpectedCreationDates
    //
    
    private List<Date> getExpectedCreationDates(Date firstDate, Date lastDate, String scheduling, List<String> runEveryDay, int tenantID)
    {
      String tz = Deployment.getDeployment(tenantID).getTimeZone();
      List<Date> result = new ArrayList<Date>();
      while (firstDate.before(lastDate) || firstDate.compareTo(lastDate) == 0)
        {
          int day = -1;
          switch (scheduling)
            {
              case "week":
                day = RLMDateUtils.getField(firstDate, Calendar.DAY_OF_WEEK, tz);
                break;
                
              case "month":
                day = RLMDateUtils.getField(firstDate, Calendar.DAY_OF_MONTH, tz);
                break;

              default:
                break;
          }
          String dayOf = String.valueOf(day);
          if (runEveryDay.contains(dayOf)) result.add(new Date(firstDate.getTime()));
          firstDate = RLMDateUtils.addDays(firstDate, 1, tz);
        }
      
      //
      //  handle last date of month
      //
      
      if ("month".equalsIgnoreCase(scheduling))
        {
          int lastDayOfMonth = RLMDateUtils.getField(lastDate, Calendar.DAY_OF_MONTH, tz);
          for (String day : runEveryDay)
            {
              if (Integer.parseInt(day) > lastDayOfMonth) result.add(new Date(lastDate.getTime()));
            }
        }
      return result;
    }
    
    //
    //  getFirstDate
    //
    
    private Date getFirstDate(Date now, int dayOf, int tenantID)
    {
      String tz = Deployment.getDeployment(tenantID).getTimeZone();
      if (Calendar.DAY_OF_WEEK == dayOf)
        {
          Date firstDateOfNext = RLMDateUtils.ceiling(now, dayOf, tz);
          return RLMDateUtils.addDays(firstDateOfNext, -7, tz);
        }
      else
        {
          Calendar c = Calendar.getInstance(TimeZone.getTimeZone(tz));
          c.setTime(now);
          int dayOfMonth = RLMDateUtils.getField(now, Calendar.DAY_OF_MONTH, tz);
          Date firstDate = RLMDateUtils.addDays(now, -dayOfMonth+1, tz);
          return firstDate;
        }
    }
    
    //
    //  getLastDate
    //
    
    private Date getLastDate(Date now, int dayOf, int tenantID)
    {
      String tz = Deployment.getDeployment(tenantID).getTimeZone();
      Date firstDateOfNext = RLMDateUtils.ceiling(now, dayOf, tz);
      if (Calendar.DAY_OF_WEEK == dayOf)
        {
          Date firstDateOfthisWk = RLMDateUtils.addDays(firstDateOfNext, -7, tz);
          return RLMDateUtils.addDays(firstDateOfthisWk, 6, tz);
        }
      else
        {
          Calendar c = Calendar.getInstance(TimeZone.getTimeZone(tz));
          c.setTime(now);
          int toalNoOfDays = c.getActualMaximum(Calendar.DAY_OF_MONTH);
          int dayOfMonth = RLMDateUtils.getField(now, Calendar.DAY_OF_MONTH, tz);
          Date firstDate = RLMDateUtils.addDays(now, -dayOfMonth+1, tz);
          Date lastDate = RLMDateUtils.addDays(firstDate, toalNoOfDays-1, tz);
          return lastDate;
        }
    }
    
  }
  
  /*****************************************
  *
  *  processPutSimpleOffer
  *
  *****************************************/
  
  private JSONObject processPutSimpleOffer(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    Date now = SystemTime.getCurrentTime();
    HashMap<String, Object> response = new HashMap<String, Object>();    
    boolean offerCanBeModified = true;
    String existingProductID = null;
    String existingVoucherID = null;
    String existingSupplierID = null;
    Boolean dryRun = false;
    boolean productCreated = false;
    boolean voucherCreated = false;  
    boolean productOfferFlag = false;
    boolean voucherOfferFlag = false;
    

    jsonRoot.put("simpleOffer", true);

    /*****************************************
    *
    *  dryRun
    *
    *****************************************/
    if (jsonRoot.containsKey("dryRun")) {
      dryRun = JSONUtilities.decodeBoolean(jsonRoot, "dryRun", false);
    }

    
    /*****************************************
     *
     * offerID
     *
     *****************************************/

    String offerID = JSONUtilities.decodeString(jsonRoot, "id", false);
    if (offerID == null)
      {
        offerID = offerService.generateOfferID();
        jsonRoot.put("id", offerID);
      }

    /*****************************************
     *
     * existing offer
     *
     *****************************************/

    GUIManagedObject existingOffer = offerService.getStoredOffer(offerID);
    
    
    /**********************************************************************************************
     * 
     * The existing product or voucher ID
     * 
     * 
     **********************************************************************************************/
    if (existingOffer != null)
      {
            Map<String, Object> OfferProductVoucherAndSupplierIDs = OfferProductVoucherAndSupplierIDs(existingOffer, tenantID);
            existingSupplierID = (String) OfferProductVoucherAndSupplierIDs.get("supplierID");
            JSONObject product = (JSONObject) OfferProductVoucherAndSupplierIDs.get("offerProduct");
            JSONObject voucher = (JSONObject) OfferProductVoucherAndSupplierIDs.get("offerVoucher");
            if (product != null && product.get("productID") != null)
              {
                existingProductID = product.get("productID").toString();
              }
            if (voucher != null && voucher.get("voucherID") != null)
              {
                existingVoucherID = voucher.get("voucherID").toString();
              }
         
      }
    

    /*****************************************
     *
     * read-only
     *
     *****************************************/

    if (existingOffer != null  && existingOffer.getReadOnly()) 
      {
        response.put("id", existingOffer.getGUIManagedObjectID());
        response.put("accepted", existingOffer.getAccepted());
        response.put("valid", existingOffer.getAccepted());
        response.put("processing", offerService.isActiveOffer(existingOffer, now));
        response.put("responseCode", "failedReadOnly");
        return JSONUtilities.encodeObject(response);
      }

    /*****************************************
     *
     * process offer
     *
     *****************************************/

    long epoch = epochServer.getKey();
    


    JSONArray productJSONArray = JSONUtilities.decodeJSONArray(jsonRoot, "products", false); // to separate the products from the input json
    JSONArray voucherJSONArray = JSONUtilities.decodeJSONArray(jsonRoot, "vouchers", false); // to separate the voucher from the input json

    Map<String, JSONObject> OfferProductAndVoucher = splitOfferProductAndVoucher(productJSONArray, voucherJSONArray,
        jsonRoot, existingProductID, existingVoucherID, tenantID);

    JSONObject productJSON = OfferProductAndVoucher.get("productJSON"); // JSONObject to create a new product with offer name
    JSONObject voucherJSON = OfferProductAndVoucher.get("voucherJSON"); // JSONObject to create a new voucher with offer name

    JSONObject productsJSONObject = (JSONObject) (OfferProductAndVoucher.get("productJSONObject")); // to get the product quantity
    JSONObject vouchersJSONObject = (JSONObject) (OfferProductAndVoucher.get("voucherJSONObject")); // to get the voucher quantity
    
    try
      {

        JSONObject result = new JSONObject();

        /***********************************
         * 
         * create Offer with product *
         * 
         ********************************/

        if (productJSON != null && !(productJSON.isEmpty()))
          {
            /*****************************************
             *
             * existing product
             *
             *****************************************/

            GUIManagedObject existingVoucher = null;
            GUIManagedObject existingProduct = null;
            productOfferFlag = true;

            if (existingVoucherID != null)
              {
                existingVoucher = voucherService.getStoredVoucher(existingVoucherID);
              }
            if (existingProductID != null)
              {
                existingProduct = productService.getStoredProduct(existingProductID);
              }

            if (existingVoucher != null)
              {
                voucherService.removeVoucher(existingVoucherID, userID, uploadedFileService, tenantID);
              }
            


            /************************************************
             * 
             * store offer with the new product embedded
             * 
             ***********************************************/
            JSONObject newProductJSONObject = new JSONObject();
            newProductJSONObject.put("quantity", productsJSONObject.get("quantity"));            
            newProductJSONObject.put("productID", productJSON.get("id"));
            JSONArray newProductJSONArray = new JSONArray();
            newProductJSONArray.add(newProductJSONObject);
            jsonRoot.replace("products", newProductJSONArray);
            

            Product product = new Product(productJSON, epoch, existingProduct, deliverableService,
                catalogCharacteristicService, tenantID);
            /*****************************************
             *
             * store product
             *
             *****************************************/
            if (!dryRun)
              {

                productService.putProduct(product, supplierService, productTypeService, deliverableService,
                    (existingProduct == null), userID);
              }

            productCreated = true;
            Offer productOffer = new Offer(jsonRoot, epoch, existingOffer, catalogCharacteristicService, tenantID);

            /*****************************************
             *
             * store
             *
             *****************************************/
            if (!dryRun)
              {
                offerService.putOffer(productOffer, callingChannelService, salesChannelService, productService,
                    voucherService, (existingOffer == null), userID);
              }

            /*****************************************
             *
             * response
             *
             *****************************************/

            response.put("id", productOffer.getOfferID());
            response.put("accepted", productOffer.getAccepted());
            response.put("valid", productOffer.getAccepted());
            response.put("processing", offerService.isActiveOffer(productOffer, now));
            response.put("responseCode", "ok");
          }

        /*******************************
         * 
         * create Offer with voucher
         * 
         * 
         ******************************/

        if (voucherJSON != null && !(voucherJSON.isEmpty()))
          {
            /*****************************************
             *
             * existing voucher
             *
             *****************************************/

            GUIManagedObject existingVoucher = null;
            GUIManagedObject existingProduct = null;
            voucherOfferFlag = true;

            if (existingVoucherID != null)
              {
                existingVoucher = voucherService.getStoredVoucher(existingVoucherID);
              }
            if (existingProductID != null)
              {
                existingProduct = productService.getStoredProduct(existingProductID);
              }
            
            if (existingProduct != null)
              {
                productService.removeProduct(existingProductID, userID, tenantID);
              }
            

            /************************************************
             * 
             * store offer with the new voucher embedded
             * 
             ***********************************************/

            JSONObject newVoucherJSONObject = new JSONObject();
            newVoucherJSONObject.put("quantity", vouchersJSONObject.get("quantity"));
            newVoucherJSONObject.put("voucherID", voucherJSON.get("id"));
            JSONArray newVoucherJSONArray = new JSONArray();
            newVoucherJSONArray.add(newVoucherJSONObject);
            jsonRoot.replace("vouchers", newVoucherJSONArray);

            /**********************************
             * 
             * create a voucher with offer name
             * 
             * 
             **************************************/

            VoucherType voucherType = voucherTypeService
                .getActiveVoucherType(JSONUtilities.decodeString(voucherJSON, "voucherTypeId", true), now);
            if (log.isDebugEnabled())
              log.debug("will use voucherType " + voucherType);

            // voucherType issue
            if (voucherType == null || voucherType.getCodeType() == VoucherType.CodeType.Unknown)
              {
                response.put("responseCode", "voucherTypeNotFound");
                return JSONUtilities.encodeObject(response);
              }

            Voucher voucher = null;
            if (voucherType.getCodeType() == VoucherType.CodeType.Shared)
              {
                voucher = new VoucherShared(voucherJSON, epoch, existingVoucher, tenantID);
                if (log.isDebugEnabled())
                  log.debug("will put shared voucher " + voucher);
              }
            if (voucher == null && voucherType.getCodeType() == VoucherType.CodeType.Personal)
              {
                voucher = new VoucherPersonal(voucherJSON, epoch, existingVoucher, voucherType, tenantID);
                if (log.isDebugEnabled())
                  log.debug("will put personal voucher " + voucher);
              }

            voucher.validate(voucherTypeService, uploadedFileService, now);

            /************************
             * 
             * store voucher
             * 
             **********************/
            if (!dryRun)
              {
                voucherService.putVoucher(voucher, (existingVoucher == null), userID);
              }


            Offer voucherOffer = new Offer(jsonRoot, epoch, existingOffer, catalogCharacteristicService, tenantID);

            /*****************************************
             *
             * store
             *
             *****************************************/
            if (!dryRun)
              {

                offerService.putOffer(voucherOffer, callingChannelService, salesChannelService, productService,
                    voucherService, (existingOffer == null), userID);
              }
            voucherCreated = true;

            /*****************************************
             *
             * response
             *
             *****************************************/

            response.put("id", voucherOffer.getOfferID());
            response.put("accepted", voucherOffer.getAccepted());
            response.put("valid", voucherOffer.getAccepted());
            response.put("processing", offerService.isActiveOffer(voucherOffer, now));
            response.put("responseCode", "ok");

          }

        return JSONUtilities.encodeObject(response);

      }
    catch (JSONUtilitiesException | GUIManagerException e)
      {
        //
        // incompleteObject
        //

        IncompleteObject incompleteObject = new IncompleteObject(jsonRoot, epoch, tenantID);
        
        //
        // store
        //
        if (!dryRun)
          {
            if (!productCreated && productOfferFlag)
              {

                GUIManagedObject existingVoucher = null;
                GUIManagedObject existingProduct = null;
                if (existingVoucherID != null)
                  {
                    existingVoucher = voucherService.getStoredVoucher(existingVoucherID);
                  }
                if (existingProductID != null)
                  {
                    existingProduct = productService.getStoredProduct(existingProductID);
                  }

                if (existingVoucher != null)
                  {
                    voucherService.removeVoucher(existingVoucherID, userID, uploadedFileService, tenantID);
                  }

                IncompleteObject incompleteObjectProduct = new IncompleteObject(productJSON, epoch, tenantID);
                productService.putProduct(incompleteObjectProduct, supplierService, productTypeService,
                    deliverableService, (existingProduct == null), userID);
              }
            if (!voucherCreated && voucherOfferFlag)
              {
                GUIManagedObject existingVoucher = null;
                GUIManagedObject existingProduct = null;
                voucherOfferFlag = true;

                if (existingVoucherID != null)
                  {
                    existingVoucher = voucherService.getStoredVoucher(existingVoucherID);
                  }
                if (existingProductID != null)
                  {
                    existingProduct = productService.getStoredProduct(existingProductID);
                  }

                if (existingProduct != null)
                  {
                    productService.removeProduct(existingProductID, userID, tenantID);
                  }
                IncompleteObject incompleteObjectVoucher = new IncompleteObject(voucherJSON, epoch, tenantID);
                voucherService.putVoucher(incompleteObjectVoucher, (existingVoucher == null), userID);
              }
            offerService.putOffer(incompleteObject, callingChannelService, salesChannelService, productService,
                voucherService, (existingOffer == null), userID);
          }

        //
        // log
        //

        StringWriter stackTraceWriter = new StringWriter();
        e.printStackTrace(new PrintWriter(stackTraceWriter, true));
        log.warn("Exception processing REST api: {}", stackTraceWriter.toString());

        //
        // response
        //

        response.put("id", incompleteObject.getGUIManagedObjectID());
        response.put("responseCode", "offerNotValid");
        response.put("responseMessage", e.getMessage());
        response.put("responseParameter",
            (e instanceof GUIManagerException) ? ((GUIManagerException) e).getResponseParameter() : null);
        return JSONUtilities.encodeObject(response);
      }
  }
  
  /*****************************************
  *
  *  processGetSimpleOffer
  *
  *****************************************/

  private JSONObject processGetSimpleOffer(String userID, JSONObject jsonRoot, boolean includeArchived, int tenantID)
  {
    /****************************************
    *
    *  response
    *
    ****************************************/

    HashMap<String,Object> response = new HashMap<String,Object>();

    /****************************************
    *
    *  argument
    *
    ****************************************/

    String offerID = JSONUtilities.decodeString(jsonRoot, "id", true);
    JSONObject offerJSON = new JSONObject();
    boolean simpleOffer = false;

    /*****************************************
    *
    *  retrieve and decorate offer
    *
    *****************************************/

    GUIManagedObject offerObject = offerService.getStoredOffer(offerID, includeArchived);

    if (offerObject != null )
      {
        if (offerObject != null && offerObject.getJSONRepresentation().get("simpleOffer") != null)
          {
            simpleOffer = (boolean) offerObject.getJSONRepresentation().get("simpleOffer");
          }
        Map<String, Object> OfferProductVoucherAndSupplierIDs = OfferProductVoucherAndSupplierIDs(offerObject, tenantID);
        JSONObject product = (JSONObject) OfferProductVoucherAndSupplierIDs.get("offerProduct");
        JSONObject voucher = (JSONObject) OfferProductVoucherAndSupplierIDs.get("offerVoucher");
        
        String offerName = offerObject.getGUIManagedObjectName();
        if (product != null && product.get("productID") != null)
          {
            String productID = product.get("productID").toString();
            String productName = (productService.getStoredProduct(productID)).getGUIManagedObjectName();

            if (simpleOffer == true && offerName.equals(productName))
              {
                offerJSON = offerService.generateResponseJSON(offerObject, true, SystemTime.getCurrentTime());                
                JSONArray productJSONArray = mergeOfferProductAndVoucher(productID, "product",offerJSON, tenantID); 
                offerJSON.put("products", productJSONArray);               
                
              }
            else
              {
                response.put("responseCode", RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseCode());
                response.put("responseMessage",
                    RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseMessage());
                return JSONUtilities.encodeObject(response);
              }
          }
        if (voucher != null && voucher.get("voucherID") != null)
          {
            String voucherID = voucher.get("voucherID").toString();
            String voucherName = (voucherService.getStoredVoucher(voucherID)).getGUIManagedObjectName();

            if (simpleOffer && offerName.equals(voucherName))
              {
                offerJSON = offerService.generateResponseJSON(offerObject, true, SystemTime.getCurrentTime());
                JSONArray voucherJSONArray = mergeOfferProductAndVoucher(voucherID, "voucher", offerJSON, tenantID);                 
                offerJSON.put("vouchers", voucherJSONArray); 
              }
            else
              {
                response.put("responseCode", RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseCode());
                response.put("responseMessage",
                    RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseMessage());
                return JSONUtilities.encodeObject(response);
              }

          }

      } 
    
    

    /*****************************************
    *
    *  response
    *
    *****************************************/
    response.put("responseCode", (offerObject != null) ? "ok" : "offerNotFound");
    if (offerObject != null) response.put("simpleOffer", offerJSON);
    return JSONUtilities.encodeObject(response);
   
  }

  
  /*****************************************
  *
  *  processGetSimpleOfferList
  *
  *****************************************/
  private JSONObject processGetSimpleOfferList(String userID, JSONObject jsonRoot, boolean fullDetails, boolean includeArchived, int tenantID)
  {

    /****************************************
     *
     * response
     *
     ****************************************/

    Map<String, Object> response = new HashMap<String, Object>();
    Collection<GUIManagedObject> offerObjects = new ArrayList<>();
    List<OfferProduct> products = new ArrayList<>();
    List<OfferVoucher> vouchers = new ArrayList<>();
    List<JSONObject> offers = new ArrayList<JSONObject>();
    Date now = SystemTime.getCurrentTime();
    boolean simpleOffer = false;
    
    if (jsonRoot.containsKey("ids"))
      {
        JSONArray offerIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids");
        for (int i = 0; i < offerIDs.size(); i++)
          {
            String offerID = offerIDs.get(i).toString();
            GUIManagedObject offerObject = offerService.getStoredOffer(offerID, includeArchived);
            if (offerObject != null && offerObject.getTenantID() == tenantID)
              {

                offerObjects.add(offerObject);
              }
          }
      }
    else
      {
        offerObjects = offerService.getStoredOffers(includeArchived, tenantID);
      }
    
    for (GUIManagedObject offerObject : offerObjects)
      {
        if (offerObject != null && offerObject.getJSONRepresentation().get("simpleOffer") != null)
          {
            simpleOffer = (boolean) offerObject.getJSONRepresentation().get("simpleOffer");
          }
        
        Map<String, Object> OfferProductVoucherAndSupplierIDs = OfferProductVoucherAndSupplierIDs(offerObject, tenantID);
        JSONObject product = (JSONObject) OfferProductVoucherAndSupplierIDs.get("offerProduct");
        JSONObject voucher = (JSONObject) OfferProductVoucherAndSupplierIDs.get("offerVoucher");
        String offerName = offerObject.getGUIManagedObjectName();
        if (product != null && product.get("productID") != null)
          {
            String productID = product.get("productID").toString();
            String productName = (productService.getStoredProduct(productID)).getGUIManagedObjectName();

            if (simpleOffer && offerName.equals(productName))
              {
                JSONObject offerJSON = offerService.generateResponseJSON(offerObject, fullDetails, now);
                if (!fullDetails)
                  {
                    if (offerObject.getJSONRepresentation().get("simpleOffer") != null)
                      {
                        offerJSON.put("simpleOffer", offerObject.getJSONRepresentation().get("simpleOffer"));
                      }
                    else
                      {
                        offerJSON.put("simpleOffer", "");
                      }
                  }
                if (fullDetails)
                  {
                    JSONArray productJSONArray = mergeOfferProductAndVoucher(productID, "product", offerJSON, tenantID);
                    offerJSON.put("products", productJSONArray);
                  }
                offers.add(offerJSON);
              }
            else
              {
                if (log.isDebugEnabled())
                  log.debug(offerObject + " is not supplierOffer");
              }
          }
        if (voucher != null && voucher.get("voucherID") != null)
          {
            String voucherID = voucher.get("voucherID").toString();
            String voucherName = (voucherService.getStoredVoucher(voucherID)).getGUIManagedObjectName();

            if (simpleOffer && offerName.equals(voucherName))
              {
                JSONObject offerJSON = offerService.generateResponseJSON(offerObject, fullDetails, now);
                if (!fullDetails)
                  {
                    if (offerObject.getJSONRepresentation().get("simpleOffer") != null)
                      {
                        offerJSON.put("simpleOffer", simpleOffer);
                      }
                    else
                      {
                        offerJSON.put("simpleOffer", "");
                      }
                  }
                if (fullDetails)
                  {
                    JSONArray voucherJSONArray = mergeOfferProductAndVoucher(voucherID, "voucher", offerJSON, tenantID);
                    offerJSON.put("vouchers", voucherJSONArray);
                  }

                offers.add(offerJSON);
              }
            else
              {
                if (log.isDebugEnabled())
                  log.debug(offerObject + " is not supplierOffer");
              }

          }

      }

    /*****************************************
     *
     * decorate offers response
     *
     *****************************************/
    response.put("responseCode", "ok");
    response.put("simpleOffers", JSONUtilities.encodeArray(offers));
    return JSONUtilities.encodeObject(response);
  }
  
  /*****************************************
  *
  *  processRemoveSimpleOffer
  *
  *****************************************/

  private JSONObject processRemoveSimpleOffer(String userID, JSONObject jsonRoot, int tenantID)
  {
    /****************************************
     *
     * response
     *
     ****************************************/

    HashMap<String, Object> response = new HashMap<String, Object>();

    /****************************************
     *
     * argument
     *
     ****************************************/
    boolean force = JSONUtilities.decodeBoolean(jsonRoot, "force", Boolean.FALSE);
    Date now = SystemTime.getCurrentTime();
    // Offer offer = null;
    String responseCode = "";
    String singleIDresponseCode = "";
    List<GUIManagedObject> offers = new ArrayList<>();
    List<String> validIDs = new ArrayList<>();
    JSONArray offerIDs = new JSONArray();
    boolean simpleOffer = false;

    /*****************************************
     *
     * remove
     *
     *****************************************/
    //
    // remove single offer
    //
    if (jsonRoot.containsKey("id"))
      {
        String offerID = JSONUtilities.decodeString(jsonRoot, "id", false);
        offerIDs.add(offerID);
        GUIManagedObject offerObject = offerService.getStoredOffer(offerID);
        if (offerObject != null && (force || !offerObject.getReadOnly()))
          singleIDresponseCode = "ok";
        else if (offerObject != null)
          singleIDresponseCode = "failedReadOnly";
        else
          {
            singleIDresponseCode = "offerNotFound";

          }
      }
    //
    // multiple deletion
    //

    if (jsonRoot.containsKey("ids"))
      {
        offerIDs = JSONUtilities.decodeJSONArray(jsonRoot, "ids", false);
      }

    for (int i = 0; i < offerIDs.size(); i++)
      {
        String offerID = offerIDs.get(i).toString();
        GUIManagedObject offerObject = offerService.getStoredOffer(offerID);

        if (offerObject != null && (force || !offerObject.getReadOnly()))
          {

            offers.add(offerObject);            
          }
      }
    /*****************************************
     *
     * remove
     *
     *****************************************/
    for (int i = 0; i < offers.size(); i++)
      {
        GUIManagedObject offerObject = offers.get(i);
        if (offerObject != null)
          {
            if (offerObject != null && offerObject.getJSONRepresentation().get("simpleOffer") != null)
              {
                simpleOffer = (boolean) offerObject.getJSONRepresentation().get("simpleOffer");
              }
            
            String offerName = offerObject.getGUIManagedObjectName();
            Map<String, Object> OfferProductVoucherAndSupplierIDs = OfferProductVoucherAndSupplierIDs(offerObject, tenantID);
            JSONObject product = (JSONObject) OfferProductVoucherAndSupplierIDs.get("offerProduct");
            JSONObject voucher = (JSONObject) OfferProductVoucherAndSupplierIDs.get("offerVoucher");

            if (product != null && product.get("productID") != null)
              {
                String productID = product.get("productID").toString();
                String productName = (productService.getStoredProduct(productID)).getGUIManagedObjectName();
                if (simpleOffer && offerName.equals(productName))
                  {
                    String productId = product.get("productID").toString();
                    productService.removeProduct(productId, userID, tenantID);
                    offerService.removeOffer(offerObject.getGUIManagedObjectID(), userID, tenantID);
                    validIDs.add(offerObject.getGUIManagedObjectID());
                  }
                else if (!simpleOffer && jsonRoot.containsKey("id"))
                  {
                    response.put("responseCode", RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseCode());
                    response.put("responseMessage",
                        RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseMessage());
                    return JSONUtilities.encodeObject(response);
                  }
                else
                  {
                    if (log.isDebugEnabled())
                      {
                        log.debug(offerObject + "is not a simple offer");
                      }
                  }
              }
            if (voucher != null && voucher.get("voucherID") != null)
              {
                String voucherID = voucher.get("voucherID").toString();
                String voucherName = (voucherService.getStoredVoucher(voucherID)).getGUIManagedObjectName();

                if (simpleOffer && offerName.equals(voucherName))
                  {
                    String voucherId = voucher.get("voucherID").toString();
                    voucherService.removeVoucher(voucherId, userID, uploadedFileService, tenantID);
                    offerService.removeOffer(offerObject.getGUIManagedObjectID(), userID, tenantID);
                    validIDs.add(offerObject.getGUIManagedObjectID());
                  }

                else if (!simpleOffer && jsonRoot.containsKey("id"))
                  {
                    response.put("responseCode", RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseCode());
                    response.put("responseMessage",
                        RESTAPIGenericReturnCodes.OFFER_UNKNOWN.getGenericResponseMessage());
                    return JSONUtilities.encodeObject(response);
                  }
                else
                  {
                    if (log.isDebugEnabled())
                      {
                        log.debug(offerObject + "is not a simple offer");
                      }
                  }

              }
          }
      }
    /*****************************************
     *
     * responseCode
     *
     *****************************************/
    if (jsonRoot.containsKey("id"))
      {
        response.put("responseCode", singleIDresponseCode);
        return JSONUtilities.encodeObject(response);
      }

    else
      {
        response.put("responseCode", "ok");
      }

    /*****************************************
     *
     * response
     *
     *****************************************/

    response.put("removedOfferIDs", JSONUtilities.encodeArray(validIDs));
    return JSONUtilities.encodeObject(response);

  }
  
  public JSONObject processSoftwareVersions(String userID, JSONObject jsonRoot, int tenantID)
  {
    Map<String, Object> response = new LinkedHashMap<String, Object>();
    response.put("evolutionVersion", com.evolving.nglm.core.Deployment.getEvolutionVersion());
    response.put("customerVersion", com.evolving.nglm.core.Deployment.getDeployment(tenantID).getCustomerVersion());
    return JSONUtilities.encodeObject(response);
  }
}

